{"culture":"NIOEmbedded","dependencies":[{"package":"swift-nio","modules":["NIOConcurrencyHelpers","NIOCore","_NIODataStructures"]}],"extensions":[],"partitions":[{"namespace":"NIOEmbedded","communities":[{"community":"enum","startIndex":0,"endIndex":2},{"community":"struct","startIndex":2,"endIndex":4},{"community":"class","startIndex":4,"endIndex":6},{"community":"enum.case","startIndex":6,"endIndex":10},{"community":"init","startIndex":10,"endIndex":14},{"community":"property","startIndex":14,"endIndex":32},{"community":"method","startIndex":32,"endIndex":52},{"community":"type.op","startIndex":52,"endIndex":53}]}],"identifiers":["s11NIOEmbedded15EmbeddedChannelC11BufferStateO","s11NIOEmbedded15EmbeddedChannelC13LeftOverStateO","s11NIOEmbedded15EmbeddedChannelC14WrongTypeErrorV","s11NIOEmbedded15EmbeddedChannelC18SynchronousOptionsV","s11NIOEmbedded15EmbeddedChannelC","s11NIOEmbedded17EmbeddedEventLoopC","s11NIOEmbedded15EmbeddedChannelC11BufferStateO4fullyAESay7NIOCore6NIOAnyVGcAEmF","s11NIOEmbedded15EmbeddedChannelC11BufferStateO5emptyyA2EmF","s11NIOEmbedded15EmbeddedChannelC13LeftOverStateO5cleanyA2EmF","s11NIOEmbedded15EmbeddedChannelC13LeftOverStateO9leftOversyAESay7NIOCore6NIOAnyVG_A2JtcAEmF","s11NIOEmbedded15EmbeddedChannelC14WrongTypeErrorV8expected6actualAEypXp_ypXptcfc","s11NIOEmbedded15EmbeddedChannelC7handler4loopAC7NIOCore0C7Handler_pSg_AA0B9EventLoopCtcfc","s11NIOEmbedded15EmbeddedChannelC8handlers4loopACSay7NIOCore0C7Handler_pG_AA0B9EventLoopCtcfc","s11NIOEmbedded17EmbeddedEventLoopCACycfc","s11NIOEmbedded15EmbeddedChannelC10isWritableSbvp","s11NIOEmbedded15EmbeddedChannelC11BufferStateO6isFullSbvp","s11NIOEmbedded15EmbeddedChannelC11BufferStateO7isEmptySbvp","s11NIOEmbedded15EmbeddedChannelC11closeFuture7NIOCore09EventLoopE0CyytGvp","s11NIOEmbedded15EmbeddedChannelC11syncOptions7NIOCore014NIOSynchronouscE0_pSgvp","s11NIOEmbedded15EmbeddedChannelC12localAddress7NIOCore06SocketE0OSgvp","s11NIOEmbedded15EmbeddedChannelC13LeftOverStateO03hasD5OversSbvp","s11NIOEmbedded15EmbeddedChannelC13LeftOverStateO7isCleanSbvp","s11NIOEmbedded15EmbeddedChannelC13remoteAddress7NIOCore06SocketE0OSgvp","s11NIOEmbedded15EmbeddedChannelC14WrongTypeErrorV6actualypXpvp","s11NIOEmbedded15EmbeddedChannelC14WrongTypeErrorV8expectedypXpvp","s11NIOEmbedded15EmbeddedChannelC17embeddedEventLoopAA0beF0Cvp","s11NIOEmbedded15EmbeddedChannelC6parent7NIOCore0C0_pSgvp","s11NIOEmbedded15EmbeddedChannelC8isActiveSbvp","s11NIOEmbedded15EmbeddedChannelC8pipeline7NIOCore0C8PipelineCvp","s11NIOEmbedded15EmbeddedChannelC9allocator7NIOCore19ByteBufferAllocatorVvp","s11NIOEmbedded15EmbeddedChannelC9eventLoop7NIOCore05EventE0_pvp","s11NIOEmbedded17EmbeddedEventLoopC02incD0Sbvp","s11NIOEmbedded15EmbeddedChannelC11readInbound2asxSgxm_tKlF","s11NIOEmbedded15EmbeddedChannelC12readOutbound2asxSgxm_tKlF","s11NIOEmbedded15EmbeddedChannelC12writeInboundyAC11BufferStateOxKlF","s11NIOEmbedded15EmbeddedChannelC13writeOutboundyAC11BufferStateOxKlF","s11NIOEmbedded15EmbeddedChannelC18SynchronousOptionsV9getOptiony5ValueQzxK7NIOCore0cG0RzlF","s11NIOEmbedded15EmbeddedChannelC18SynchronousOptionsV9setOption_5valueyx_5ValueQztK7NIOCore0cG0RzlF","s11NIOEmbedded15EmbeddedChannelC18throwIfErrorCaughtyyKF","s11NIOEmbedded15EmbeddedChannelC4bind2to7promisey7NIOCore13SocketAddressO_AG16EventLoopPromiseVyytGSgtF","s11NIOEmbedded15EmbeddedChannelC6finish19acceptAlreadyClosedAC13LeftOverStateOSb_tKF","s11NIOEmbedded15EmbeddedChannelC6finishAC13LeftOverStateOyKF","s11NIOEmbedded15EmbeddedChannelC7connect2to7promisey7NIOCore13SocketAddressO_AG16EventLoopPromiseVyytGSgtF","s11NIOEmbedded15EmbeddedChannelC9getOptiony7NIOCore15EventLoopFutureCy5ValueQzGxAE0cE0RzlF","s11NIOEmbedded15EmbeddedChannelC9setOption_5value7NIOCore15EventLoopFutureCyytGx_5ValueQztAF0cE0RzlF","s11NIOEmbedded17EmbeddedEventLoopC11advanceTime2byy7NIOCore0F6AmountV_tF","s11NIOEmbedded17EmbeddedEventLoopC11advanceTime2toy7NIOCore11NIODeadlineV_tF","s11NIOEmbedded17EmbeddedEventLoopC12scheduleTask2in_7NIOCore9ScheduledVyxGAF10TimeAmountV_xyKctlF","s11NIOEmbedded17EmbeddedEventLoopC12scheduleTask8deadline_7NIOCore9ScheduledVyxGAF11NIODeadlineV_xyKctlF","s11NIOEmbedded17EmbeddedEventLoopC18shutdownGracefully5queue_y8Dispatch0H5QueueC_ys5Error_pSgctF","s11NIOEmbedded17EmbeddedEventLoopC3runyyF","s11NIOEmbedded17EmbeddedEventLoopC7executeyyyycF","s11NIOEmbedded15EmbeddedChannelC14WrongTypeErrorV2eeoiySbAE_AEtFZ","s7NIOCore10TimeAmountV","s7NIOCore11NIODeadlineV","s7NIOCore13ChannelOptionP","s7NIOCore13SocketAddressO","s7NIOCore14ChannelHandlerP","s7NIOCore14EventLoopGroupP","s7NIOCore14EventLoopGroupP18shutdownGracefully5queue_y8Dispatch0H5QueueC_ys5Error_pSgctF","s7NIOCore14EventLoopGroupPAAE11descriptionSSvp","s7NIOCore14EventLoopGroupPAAE18shutdownGracefullyyyYaKF","s7NIOCore14EventLoopGroupPAAE18shutdownGracefullyyyys5Error_pSgcF","s7NIOCore14EventLoopGroupPAAE22syncShutdownGracefullyyyKF","s7NIOCore15ChannelPipelineC","s7NIOCore15EventLoopFutureC","s7NIOCore16EventLoopPromiseV","s7NIOCore19ByteBufferAllocatorV","s7NIOCore22ChannelOutboundInvokerP","s7NIOCore22ChannelOutboundInvokerP011triggerUserC5Event_7promiseyyp_AA0G11LoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP13writeAndFlush_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP4bind2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP4readyyF","s7NIOCore22ChannelOutboundInvokerP5close4mode7promiseyAA9CloseModeO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP5flushyyF","s7NIOCore22ChannelOutboundInvokerP5write_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP7connect2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP8register7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore22ChannelOutboundInvokerP9eventLoopAA05EventF0_pvp","s7NIOCore22ChannelOutboundInvokerPAAE011triggerUserC5Event_4file4lineAA0G10LoopFutureCyytGyp_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE13writeAndFlush_4file4lineAA15EventLoopFutureCyytGAA6NIOAnyV_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE4bind2to4file4lineAA15EventLoopFutureCyytGAA13SocketAddressO_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE5close4mode4file4lineAA15EventLoopFutureCyytGAA9CloseModeO_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE5write_4file4lineAA15EventLoopFutureCyytGAA6NIOAnyV_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE7connect2to4file4lineAA15EventLoopFutureCyytGAA13SocketAddressO_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE8register4file4lineAA15EventLoopFutureCyytGs12StaticStringV_SutF","s7NIOCore28NIOSynchronousChannelOptionsP","s7NIOCore28NIOSynchronousChannelOptionsP9getOptiony5ValueQyd__qd__KAA0cF0Rd__lF","s7NIOCore28NIOSynchronousChannelOptionsP9setOption_5valueyqd___5ValueQyd__tKAA0cF0Rd__lF","s7NIOCore6NIOAnyV","s7NIOCore7ChannelP","s7NIOCore7ChannelP10isWritableSbvp","s7NIOCore7ChannelP11closeFutureAA09EventLoopD0CyytGvp","s7NIOCore7ChannelP11syncOptionsAA014NIOSynchronousbD0_pSgvp","s7NIOCore7ChannelP12localAddressAA06SocketD0OSgvp","s7NIOCore7ChannelP13remoteAddressAA06SocketD0OSgvp","s7NIOCore7ChannelP6parentAaB_pSgvp","s7NIOCore7ChannelP8isActiveSbvp","s7NIOCore7ChannelP8pipelineAA0B8PipelineCvp","s7NIOCore7ChannelP9allocatorAA19ByteBufferAllocatorVvp","s7NIOCore7ChannelP9getOptionyAA15EventLoopFutureCy5ValueQyd__Gqd__AA0bD0Rd__lF","s7NIOCore7ChannelP9setOption_5valueAA15EventLoopFutureCyytGqd___5ValueQyd__tAA0bD0Rd__lF","s7NIOCore7ChannelPAAE11syncOptionsAA014NIOSynchronousbD0_pSgvp","s7NIOCore7ChannelPAAE13writeAndFlush_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE13writeAndFlushyAA15EventLoopFutureCyytGqd__lF","s7NIOCore7ChannelPAAE13writeAndFlushyyqd__YaKlF","s7NIOCore7ChannelPAAE24triggerUserOutboundEvent_7promiseyyp_AA0F11LoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE26registerAlreadyConfigured07promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore7ChannelPAAE4readyyF","s7NIOCore7ChannelPAAE5close4mode7promiseyAA9CloseModeO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE5flushyyF","s7NIOCore7ChannelPAAE5write_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE5writeyAA15EventLoopFutureCyytGqd__lF","s7NIOCore7ChannelPAAE8register7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore7ChannelPAAE9getOptiony5ValueQyd__qd__YaKAA0bD0Rd__lF","s7NIOCore7ChannelPAAE9setOption_5valueyqd___5ValueQyd__tYaKAA0bD0Rd__lF","s7NIOCore9EventLoopP","s7NIOCore9EventLoopP02inbC0Sbvp","s7NIOCore9EventLoopP12scheduleTask2in_AA9ScheduledVyqd__GAA10TimeAmountV_qd__yKctlF","s7NIOCore9EventLoopP12scheduleTask8deadline_AA9ScheduledVyqd__GAA11NIODeadlineV_qd__yKctlF","s7NIOCore9EventLoopP7executeyyyycF","s7NIOCore9EventLoopPAAE011assertNotInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE014preconditionInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE017preconditionNotInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE08assertInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE10flatSubmityAA0bC6FutureCyqd__GAGyclF","s7NIOCore9EventLoopPAAE11makePromise2of4file4lineAA0bcE0Vyqd__Gqd__m_s12StaticStringVSutlF","s7NIOCore9EventLoopPAAE12makeIteratorAA0bcE0VyF","s7NIOCore9EventLoopPAAE16flatScheduleTask2in4file4line_AA9ScheduledVyqd__GAA10TimeAmountV_s12StaticStringVSuAA0bC6FutureCyqd__GyKctlF","s7NIOCore9EventLoopPAAE16flatScheduleTask8deadline4file4line_AA9ScheduledVyqd__GAA11NIODeadlineV_s12StaticStringVSuAA0bC6FutureCyqd__GyKctlF","s7NIOCore9EventLoopPAAE16makeFailedFuture_4file4lineAA0bcF0Cyqd__Gs5Error_p_s12StaticStringVSutlF","s7NIOCore9EventLoopPAAE16makeFailedFutureyAA0bcF0Cyqd__Gs5Error_plF","s7NIOCore9EventLoopPAAE19makeCompletedFutureyAA0bcF0Cyqd__Gs6ResultOyqd__s5Error_pGlF","s7NIOCore9EventLoopPAAE19makeSucceededFuture_4file4lineAA0bcF0Cyqd__Gqd___s12StaticStringVSutlF","s7NIOCore9EventLoopPAAE19makeSucceededFutureyAA0bcF0Cyqd__Gqd__lF","s7NIOCore9EventLoopPAAE20scheduleRepeatedTask12initialDelay5delay9notifying_AA0eF0CAA10TimeAmountV_AkA0bC7PromiseVyytGSgyAIKctF","s7NIOCore9EventLoopPAAE23makeSucceededVoidFutureAA0bcG0CyytGyF","s7NIOCore9EventLoopPAAE25scheduleRepeatedAsyncTask12initialDelay5delay9notifying_AA0eG0CAA10TimeAmountV_AkA0bC7PromiseVyytGSgAA0bC6FutureCyytGAIctF","s7NIOCore9EventLoopPAAE3anyAaB_pyF","s7NIOCore9EventLoopPAAE4nextAaB_pyF","s7NIOCore9EventLoopPAAE6submityAA0bC6FutureCyqd__Gqd__yKclF","s7NIOCore9ScheduledV","s8Dispatch0A5QueueC","sSQ","sSQ2eeoiySbx_xtFZ","sSQsE2neoiySbx_xtFZ","sSb","ss4Voida","ss5ErrorP","ss8SendableP"],"vertices":[{"p":["EmbeddedChannel","BufferState"],"f":[["enum",12],[" ",17],["BufferState",7]],"s":[["enum",12],[" ",17],["BufferState",7]],"d":"`BufferState` represents the state of either the inbound, or the outbound `EmbeddedChannel` buffer. These\nbuffers contain data that travelled the `ChannelPipeline` all the way.\n\nIf the last `ChannelHandler` explicitly (by calling `fireChannelRead`) or implicitly (by not implementing\n`channelRead`) sends inbound data into the end of the `EmbeddedChannel`, it will be held in the\n`EmbeddedChannel`'s inbound buffer. Similarly for `write` on the outbound side. The state of the respective\nbuffer will be returned from `writeInbound`/`writeOutbound` as a `BufferState`."},{"p":["EmbeddedChannel","LeftOverState"],"f":[["enum",12],[" ",17],["LeftOverState",7]],"s":[["enum",12],[" ",17],["LeftOverState",7]],"d":"`LeftOverState` represents any left-over inbound, outbound, and pending outbound events that hit the\n`EmbeddedChannel` and were not consumed when `finish` was called on the `EmbeddedChannel`.\n\n`EmbeddedChannel` is most useful in testing and usually in unit tests, you want to consume all inbound and\noutbound data to verify they are what you expect. Therefore, when you `finish` an `EmbeddedChannel` it will\nreturn if it's either `.clean` (no left overs) or that it has `.leftOvers`."},{"p":["EmbeddedChannel","WrongTypeError"],"f":[["struct",12],[" ",17],["WrongTypeError",7]],"s":[["struct",12],[" ",17],["WrongTypeError",7]],"d":"`WrongTypeError` is throws if you use `readInbound` or `readOutbound` and request a certain type but the first\nitem in the respective buffer is of a different type."},{"p":["EmbeddedChannel","SynchronousOptions"],"f":[["struct",12],[" ",17],["SynchronousOptions",7]],"s":[["struct",12],[" ",17],["SynchronousOptions",7]]},{"p":["EmbeddedChannel"],"f":[["final",12],[" ",17],["class",12],[" ",17],["EmbeddedChannel",7]],"s":[["class",12],[" ",17],["EmbeddedChannel",7]],"d":"`EmbeddedChannel` is a `Channel` implementation that does neither any\nactual IO nor has a proper eventing mechanism. The prime use-case for\n`EmbeddedChannel` is in unit tests when you want to feed the inbound events\nand check the outbound events manually.\n\nPlease remember to call `finish()` when you are no longer using this\n`EmbeddedChannel`.\n\nTo feed events through an `EmbeddedChannel`'s `ChannelPipeline` use\n`EmbeddedChannel.writeInbound` which accepts data of any type. It will then\nforward that data through the `ChannelPipeline` and the subsequent\n`ChannelInboundHandler` will receive it through the usual `channelRead`\nevent. The user is responsible for making sure the first\n`ChannelInboundHandler` expects data of that type.\n\n`EmbeddedChannel` automatically collects arriving outbound data and makes it\navailable one-by-one through `readOutbound`.\n\n- note: `EmbeddedChannel` is currently only compatible with\n  `EmbeddedEventLoop`s and cannot be used with `SelectableEventLoop`s from\n  for example `MultiThreadedEventLoopGroup`.\n- warning: Unlike other `Channel`s, `EmbeddedChannel` **is not thread-safe**. This\n    is because it is intended to be run in the thread that instantiated it. Users are\n    responsible for ensuring they never call into an `EmbeddedChannel` in an\n    unsynchronized fashion. `EmbeddedEventLoop`s notes also apply as\n    `EmbeddedChannel` uses an `EmbeddedEventLoop` as its `EventLoop`."},{"p":["EmbeddedEventLoop"],"f":[["final",12],[" ",17],["class",12],[" ",17],["EmbeddedEventLoop",7]],"s":[["class",12],[" ",17],["EmbeddedEventLoop",7]],"d":"An `EventLoop` that is embedded in the current running context with no external\ncontrol.\n\nUnlike more complex `EventLoop`s, such as `SelectableEventLoop`, the `EmbeddedEventLoop`\nhas no proper eventing mechanism. Instead, reads and writes are fully controlled by the\nentity that instantiates the `EmbeddedEventLoop`. This property makes `EmbeddedEventLoop`\nof limited use for many application purposes, but highly valuable for testing and other\nkinds of mocking.\n\nTime is controllable on an `EmbeddedEventLoop`. It begins at `NIODeadline.uptimeNanoseconds(0)`\nand may be advanced by a fixed amount by using `advanceTime(by:)`, or advanced to a point in\ntime with `advanceTime(to:)`.\n\n- warning: Unlike `SelectableEventLoop`, `EmbeddedEventLoop` **is not thread-safe**. This\n    is because it is intended to be run in the thread that instantiated it. Users are\n    responsible for ensuring they never call into the `EmbeddedEventLoop` in an\n    unsynchronized fashion."},{"p":["EmbeddedChannel","BufferState","full(_:)"],"f":[["case",12],[" ",17],["full",7],["([",17],["NIOAny",18,89],["])",17]],"s":[["case",12],[" ",17],["full",7],["([",17],["NIOAny",18],["])",17]],"d":"The buffer is non-empty."},{"p":["EmbeddedChannel","BufferState","empty"],"f":[["case",12],[" ",17],["empty",7]],"s":[["case",12],[" ",17],["empty",7]],"d":"The buffer is empty."},{"p":["EmbeddedChannel","LeftOverState","clean"],"f":[["case",12],[" ",17],["clean",7]],"s":[["case",12],[" ",17],["clean",7]],"d":"The `EmbeddedChannel` is clean, ie. no inbound, outbound, or pending outbound data left on `finish`."},{"p":["EmbeddedChannel","LeftOverState","leftOvers(inbound:outbound:pendingOutbound:)"],"f":[["case",12],[" ",17],["leftOvers",7],["(",17],["inbound",1],[": [",17],["NIOAny",18,89],["], ",17],["outbound",1],[": [",17],["NIOAny",18,89],["], ",17],["pendingOutbound",1],[": [",17],["NIOAny",18,89],["])",17]],"s":[["case",12],[" ",17],["leftOvers",7],["(",17],["inbound",1],[": [",17],["NIOAny",18],["], ",17],["outbound",1],[": [",17],["NIOAny",18],["], ",17],["pendingOutbound",1],[": [",17],["NIOAny",18],["])",17]],"d":"The `EmbeddedChannel` has inbound, outbound, or pending outbound data left on `finish`."},{"p":["EmbeddedChannel","WrongTypeError","init(expected:actual:)"],"f":[["init",10],["(",17],["expected",1],[": ",17],["Any",12],[".Type, ",17],["actual",1],[": ",17],["Any",12],[".Type)",17]],"s":[["init",10],["(",17],["expected",1],[": ",17],["Any",12],[".Type, ",17],["actual",1],[": ",17],["Any",12],[".Type)",17]]},{"p":["EmbeddedChannel","init(handler:loop:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["handler",1],[": ",17],["ChannelHandler",18,57],["? = nil, ",17],["loop",1],[": ",17],["EmbeddedEventLoop",18,5],[" = EmbeddedEventLoop())",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["handler",1],[": ",17],["ChannelHandler",18],["?, ",17],["loop",1],[": ",17],["EmbeddedEventLoop",18],[")",17]],"d":"Create a new instance.\n\nDuring creation it will automatically also register itself on the `EmbeddedEventLoop`.\n\n- parameters:\n    - handler: The `ChannelHandler` to add to the `ChannelPipeline` before register or `nil` if none should be added.\n    - loop: The `EmbeddedEventLoop` to use."},{"p":["EmbeddedChannel","init(handlers:loop:)"],"f":[["init",10],["(",17],["handlers",1],[": [",17],["ChannelHandler",18,57],["], ",17],["loop",1],[": ",17],["EmbeddedEventLoop",18,5],[" = EmbeddedEventLoop())",17]],"s":[["init",10],["(",17],["handlers",1],[": [",17],["ChannelHandler",18],["], ",17],["loop",1],[": ",17],["EmbeddedEventLoop",18],[")",17]],"d":"Create a new instance.\n\nDuring creation it will automatically also register itself on the `EmbeddedEventLoop`.\n\n- parameters:\n    - handlers: The `ChannelHandler`s to add to the `ChannelPipeline` before register.\n    - loop: The `EmbeddedEventLoop` to use."},{"p":["EmbeddedEventLoop","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"d":"Initialize a new `EmbeddedEventLoop`."},{"p":["EmbeddedChannel","isWritable"],"f":[["var",12],[" ",17],["isWritable",7],[": ",17],["Bool",18,146]],"s":[["var",12],[" ",17],["isWritable",7],[": ",17],["Bool",18]],"d":"- see: `Channel.isWritable`"},{"p":["EmbeddedChannel","BufferState","isFull"],"f":[["var",12],[" ",17],["isFull",7],[": ",17],["Bool",18,146],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isFull",7],[": ",17],["Bool",18]],"d":"Returns `true` if the buffer was non-empty."},{"p":["EmbeddedChannel","BufferState","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,146],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"d":"Returns `true` is the buffer was empty."},{"p":["EmbeddedChannel","closeFuture"],"f":[["var",12],[" ",17],["closeFuture",7],[": ",17],["EventLoopFuture",18,65],["<",17],["Void",18,147],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["closeFuture",7],[": ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"- see: `Channel.closeFuture`"},{"p":["EmbeddedChannel","syncOptions"],"f":[["final",12],[" ",17],["var",12],[" ",17],["syncOptions",7],[": ",17],["NIOSynchronousChannelOptions",18,86],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["syncOptions",7],[": ",17],["NIOSynchronousChannelOptions",18],["?",17]]},{"p":["EmbeddedChannel","localAddress"],"f":[["var",12],[" ",17],["localAddress",7],[": ",17],["SocketAddress",18,56],["?",17]],"s":[["var",12],[" ",17],["localAddress",7],[": ",17],["SocketAddress",18],["?",17]],"d":"- see: `Channel.localAddress`"},{"p":["EmbeddedChannel","LeftOverState","hasLeftOvers"],"f":[["var",12],[" ",17],["hasLeftOvers",7],[": ",17],["Bool",18,146],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["hasLeftOvers",7],[": ",17],["Bool",18]],"d":"`true` if the `EmbeddedChannel` if there was unconsumed inbound, outbound, or pending outbound data left\non the `Channel` when it was `finish`ed."},{"p":["EmbeddedChannel","LeftOverState","isClean"],"f":[["var",12],[" ",17],["isClean",7],[": ",17],["Bool",18,146],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isClean",7],[": ",17],["Bool",18]],"d":"`true` if the `EmbeddedChannel` was `clean` on `finish`, ie. there is no unconsumed inbound, outbound, or\npending outbound data left on the `Channel`."},{"p":["EmbeddedChannel","remoteAddress"],"f":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18,56],["?",17]],"s":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18],["?",17]],"d":"- see: `Channel.remoteAddress`"},{"p":["EmbeddedChannel","WrongTypeError","actual"],"f":[["let",12],[" ",17],["actual",7],[": ",17],["Any",12],[".Type",17]],"s":[["let",12],[" ",17],["actual",7],[": ",17],["Any",12],[".Type",17]],"d":"The type of the actual first element."},{"p":["EmbeddedChannel","WrongTypeError","expected"],"f":[["let",12],[" ",17],["expected",7],[": ",17],["Any",12],[".Type",17]],"s":[["let",12],[" ",17],["expected",7],[": ",17],["Any",12],[".Type",17]],"d":"The type you expected."},{"p":["EmbeddedChannel","embeddedEventLoop"],"f":[["var",12],[" ",17],["embeddedEventLoop",7],[": ",17],["EmbeddedEventLoop",18,5]],"s":[["var",12],[" ",17],["embeddedEventLoop",7],[": ",17],["EmbeddedEventLoop",18]],"d":"Returns the `EmbeddedEventLoop` that this `EmbeddedChannel` uses. This will return the same instance as\n`EmbeddedChannel.eventLoop` but as the concrete `EmbeddedEventLoop` rather than as `EventLoop` existential."},{"p":["EmbeddedChannel","parent"],"f":[["let",12],[" ",17],["parent",7],[": ",17],["Channel",18,90],["?",17]],"s":[["let",12],[" ",17],["parent",7],[": ",17],["Channel",18],["?",17]],"d":"`nil` because `EmbeddedChannel`s don't have parents."},{"p":["EmbeddedChannel","isActive"],"f":[["var",12],[" ",17],["isActive",7],[": ",17],["Bool",18,146],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isActive",7],[": ",17],["Bool",18]],"d":"Returns `true` if the `EmbeddedChannel` is 'active'.\n\nAn active `EmbeddedChannel` can be closed by calling `close` or `finish` on the `EmbeddedChannel`.\n\n- note: An `EmbeddedChannel` starts _inactive_ and can be activated, for example by calling `connect`."},{"p":["EmbeddedChannel","pipeline"],"f":[["var",12],[" ",17],["pipeline",7],[": ",17],["ChannelPipeline",18,64],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["pipeline",7],[": ",17],["ChannelPipeline",18]],"d":"- see: `Channel.pipeline`"},{"p":["EmbeddedChannel","allocator"],"f":[["var",12],[" ",17],["allocator",7],[": ",17],["ByteBufferAllocator",18,67]],"s":[["var",12],[" ",17],["allocator",7],[": ",17],["ByteBufferAllocator",18]],"d":"- see: `Channel.allocator`"},{"p":["EmbeddedChannel","eventLoop"],"f":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18,116],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18]],"d":"- see: `Channel.eventLoop`"},{"p":["EmbeddedEventLoop","inEventLoop"],"f":[["var",12],[" ",17],["inEventLoop",7],[": ",17],["Bool",18,146],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["inEventLoop",7],[": ",17],["Bool",18]],"d":"- see: `EventLoop.inEventLoop`"},{"p":["EmbeddedChannel","readInbound(as:)"],"f":[["func",12],[" ",17],["readInbound",7],["<",17],["T",0],[">(",17],["as",1],[" ",17],["type",2],[": ",17],["T",18],[".Type = T.self) ",17],["throws",12],[" -> ",17],["T",18],["?",17]],"s":[["func",12],[" ",17],["readInbound",7],["<",17],["T",0],[">(",17],["as",1],[": ",17],["T",18],[".Type) ",17],["throws",12],[" -> ",17],["T",18],["?",17]],"g":[["T",0,0]],"d":"If available, this method reads one element of type `T` out of the `EmbeddedChannel`'s inbound buffer. If the\nfirst element was of a different type than requested, `EmbeddedChannel.WrongTypeError` will be thrown, if there\nare no elements in the outbound buffer, `nil` will be returned.\n\nData hits the `EmbeddedChannel`'s inbound buffer when data was send through the pipeline using `fireChannelRead`\nand then travelled the `ChannelPipeline` all the way too the back. For data to hit the inbound buffer, the\nlast `ChannelHandler` must have send the event either explicitly (by calling\n`ChannelHandlerContext.fireChannelRead`) or implicitly by not implementing `channelRead`.\n\n- note: `EmbeddedChannel.writeInbound` will fire data through the `ChannelPipeline` using `fireChannelRead`."},{"p":["EmbeddedChannel","readOutbound(as:)"],"f":[["func",12],[" ",17],["readOutbound",7],["<",17],["T",0],[">(",17],["as",1],[" ",17],["type",2],[": ",17],["T",18],[".Type = T.self) ",17],["throws",12],[" -> ",17],["T",18],["?",17]],"s":[["func",12],[" ",17],["readOutbound",7],["<",17],["T",0],[">(",17],["as",1],[": ",17],["T",18],[".Type) ",17],["throws",12],[" -> ",17],["T",18],["?",17]],"g":[["T",0,0]],"d":"If available, this method reads one element of type `T` out of the `EmbeddedChannel`'s outbound buffer. If the\nfirst element was of a different type than requested, `EmbeddedChannel.WrongTypeError` will be thrown, if there\nare no elements in the outbound buffer, `nil` will be returned.\n\nData hits the `EmbeddedChannel`'s outbound buffer when data was written using `write`, then `flush`ed, and\nthen travelled the `ChannelPipeline` all the way too the front. For data to hit the outbound buffer, the very\nfirst `ChannelHandler` must have written and flushed it either explicitly (by calling\n`ChannelHandlerContext.write` and `flush`) or implicitly by not implementing `write`/`flush`.\n\n- note: Outbound events travel the `ChannelPipeline` _back to front_.\n- note: `EmbeddedChannel.writeOutbound` will `write` data through the `ChannelPipeline`, starting with last\n        `ChannelHandler`."},{"p":["EmbeddedChannel","writeInbound(_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["writeInbound",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["data",2],[": ",17],["T",18],[") ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18,4],[".",17],["BufferState",18,0]],"s":[["func",12],[" ",17],["writeInbound",7],["<",17],["T",0],[">(",17],["T",18],[") ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18],[".",17],["BufferState",18]],"g":[["T",0,0]]},{"p":["EmbeddedChannel","writeOutbound(_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["writeOutbound",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["data",2],[": ",17],["T",18],[") ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18,4],[".",17],["BufferState",18,0]],"s":[["func",12],[" ",17],["writeOutbound",7],["<",17],["T",0],[">(",17],["T",18],[") ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18],[".",17],["BufferState",18]],"g":[["T",0,0]]},{"p":["EmbeddedChannel","SynchronousOptions","getOption(_:)"],"f":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[") ",17],["throws",12],[" -> ",17],["Option",18],[".",17],["Value",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,55]],"s":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["Option",18],[") ",17],["throws",12],[" -> ",17],["Option",18],[".",17],["Value",18]],"c":[["Option",1,"ChannelOption",55]],"g":[["Option",0,0]]},{"p":["EmbeddedChannel","SynchronousOptions","setOption(_:value:)"],"f":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") ",17],["throws",12],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,55]],"s":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") ",17],["throws",12]],"c":[["Option",1,"ChannelOption",55]],"g":[["Option",0,0]]},{"p":["EmbeddedChannel","throwIfErrorCaught()"],"f":[["func",12],[" ",17],["throwIfErrorCaught",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["throwIfErrorCaught",7],["() ",17],["throws",12]],"d":"This method will throw the error that is stored in the `EmbeddedChannel` if any.\n\nThe `EmbeddedChannel` will store an error some error travels the `ChannelPipeline` all the way past its end."},{"p":["EmbeddedChannel","bind(to:promise:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,56],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,66],["<",17],["Void",18,147],[">?)",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires the (outbound) `bind` event through the `ChannelPipeline`. If the event hits the `EmbeddedChannel` which\nhappens when it travels the `ChannelPipeline` all the way to the front, this will also set the\n`EmbeddedChannel`'s `localAddress`.\n\n- parameters:\n    - address: The address to fake-bind to.\n    - promise: The `EventLoopPromise` which will be fulfilled when the fake-bind operation has been done."},{"p":["EmbeddedChannel","finish(acceptAlreadyClosed:)"],"f":[["func",12],[" ",17],["finish",7],["(",17],["acceptAlreadyClosed",1],[": ",17],["Bool",18,146],[") ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18,4],[".",17],["LeftOverState",18,1]],"s":[["func",12],[" ",17],["finish",7],["(",17],["acceptAlreadyClosed",1],[": ",17],["Bool",18],[") ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18],[".",17],["LeftOverState",18]],"d":"Synchronously closes the `EmbeddedChannel`.\n\nErrors in the `EmbeddedChannel` can be consumed using `throwIfErrorCaught`.\n\n- parameters:\n    - acceptAlreadyClosed: Whether `finish` should throw if the `EmbeddedChannel` has been previously `close`d.\n- returns: The `LeftOverState` of the `EmbeddedChannel`. If all the inbound and outbound events have been\n           consumed (using `readInbound` / `readOutbound`) and there are no pending outbound events (unflushed\n           writes) this will be `.clean`. If there are any unconsumed inbound, outbound, or pending outbound\n           events, the `EmbeddedChannel` will returns those as `.leftOvers(inbound:outbound:pendingOutbound:)`."},{"p":["EmbeddedChannel","finish()"],"f":[["func",12],[" ",17],["finish",7],["() ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18,4],[".",17],["LeftOverState",18,1]],"s":[["func",12],[" ",17],["finish",7],["() ",17],["throws",12],[" -> ",17],["EmbeddedChannel",18],[".",17],["LeftOverState",18]],"d":"Synchronously closes the `EmbeddedChannel`.\n\nThis method will throw if the `Channel` hit any unconsumed errors or if the `close` fails. Errors in the\n`EmbeddedChannel` can be consumed using `throwIfErrorCaught`.\n\n- returns: The `LeftOverState` of the `EmbeddedChannel`. If all the inbound and outbound events have been\n           consumed (using `readInbound` / `readOutbound`) and there are no pending outbound events (unflushed\n           writes) this will be `.clean`. If there are any unconsumed inbound, outbound, or pending outbound\n           events, the `EmbeddedChannel` will returns those as `.leftOvers(inbound:outbound:pendingOutbound:)`."},{"p":["EmbeddedChannel","connect(to:promise:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,56],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,66],["<",17],["Void",18,147],[">?)",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires the (outbound) `connect` event through the `ChannelPipeline`. If the event hits the `EmbeddedChannel`\nwhich happens when it travels the `ChannelPipeline` all the way to the front, this will also set the\n`EmbeddedChannel`'s `remoteAddress`.\n\n- parameters:\n    - address: The address to fake-bind to.\n    - promise: The `EventLoopPromise` which will be fulfilled when the fake-bind operation has been done."},{"p":["EmbeddedChannel","getOption(_:)"],"f":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[") -> ",17],["EventLoopFuture",18,65],["<",17],["Option",18],[".",17],["Value",18],["> ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,55]],"s":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["Option",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Option",18],[".",17],["Value",18],[">",17]],"c":[["Option",1,"ChannelOption",55]],"g":[["Option",0,0]],"d":"- see: `Channel.getOption`"},{"p":["EmbeddedChannel","setOption(_:value:)"],"f":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["EventLoopFuture",18,65],["<",17],["Void",18,147],["> ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,55]],"s":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"c":[["Option",1,"ChannelOption",55]],"g":[["Option",0,0]],"d":"- see: `Channel.setOption`"},{"p":["EmbeddedEventLoop","advanceTime(by:)"],"f":[["func",12],[" ",17],["advanceTime",7],["(",17],["by",1],[" ",17],["increment",2],[": ",17],["TimeAmount",18,53],[")",17]],"s":[["func",12],[" ",17],["advanceTime",7],["(",17],["by",1],[": ",17],["TimeAmount",18],[")",17]],"d":"Runs the event loop and moves \"time\" forward by the given amount, running any scheduled\ntasks that need to be run."},{"p":["EmbeddedEventLoop","advanceTime(to:)"],"f":[["func",12],[" ",17],["advanceTime",7],["(",17],["to",1],[" ",17],["deadline",2],[": ",17],["NIODeadline",18,54],[")",17]],"s":[["func",12],[" ",17],["advanceTime",7],["(",17],["to",1],[": ",17],["NIODeadline",18],[")",17]],"d":"Runs the event loop and moves \"time\" forward to the given point in time, running any scheduled\ntasks that need to be run.\n\n- Note: If `deadline` is before the current time, the current time will not be advanced."},{"p":["EmbeddedEventLoop","scheduleTask(in:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["in",1],[": ",17],["TimeAmount",18,53],[", ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18,141],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["in",1],[": ",17],["TimeAmount",18],[", () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18],["<",17],["T",18],[">",17]],"g":[["T",0,0]],"d":"- see: `EventLoop.scheduleTask(in:_:)`"},{"p":["EmbeddedEventLoop","scheduleTask(deadline:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["deadline",1],[": ",17],["NIODeadline",18,54],[", ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18,141],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["deadline",1],[": ",17],["NIODeadline",18],[", () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18],["<",17],["T",18],[">",17]],"g":[["T",0,0]],"d":"- see: `EventLoop.scheduleTask(deadline:_:)`"},{"p":["EmbeddedEventLoop","shutdownGracefully(queue:_:)"],"f":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18,142],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,148],["?) -> ",17],["Void",18,147],[")",17]],"s":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18],[", (",17],["Error",18],["?) -> ",17],["Void",18],[")",17]],"d":"- see: `EventLoop.shutdownGracefully`"},{"p":["EmbeddedEventLoop","run()"],"f":[["func",12],[" ",17],["run",7],["()",17]],"s":[["func",12],[" ",17],["run",7],["()",17]],"d":"Run all tasks that have previously been submitted to this `EmbeddedEventLoop`, either by calling `execute` or\nevents that have been enqueued using `scheduleTask`/`scheduleRepeatedTask`/`scheduleRepeatedAsyncTask` and whose\ndeadlines have expired.\n\n- seealso: `EmbeddedEventLoop.advanceTime`."},{"p":["EmbeddedEventLoop","execute(_:)"],"f":[["func",12],[" ",17],["execute",7],["(",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () -> ",17],["Void",18,147],[")",17]],"s":[["func",12],[" ",17],["execute",7],["(() -> ",17],["Void",18],[")",17]],"d":"On an `EmbeddedEventLoop`, `execute` will simply use `scheduleTask` with a deadline of _now_. This means that\n`task` will be run the next time you call `EmbeddedEventLoop.run`."},{"p":["EmbeddedChannel","WrongTypeError","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["EmbeddedChannel",18,4],[".",17],["WrongTypeError",18,2],[", ",17],["rhs",2],[": ",17],["EmbeddedChannel",18,4],[".",17],["WrongTypeError",18,2],[") -> ",17],["Bool",18,146]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["EmbeddedChannel",18],[".",17],["WrongTypeError",18],[", ",17],["EmbeddedChannel",18],[".",17],["WrongTypeError",18],[") -> ",17],["Bool",18]]}],"edges":{"conformer":[2,143,[],2,148,[],2,149,[],3,86,[],4,68,[],4,90,[],5,58,[],5,116,[]],"feature":[60,5,61,5,62,5,63,5,79,4,80,4,81,4,82,4,83,4,84,4,85,4,102,4,103,4,104,4,105,4,106,4,107,4,108,4,109,4,110,4,111,4,112,4,113,4,114,4,115,4,121,5,122,5,123,5,124,5,125,5,126,5,127,5,128,5,129,5,130,5,131,5,132,5,133,5,134,5,135,5,136,5,137,5,138,5,139,5,140,5,145,2],"member":[0,4,1,4,2,4,3,4,6,0,7,0,8,1,9,1,10,2,11,4,12,4,13,5,14,4,15,0,16,0,17,4,18,4,19,4,20,1,21,1,22,4,23,2,24,2,25,4,26,4,27,4,28,4,29,4,30,4,31,5,32,4,33,4,34,4,35,4,36,3,37,3,38,4,39,4,40,4,41,4,42,4,43,4,44,4,45,5,46,5,47,5,48,5,49,5,50,5,51,5,52,2]},"hints":[14,91,17,92,18,93,19,94,22,95,26,96,27,97,28,98,29,99,30,78,31,117,36,87,37,88,39,71,42,76,43,100,44,101,47,118,48,119,49,59,51,120,52,144,60,60,61,61,62,62,63,63,79,79,80,80,81,81,82,82,83,83,84,84,85,85,102,102,103,70,104,104,105,105,106,69,107,107,108,72,109,73,110,74,111,75,112,112,113,77,114,114,115,115,121,121,122,122,123,123,124,124,125,125,126,126,127,127,128,128,129,129,130,130,131,131,132,132,133,133,134,134,135,135,136,136,137,137,138,138,139,139,140,140,145,145],"sourcemap":[{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOEmbedded/Embedded.swift","symbols":[70,19,5,93,15,31,98,11,13,102,16,48,123,16,47,129,16,51,138,16,50,145,16,45,153,16,46,202,16,49,395,19,4,402,16,1,404,13,8,407,13,9,411,19,21,421,19,20,433,16,0,435,13,7,438,13,6,441,19,16,450,19,15,457,18,2,459,19,24,462,19,23,464,15,10,469,27,52,479,15,27,482,15,17,493,15,28,498,15,14,510,16,40,540,16,41,547,15,29,550,15,30,556,15,25,559,15,19,562,15,22,565,15,26,580,16,33,595,16,32,609,35,34,627,35,35,635,16,38,661,23,11,673,11,12,685,16,44,698,16,43,717,16,39,731,16,42,740,18,3,749,20,37,754,20,36,759,21,18]}]}