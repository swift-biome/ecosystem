{"culture":"NIOPosix","dependencies":[{"package":"swift-nio","modules":["NIOConcurrencyHelpers","NIOCore","_NIODataStructures"]}],"extensions":[],"partitions":[{"namespace":"NIOPosix","communities":[{"community":"protocol","startIndex":0,"endIndex":1},{"community":"enum","startIndex":1,"endIndex":4},{"community":"struct","startIndex":4,"endIndex":11},{"community":"class","startIndex":11,"endIndex":18},{"community":"enum.case","startIndex":18,"endIndex":21},{"community":"init","startIndex":21,"endIndex":35},{"community":"type.property","startIndex":35,"endIndex":38},{"community":"property","startIndex":38,"endIndex":47},{"community":"type.method","startIndex":47,"endIndex":48},{"community":"method","startIndex":48,"endIndex":107},{"community":"typealias","startIndex":107,"endIndex":108}]}],"identifiers":["s8NIOPosix8ResolverP","s8NIOPosix13NIOThreadPoolC13WorkItemStateO","s8NIOPosix17NonBlockingFileIOV5ErrorO","s8NIOPosix18NIOThreadPoolErrorO","s8NIOPosix17NonBlockingFileIOV","s8NIOPosix18NIOConnectionErrorV","s8NIOPosix18NIOThreadPoolErrorO06ThreadC8InactiveV","s8NIOPosix19NIOFcntlFailedErrorV","s8NIOPosix23SingleConnectionFailureV","s8NIOPosix29UnixDomainSocketPathWrongTypeV","s8NIOPosix36NIOFailedToSetSocketNonBlockingErrorV","s8NIOPosix13NIOThreadPoolC","s8NIOPosix15ClientBootstrapC","s8NIOPosix15ServerBootstrapC","s8NIOPosix16NIOPipeBootstrapC","s8NIOPosix17DatagramBootstrapC","s8NIOPosix22ThreadSpecificVariableC","s8NIOPosix27MultiThreadedEventLoopGroupC","s8NIOPosix13NIOThreadPoolC13WorkItemStateO6activeyA2EmF","s8NIOPosix13NIOThreadPoolC13WorkItemStateO9cancelledyA2EmF","s8NIOPosix17NonBlockingFileIOV5ErrorO015descriptorSetTobC0yA2EmF","s8NIOPosix13NIOThreadPoolC15numberOfThreadsACSi_tcfc","s8NIOPosix15ClientBootstrapC15validatingGroupACSg7NIOCore09EventLoopE0_p_tcfc","s8NIOPosix15ClientBootstrapC5groupAC7NIOCore14EventLoopGroup_p_tcfc","s8NIOPosix15ServerBootstrapC15validatingGroup05childE0ACSg7NIOCore09EventLoopE0_p_AgH_pSgtcfc","s8NIOPosix15ServerBootstrapC5group10childGroupAC7NIOCore09EventLoopF0_p_AfG_ptcfc","s8NIOPosix15ServerBootstrapC5groupAC7NIOCore14EventLoopGroup_p_tcfc","s8NIOPosix16NIOPipeBootstrapC15validatingGroupACSg7NIOCore09EventLoopE0_p_tcfc","s8NIOPosix16NIOPipeBootstrapC5groupAC7NIOCore14EventLoopGroup_p_tcfc","s8NIOPosix17DatagramBootstrapC15validatingGroupACSg7NIOCore09EventLoopE0_p_tcfc","s8NIOPosix17DatagramBootstrapC5groupAC7NIOCore14EventLoopGroup_p_tcfc","s8NIOPosix17NonBlockingFileIOV10threadPoolAcA09NIOThreadG0C_tcfc","s8NIOPosix22ThreadSpecificVariableC5valueACyxGx_tcfc","s8NIOPosix22ThreadSpecificVariableCACyxGycfc","s8NIOPosix27MultiThreadedEventLoopGroupC15numberOfThreadsACSi_tcfc","s8NIOPosix17NonBlockingFileIOV16defaultChunkSizeSivpZ","s8NIOPosix17NonBlockingFileIOV21defaultThreadPoolSizeSivpZ","s8NIOPosix27MultiThreadedEventLoopGroupC07currentdE07NIOCore0dE0_pSgvpZ","s8NIOPosix18NIOConnectionErrorV12dnsAAAAErrors0C0_pSgvp","s8NIOPosix18NIOConnectionErrorV16connectionErrorsSayAA23SingleConnectionFailureVGvp","s8NIOPosix18NIOConnectionErrorV4hostSSvp","s8NIOPosix18NIOConnectionErrorV4portSivp","s8NIOPosix18NIOConnectionErrorV9dnsAErrors0C0_pSgvp","s8NIOPosix22ThreadSpecificVariableC12currentValuexSgvp","s8NIOPosix23SingleConnectionFailureV5errors5Error_pvp","s8NIOPosix23SingleConnectionFailureV6target7NIOCore13SocketAddressOvp","s8NIOPosix27MultiThreadedEventLoopGroupC11descriptionSSvp","s8NIOPosix27MultiThreadedEventLoopGroupC019withCurrentThreadAsdE0yyy7NIOCore0dE0_pcFZ","s8NIOPosix13NIOThreadPoolC11runIfActive9eventLoop_7NIOCore05EventH6FutureCyxGAF0jH0_p_xyKctlF","s8NIOPosix13NIOThreadPoolC18shutdownGracefully5queue_y8Dispatch0G5QueueC_ys5Error_pSgctF","s8NIOPosix13NIOThreadPoolC18shutdownGracefullyyyys5Error_pSgcF","s8NIOPosix13NIOThreadPoolC22syncShutdownGracefullyyyKF","s8NIOPosix13NIOThreadPoolC5startyyF","s8NIOPosix13NIOThreadPoolC6submityyyAC13WorkItemStateOcF","s8NIOPosix15ClientBootstrapC13channelOption_5valueACXDx_5ValueQzt7NIOCore07ChannelE0RzlF","s8NIOPosix15ClientBootstrapC14connectTimeoutyACXD7NIOCore10TimeAmountVF","s8NIOPosix15ClientBootstrapC16protocolHandlersyACXDSay7NIOCore14ChannelHandler_pGycF","s8NIOPosix15ClientBootstrapC18channelInitializeryACXD7NIOCore15EventLoopFutureCyytGAE7Channel_pcF","s8NIOPosix15ClientBootstrapC19withConnectedSocket10descriptor7NIOCore15EventLoopFutureCyAF7Channel_pGs5Int32V_tF","s8NIOPosix15ClientBootstrapC19withConnectedSockety7NIOCore15EventLoopFutureCyAE7Channel_pGs5Int32VF","s8NIOPosix15ClientBootstrapC4bind2toAC7NIOCore13SocketAddressO_tF","s8NIOPosix15ClientBootstrapC7connect20unixDomainSocketPath7NIOCore15EventLoopFutureCyAF7Channel_pGSS_tF","s8NIOPosix15ClientBootstrapC7connect2to7NIOCore15EventLoopFutureCyAF7Channel_pGAF13SocketAddressO_tF","s8NIOPosix15ClientBootstrapC7connect4host4port7NIOCore15EventLoopFutureCyAG7Channel_pGSS_SitF","s8NIOPosix15ClientBootstrapC8resolveryACXDAA8Resolver_pSgF","s8NIOPosix15ServerBootstrapC11bindTimeoutyACXD7NIOCore10TimeAmountVF","s8NIOPosix15ServerBootstrapC15withBoundSocket10descriptor7NIOCore15EventLoopFutureCyAF7Channel_pGs5Int32V_tF","s8NIOPosix15ServerBootstrapC15withBoundSockety7NIOCore15EventLoopFutureCyAE7Channel_pGs5Int32VF","s8NIOPosix15ServerBootstrapC18childChannelOption_5valueACXDx_5ValueQzt7NIOCore0eF0RzlF","s8NIOPosix15ServerBootstrapC19serverChannelOption_5valueACXDx_5ValueQzt7NIOCore0eF0RzlF","s8NIOPosix15ServerBootstrapC23childChannelInitializeryACXD7NIOCore15EventLoopFutureCyytGAE0E0_pcF","s8NIOPosix15ServerBootstrapC24serverChannelInitializeryACXD7NIOCore15EventLoopFutureCyytGAE0E0_pcF","s8NIOPosix15ServerBootstrapC4bind20unixDomainSocketPath015cleanupExistingG4File7NIOCore15EventLoopFutureCyAG7Channel_pGSS_SbtF","s8NIOPosix15ServerBootstrapC4bind20unixDomainSocketPath7NIOCore15EventLoopFutureCyAF7Channel_pGSS_tF","s8NIOPosix15ServerBootstrapC4bind2to7NIOCore15EventLoopFutureCyAF7Channel_pGAF13SocketAddressO_tF","s8NIOPosix15ServerBootstrapC4bind4host4port7NIOCore15EventLoopFutureCyAG7Channel_pGSS_SitF","s8NIOPosix16NIOPipeBootstrapC13channelOption_5valueACXDx_5ValueQzt7NIOCore07ChannelE0RzlF","s8NIOPosix16NIOPipeBootstrapC18channelInitializeryACXD7NIOCore15EventLoopFutureCyytGAE7Channel_pcF","s8NIOPosix16NIOPipeBootstrapC25withInputOutputDescriptory7NIOCore15EventLoopFutureCyAE7Channel_pGs5Int32VF","s8NIOPosix16NIOPipeBootstrapC9withPipes15inputDescriptor06outputG07NIOCore15EventLoopFutureCyAG7Channel_pGs5Int32V_AMtF","s8NIOPosix17DatagramBootstrapC13channelOption_5valueACXDx_5ValueQzt7NIOCore07ChannelE0RzlF","s8NIOPosix17DatagramBootstrapC15withBoundSocket10descriptor7NIOCore15EventLoopFutureCyAF7Channel_pGs5Int32V_tF","s8NIOPosix17DatagramBootstrapC15withBoundSockety7NIOCore15EventLoopFutureCyAE7Channel_pGs5Int32VF","s8NIOPosix17DatagramBootstrapC18channelInitializeryACXD7NIOCore15EventLoopFutureCyytGAE7Channel_pcF","s8NIOPosix17DatagramBootstrapC4bind20unixDomainSocketPath015cleanupExistingG4File7NIOCore15EventLoopFutureCyAG7Channel_pGSS_SbtF","s8NIOPosix17DatagramBootstrapC4bind20unixDomainSocketPath7NIOCore15EventLoopFutureCyAF7Channel_pGSS_tF","s8NIOPosix17DatagramBootstrapC4bind2to7NIOCore15EventLoopFutureCyAF7Channel_pGAF13SocketAddressO_tF","s8NIOPosix17DatagramBootstrapC4bind4host4port7NIOCore15EventLoopFutureCyAG7Channel_pGSS_SitF","s8NIOPosix17NonBlockingFileIOV04openD04path4mode5flags9eventLoop7NIOCore05EventK6FutureCyAI13NIOFileHandleCGSS_AM4ModeVAM5FlagsVAI0mK0_ptF","s8NIOPosix17NonBlockingFileIOV04openD04path9eventLoop7NIOCore05EventI6FutureCyAG13NIOFileHandleC_AG0D6RegionVtGSS_AG0kI0_ptF","s8NIOPosix17NonBlockingFileIOV04readD4Size10fileHandle9eventLoop7NIOCore05EventK6FutureCys5Int64VGAG07NIOFileI0C_AG0mK0_ptF","s8NIOPosix17NonBlockingFileIOV06changeD4Size10fileHandle4size9eventLoop7NIOCore05EventL6FutureCyytGAH07NIOFileI0C_s5Int64VAH0nL0_ptF","s8NIOPosix17NonBlockingFileIOV11readChunked10fileHandle10fromOffset9byteCount9chunkSize9allocator9eventLoop0N7Handler7NIOCore05EventR6FutureCyytGAL07NIOFileI0C_s5Int64VS2iAL19ByteBufferAllocatorVAL0uR0_pAoL0yZ0VctF","s8NIOPosix17NonBlockingFileIOV11readChunked10fileHandle9byteCount9chunkSize9allocator9eventLoop0L7Handler7NIOCore05EventP6FutureCyytGAK07NIOFileI0C_S2iAK19ByteBufferAllocatorVAK0sP0_pAnK0vW0VctF","s8NIOPosix17NonBlockingFileIOV11readChunked10fileRegion9chunkSize9allocator9eventLoop0J7Handler7NIOCore05EventN6FutureCyytGAJ0dI0V_SiAJ19ByteBufferAllocatorVAJ0qN0_pAmJ0sT0VctF","s8NIOPosix17NonBlockingFileIOV4read10fileHandle10fromOffset9byteCount9allocator9eventLoop7NIOCore05EventO6FutureCyAJ10ByteBufferVGAJ07NIOFileH0C_s5Int64VSiAJ0sT9AllocatorVAJ0qO0_ptF","s8NIOPosix17NonBlockingFileIOV4read10fileHandle9byteCount9allocator9eventLoop7NIOCore05EventM6FutureCyAI10ByteBufferVGAI07NIOFileH0C_SiAI0qR9AllocatorVAI0oM0_ptF","s8NIOPosix17NonBlockingFileIOV4read10fileRegion9allocator9eventLoop7NIOCore05EventK6FutureCyAH10ByteBufferVGAH0dH0V_AH0oP9AllocatorVAH0mK0_ptF","s8NIOPosix17NonBlockingFileIOV5write10fileHandle6buffer9eventLoop7NIOCore05EventK6FutureCyytGAH07NIOFileH0C_AH10ByteBufferVAH0mK0_ptF","s8NIOPosix17NonBlockingFileIOV5write10fileHandle8toOffset6buffer9eventLoop7NIOCore05EventM6FutureCyytGAI07NIOFileH0C_s5Int64VAI10ByteBufferVAI0oM0_ptF","s8NIOPosix27MultiThreadedEventLoopGroupC12makeIterator7NIOCore0deH0VyF","s8NIOPosix27MultiThreadedEventLoopGroupC18shutdownGracefully5queue_y8Dispatch0J5QueueC_ys5Error_pSgctF","s8NIOPosix27MultiThreadedEventLoopGroupC3any7NIOCore0dE0_pyF","s8NIOPosix27MultiThreadedEventLoopGroupC4next7NIOCore0dE0_pyF","s8NIOPosix8ResolverP13cancelQueriesyyF","s8NIOPosix8ResolverP14initiateAQuery4host4port7NIOCore15EventLoopFutureCySayAG13SocketAddressOGGSS_SitF","s8NIOPosix8ResolverP17initiateAAAAQuery4host4port7NIOCore15EventLoopFutureCySayAG13SocketAddressOGGSS_SitF","s8NIOPosix13NIOThreadPoolC8WorkItema","s7NIOCore10ByteBufferV","s7NIOCore10FileRegionV","s7NIOCore10TimeAmountV","s7NIOCore12NIOBSDSocketO","s7NIOCore12NIOBSDSocketO6Handlea","s7NIOCore13ChannelOptionP","s7NIOCore13NIOFileHandleC","s7NIOCore13NIOFileHandleC4ModeV","s7NIOCore13NIOFileHandleC5FlagsV","s7NIOCore13SocketAddressO","s7NIOCore14ChannelHandlerP","s7NIOCore14EventLoopGroupP","s7NIOCore14EventLoopGroupP12makeIteratorAA0bcF0VyF","s7NIOCore14EventLoopGroupP18shutdownGracefully5queue_y8Dispatch0H5QueueC_ys5Error_pSgctF","s7NIOCore14EventLoopGroupP3anyAA0bC0_pyF","s7NIOCore14EventLoopGroupP4nextAA0bC0_pyF","s7NIOCore14EventLoopGroupPAAE11descriptionSSvp","s7NIOCore14EventLoopGroupPAAE18shutdownGracefullyyyYaKF","s7NIOCore14EventLoopGroupPAAE18shutdownGracefullyyyys5Error_pSgcF","s7NIOCore14EventLoopGroupPAAE22syncShutdownGracefullyyyKF","s7NIOCore15EventLoopFutureC","s7NIOCore17EventLoopIteratorV","s7NIOCore19ByteBufferAllocatorV","s7NIOCore29NIOClientTCPBootstrapProtocolP","s7NIOCore29NIOClientTCPBootstrapProtocolP13channelOption_5valuexqd___5ValueQyd__tAA07ChannelF0Rd__lF","s7NIOCore29NIOClientTCPBootstrapProtocolP14connectTimeoutyxAA10TimeAmountVF","s7NIOCore29NIOClientTCPBootstrapProtocolP16protocolHandlersyxSayAA14ChannelHandler_pGycF","s7NIOCore29NIOClientTCPBootstrapProtocolP18channelInitializeryxAA15EventLoopFutureCyytGAA7Channel_pcF","s7NIOCore29NIOClientTCPBootstrapProtocolP7connect20unixDomainSocketPathAA15EventLoopFutureCyAA7Channel_pGSS_tF","s7NIOCore29NIOClientTCPBootstrapProtocolP7connect2toAA15EventLoopFutureCyAA7Channel_pGAA13SocketAddressO_tF","s7NIOCore29NIOClientTCPBootstrapProtocolP7connect4host4portAA15EventLoopFutureCyAA7Channel_pGSS_SitF","s7NIOCore7ChannelP","s7NIOCore9EventLoopP","s8Dispatch0A5QueueC","sSH","sSQ","sSQsE2neoiySbx_xtFZ","sSS","sSb","sSi","ss23CustomStringConvertibleP","ss23CustomStringConvertibleP11descriptionSSvp","ss23CustomStringConvertibleP12_RegexParserE21halfWidthCornerQuotedSSvp","ss4CInta","ss4Voida","ss5ErrorP","ss5Int64V","ss8SendableP"],"vertices":[{"p":["Resolver"],"f":[["protocol",12],[" ",17],["Resolver",7]],"s":[["protocol",12],[" ",17],["Resolver",7]],"d":"A protocol that covers an object that does DNS lookups.\n\nIn general the rules for the resolver are relatively broad: there are no specific requirements on how\nit operates. However, the rest of the code assumes that it obeys RFC 6724, particularly section 6 on\nordering returned addresses. That is, the IPv6 and IPv4 responses should be ordered by the destination\naddress ordering rules from that RFC. This specification is widely implemented by getaddrinfo\nimplementations, so any implementation based on getaddrinfo will work just fine. In the future, a custom\nresolver will need also to implement these sorting rules."},{"p":["NIOThreadPool","WorkItemState"],"f":[["enum",12],[" ",17],["WorkItemState",7]],"s":[["enum",12],[" ",17],["WorkItemState",7]],"d":"The state of the `WorkItem`."},{"p":["NonBlockingFileIO","Error"],"f":[["enum",12],[" ",17],["Error",7]],"s":[["enum",12],[" ",17],["Error",7]],"d":"`NonBlockingFileIO` errors."},{"p":["NIOThreadPoolError"],"f":[["enum",12],[" ",17],["NIOThreadPoolError",7]],"s":[["enum",12],[" ",17],["NIOThreadPoolError",7]],"d":"Errors that may be thrown when executing work on a `NIOThreadPool`"},{"p":["NonBlockingFileIO"],"f":[["struct",12],[" ",17],["NonBlockingFileIO",7]],"s":[["struct",12],[" ",17],["NonBlockingFileIO",7]],"d":"`NonBlockingFileIO` is a helper that allows you to read files without blocking the calling thread.\n\nIt is worth noting that `kqueue`, `epoll` or `poll` returning claiming a file is readable does not mean that the\ndata is already available in the kernel's memory. In other words, a `read` from a file can still block even if\nreported as readable. This behaviour is also documented behaviour:\n\n - [`poll`](http://pubs.opengroup.org/onlinepubs/009695399/functions/poll.html): \"Regular files shall always poll TRUE for reading and writing.\"\n - [`epoll`](http://man7.org/linux/man-pages/man7/epoll.7.html): \"epoll is simply a faster poll(2), and can be used wherever the latter is used since it shares the same semantics.\"\n - [`kqueue`](https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2): \"Returns when the file pointer is not at the end of file.\"\n\n`NonBlockingFileIO` helps to work around this issue by maintaining its own thread pool that is used to read the data\nfrom the files into memory. It will then hand the (in-memory) data back which makes it available without the possibility\nof blocking."},{"p":["NIOConnectionError"],"f":[["struct",12],[" ",17],["NIOConnectionError",7]],"s":[["struct",12],[" ",17],["NIOConnectionError",7]],"d":"A representation of all the errors that happened during an attempt to connect\nto a given host and port."},{"p":["NIOThreadPoolError","ThreadPoolInactive"],"f":[["struct",12],[" ",17],["ThreadPoolInactive",7]],"s":[["struct",12],[" ",17],["ThreadPoolInactive",7]],"d":"The `NIOThreadPool` was not active."},{"p":["NIOFcntlFailedError"],"f":[["struct",12],[" ",17],["NIOFcntlFailedError",7]],"s":[["struct",12],[" ",17],["NIOFcntlFailedError",7]],"d":"`NIOFcntlFailedError` indicates that NIO was unable to perform an\noperation on a socket.\n\nThis error should never happen, unfortunately, we have seen this happen on Darwin."},{"p":["SingleConnectionFailure"],"f":[["struct",12],[" ",17],["SingleConnectionFailure",7]],"s":[["struct",12],[" ",17],["SingleConnectionFailure",7]],"d":"An error that occurred during connection to a given target."},{"p":["UnixDomainSocketPathWrongType"],"f":[["struct",12],[" ",17],["UnixDomainSocketPathWrongType",7]],"s":[["struct",12],[" ",17],["UnixDomainSocketPathWrongType",7]],"d":"The requested UDS path exists and has wrong type (not a socket)."},{"p":["NIOFailedToSetSocketNonBlockingError"],"f":[["struct",12],[" ",17],["NIOFailedToSetSocketNonBlockingError",7]],"s":[["struct",12],[" ",17],["NIOFailedToSetSocketNonBlockingError",7]],"a":{"a":{"d":true,"r":"NIOFcntlFailedError"}},"d":"`NIOFailedToSetSocketNonBlockingError` indicates that NIO was unable to set a socket to non-blocking mode, either\nwhen connecting a socket as a client or when accepting a socket as a server.\n\nThis error should never happen because a socket should always be able to be set to non-blocking mode. Unfortunately,\nwe have seen this happen on Darwin."},{"p":["NIOThreadPool"],"f":[["final",12],[" ",17],["class",12],[" ",17],["NIOThreadPool",7]],"s":[["class",12],[" ",17],["NIOThreadPool",7]],"d":"A thread pool that should be used if some (kernel thread) blocking work\nneeds to be performed for which no non-blocking API exists.\n\nWhen using NIO it is crucial not to block any of the `EventLoop`s as that\nleads to slow downs or stalls of arbitrary other work. Unfortunately though\nthere are tasks that applications need to achieve for which no non-blocking\nAPIs exist. In those cases `NIOThreadPool` can be used but should be\ntreated as a last resort.\n\n- note: The prime example for missing non-blocking APIs is file IO on UNIX.\n  The OS does not provide a usable and truly non-blocking API but with\n  `NonBlockingFileIO` NIO provides a high-level API for file IO that should\n  be preferred to running blocking file IO system calls directly on\n  `NIOThreadPool`. Under the covers `NonBlockingFileIO` will use\n  `NIOThreadPool` on all currently supported platforms though."},{"p":["ClientBootstrap"],"f":[["final",12],[" ",17],["class",12],[" ",17],["ClientBootstrap",7]],"s":[["class",12],[" ",17],["ClientBootstrap",7]],"d":"A `ClientBootstrap` is an easy way to bootstrap a `SocketChannel` when creating network clients.\n\nUsually you re-use a `ClientBootstrap` once you set it up and called `connect` multiple times on it.\nThis way you ensure that the same `EventLoop`s will be shared across all your connections.\n\nExample:\n\n```swift\n    let group = MultiThreadedEventLoopGroup(numberOfThreads: 1)\n    defer {\n        try! group.syncShutdownGracefully()\n    }\n    let bootstrap = ClientBootstrap(group: group)\n        // Enable SO_REUSEADDR.\n        .channelOption(ChannelOptions.socketOption(.so_reuseaddr), value: 1)\n        .channelInitializer { channel in\n            // always instantiate the handler _within_ the closure as\n            // it may be called multiple times (for example if the hostname\n            // resolves to both IPv4 and IPv6 addresses, cf. Happy Eyeballs).\n            channel.pipeline.addHandler(MyChannelHandler())\n        }\n    try! bootstrap.connect(host: \"example.org\", port: 12345).wait()\n    /* the Channel is now connected */\n```\n\nThe connected `SocketChannel` will operate on `ByteBuffer` as inbound and on `IOData` as outbound messages."},{"p":["ServerBootstrap"],"f":[["final",12],[" ",17],["class",12],[" ",17],["ServerBootstrap",7]],"s":[["class",12],[" ",17],["ServerBootstrap",7]],"d":"A `ServerBootstrap` is an easy way to bootstrap a `ServerSocketChannel` when creating network servers.\n\nExample:\n\n```swift\n    let group = MultiThreadedEventLoopGroup(numberOfThreads: System.coreCount)\n    defer {\n        try! group.syncShutdownGracefully()\n    }\n    let bootstrap = ServerBootstrap(group: group)\n        // Specify backlog and enable SO_REUSEADDR for the server itself\n        .serverChannelOption(ChannelOptions.backlog, value: 256)\n        .serverChannelOption(ChannelOptions.socketOption(.so_reuseaddr), value: 1)\n\n        // Set the handlers that are applied to the accepted child `Channel`s.\n        .childChannelInitializer { channel in\n            // Ensure we don't read faster then we can write by adding the BackPressureHandler into the pipeline.\n            channel.pipeline.addHandler(BackPressureHandler()).flatMap { () in\n                // make sure to instantiate your `ChannelHandlers` inside of\n                // the closure as it will be invoked once per connection.\n                channel.pipeline.addHandler(MyChannelHandler())\n            }\n        }\n\n        // Enable SO_REUSEADDR for the accepted Channels\n        .childChannelOption(ChannelOptions.socketOption(.so_reuseaddr), value: 1)\n        .childChannelOption(ChannelOptions.maxMessagesPerRead, value: 16)\n        .childChannelOption(ChannelOptions.recvAllocator, value: AdaptiveRecvByteBufferAllocator())\n    let channel = try! bootstrap.bind(host: host, port: port).wait()\n    /* the server will now be accepting connections */\n\n    try! channel.closeFuture.wait() // wait forever as we never close the Channel\n```\n\nThe `EventLoopFuture` returned by `bind` will fire with a `ServerSocketChannel`. This is the channel that owns the listening socket.\nEach time it accepts a new connection it will fire a `SocketChannel` through the `ChannelPipeline` via `fireChannelRead`: as a result,\nthe `ServerSocketChannel` operates on `Channel`s as inbound messages. Outbound messages are not supported on a `ServerSocketChannel`\nwhich means that each write attempt will fail.\n\nAccepted `SocketChannel`s operate on `ByteBuffer` as inbound data, and `IOData` as outbound data."},{"p":["NIOPipeBootstrap"],"f":[["final",12],[" ",17],["class",12],[" ",17],["NIOPipeBootstrap",7]],"s":[["class",12],[" ",17],["NIOPipeBootstrap",7]],"d":"A `NIOPipeBootstrap` is an easy way to bootstrap a `PipeChannel` which uses two (uni-directional) UNIX pipes\nand makes a `Channel` out of them.\n\nExample bootstrapping a `Channel` using `stdin` and `stdout`:\n\n    let channel = try NIOPipeBootstrap(group: group)\n                      .channelInitializer { channel in\n                          channel.pipeline.addHandler(MyChannelHandler())\n                      }\n                      .withPipes(inputDescriptor: STDIN_FILENO, outputDescriptor: STDOUT_FILENO)\n"},{"p":["DatagramBootstrap"],"f":[["final",12],[" ",17],["class",12],[" ",17],["DatagramBootstrap",7]],"s":[["class",12],[" ",17],["DatagramBootstrap",7]],"d":"A `DatagramBootstrap` is an easy way to bootstrap a `DatagramChannel` when creating datagram clients\nand servers.\n\nExample:\n\n```swift\n    let group = MultiThreadedEventLoopGroup(numberOfThreads: 1)\n    defer {\n        try! group.syncShutdownGracefully()\n    }\n    let bootstrap = DatagramBootstrap(group: group)\n        // Enable SO_REUSEADDR.\n        .channelOption(ChannelOptions.socketOption(.so_reuseaddr), value: 1)\n        .channelInitializer { channel in\n            channel.pipeline.addHandler(MyChannelHandler())\n        }\n    let channel = try! bootstrap.bind(host: \"127.0.0.1\", port: 53).wait()\n    /* the Channel is now ready to send/receive datagrams */\n\n    try channel.closeFuture.wait()  // Wait until the channel un-binds.\n```\n\nThe `DatagramChannel` will operate on `AddressedEnvelope<ByteBuffer>` as inbound and outbound messages."},{"p":["ThreadSpecificVariable"],"f":[["final",12],[" ",17],["class",12],[" ",17],["ThreadSpecificVariable",7],["<",17],["Value",0],["> ",17],["where",12],[" ",17],["Value",18],[" : AnyObject",17]],"s":[["class",12],[" ",17],["ThreadSpecificVariable",7]],"g":[["Value",0,0]],"d":"A `ThreadSpecificVariable` is a variable that can be read and set like a normal variable except that it holds\ndifferent variables per thread.\n\n`ThreadSpecificVariable` is thread-safe so it can be used with multiple threads at the same time but the value\nreturned by `currentValue` is defined per thread."},{"p":["MultiThreadedEventLoopGroup"],"f":[["final",12],[" ",17],["class",12],[" ",17],["MultiThreadedEventLoopGroup",7]],"s":[["class",12],[" ",17],["MultiThreadedEventLoopGroup",7]],"d":"An `EventLoopGroup` which will create multiple `EventLoop`s, each tied to its own `NIOThread`.\n\nThe effect of initializing a `MultiThreadedEventLoopGroup` is to spawn `numberOfThreads` fresh threads which will\nall run their own `EventLoop`. Those threads will not be shut down until `shutdownGracefully` or\n`syncShutdownGracefully` is called.\n\n- note: It's good style to call `MultiThreadedEventLoopGroup.shutdownGracefully` or\n        `MultiThreadedEventLoopGroup.syncShutdownGracefully` when you no longer need this `EventLoopGroup`. In\n        many cases that is just before your program exits.\n- warning: Unit tests often spawn one `MultiThreadedEventLoopGroup` per unit test to force isolation between the\n           tests. In those cases it's important to shut the `MultiThreadedEventLoopGroup` down at the end of the\n           test. A good place to start a `MultiThreadedEventLoopGroup` is the `setUp` method of your `XCTestCase`\n           subclass, a good place to shut it down is the `tearDown` method."},{"p":["NIOThreadPool","WorkItemState","active"],"f":[["case",12],[" ",17],["active",7]],"s":[["case",12],[" ",17],["active",7]],"d":"The `WorkItem` is active now and in process by the `NIOThreadPool`."},{"p":["NIOThreadPool","WorkItemState","cancelled"],"f":[["case",12],[" ",17],["cancelled",7]],"s":[["case",12],[" ",17],["cancelled",7]],"d":"The `WorkItem` was cancelled and will not be processed by the `NIOThreadPool`."},{"p":["NonBlockingFileIO","Error","descriptorSetToNonBlocking"],"f":[["case",12],[" ",17],["descriptorSetToNonBlocking",7]],"s":[["case",12],[" ",17],["descriptorSetToNonBlocking",7]],"d":"`NonBlockingFileIO` is meant to be used with file descriptors that are set to the default (blocking) mode.\nIt doesn't make sense to use it with a file descriptor where `O_NONBLOCK` is set therefore this error is\nraised when that was requested."},{"p":["NIOThreadPool","init(numberOfThreads:)"],"f":[["init",10],["(",17],["numberOfThreads",1],[": ",17],["Int",18,147],[")",17]],"s":[["init",10],["(",17],["numberOfThreads",1],[": ",17],["Int",18],[")",17]],"d":"Initialize a `NIOThreadPool` thread pool with `numberOfThreads` threads.\n\n- parameters:\n  - numberOfThreads: The number of threads to use for the thread pool."},{"p":["ClientBootstrap","init(validatingGroup:)"],"f":[["init",10],["?(",17],["validatingGroup",1],[" ",17],["group",2],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["init",10],["?(",17],["validatingGroup",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `ClientBootstrap` on the `EventLoopGroup` `group`, validating that `group` is compatible.\n\n- parameters:\n    - group: The `EventLoopGroup` to use."},{"p":["ClientBootstrap","init(group:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `ClientBootstrap` on the `EventLoopGroup` `group`.\n\nThe `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `ClientBootstrap` is\ncompatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by\n`MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:)` for a fallible initializer for\nsituations where it's impossible to tell ahead of time if the `EventLoopGroup` is compatible or not.\n\n- parameters:\n    - group: The `EventLoopGroup` to use."},{"p":["ServerBootstrap","init(validatingGroup:childGroup:)"],"f":[["init",10],["?(",17],["validatingGroup",1],[" ",17],["group",2],[": ",17],["EventLoopGroup",18,119],[", ",17],["childGroup",1],[": ",17],["EventLoopGroup",18,119],["? = nil)",17]],"s":[["init",10],["?(",17],["validatingGroup",1],[": ",17],["EventLoopGroup",18],[", ",17],["childGroup",1],[": ",17],["EventLoopGroup",18],["?)",17]],"d":"Create a `ServerBootstrap` on the `EventLoopGroup` `group` which accepts `Channel`s on `childGroup`, validating\nthat the `EventLoopGroup`s are compatible with `ServerBootstrap`.\n\n- parameters:\n    - group: The `EventLoopGroup` to use for the `bind` of the `ServerSocketChannel` and to accept new `SocketChannel`s with.\n    - childGroup: The `EventLoopGroup` to run the accepted `SocketChannel`s on. If `nil`, `group` is used."},{"p":["ServerBootstrap","init(group:childGroup:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18,119],[", ",17],["childGroup",1],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18],[", ",17],["childGroup",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `ServerBootstrap` on the `EventLoopGroup` `group` which accepts `Channel`s on `childGroup`.\n\nThe `EventLoopGroup`s `group` and `childGroup` must be compatible, otherwise the program will crash.\n`ServerBootstrap` is compatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by\n`MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:childGroup:)` for a fallible initializer for\nsituations where it's impossible to tell ahead of time if the `EventLoopGroup`s are compatible or not.\n\n- parameters:\n    - group: The `EventLoopGroup` to use for the `bind` of the `ServerSocketChannel` and to accept new `SocketChannel`s with.\n    - childGroup: The `EventLoopGroup` to run the accepted `SocketChannel`s on."},{"p":["ServerBootstrap","init(group:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `ServerBootstrap` on the `EventLoopGroup` `group`.\n\nThe `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `ServerBootstrap` is\ncompatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by\n`MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:childGroup:)` for a fallible initializer for\nsituations where it's impossible to tell ahead of time if the `EventLoopGroup`s are compatible or not.\n\n- parameters:\n    - group: The `EventLoopGroup` to use for the `bind` of the `ServerSocketChannel` and to accept new `SocketChannel`s with."},{"p":["NIOPipeBootstrap","init(validatingGroup:)"],"f":[["init",10],["?(",17],["validatingGroup",1],[" ",17],["group",2],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["init",10],["?(",17],["validatingGroup",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `NIOPipeBootstrap` on the `EventLoopGroup` `group`, validating that `group` is compatible.\n\n- parameters:\n    - group: The `EventLoopGroup` to use."},{"p":["NIOPipeBootstrap","init(group:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `NIOPipeBootstrap` on the `EventLoopGroup` `group`.\n\nThe `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `NIOPipeBootstrap` is\ncompatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by\n`MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:)` for a fallible initializer for\nsituations where it's impossible to tell ahead of time if the `EventLoopGroup`s are compatible or not.\n\n- parameters:\n    - group: The `EventLoopGroup` to use."},{"p":["DatagramBootstrap","init(validatingGroup:)"],"f":[["init",10],["?(",17],["validatingGroup",1],[" ",17],["group",2],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["init",10],["?(",17],["validatingGroup",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `DatagramBootstrap` on the `EventLoopGroup` `group`, validating that `group` is compatible.\n\n- parameters:\n    - group: The `EventLoopGroup` to use."},{"p":["DatagramBootstrap","init(group:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18,119],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["group",1],[": ",17],["EventLoopGroup",18],[")",17]],"d":"Create a `DatagramBootstrap` on the `EventLoopGroup` `group`.\n\nThe `EventLoopGroup` `group` must be compatible, otherwise the program will crash. `DatagramBootstrap` is\ncompatible only with `MultiThreadedEventLoopGroup` as well as the `EventLoop`s returned by\n`MultiThreadedEventLoopGroup.next`. See `init(validatingGroup:)` for a fallible initializer for\nsituations where it's impossible to tell ahead of time if the `EventLoopGroup` is compatible or not.\n\n- parameters:\n    - group: The `EventLoopGroup` to use."},{"p":["NonBlockingFileIO","init(threadPool:)"],"f":[["init",10],["(",17],["threadPool",1],[": ",17],["NIOThreadPool",18,11],[")",17]],"s":[["init",10],["(",17],["threadPool",1],[": ",17],["NIOThreadPool",18],[")",17]],"d":"Initialize a `NonBlockingFileIO` which uses the `NIOThreadPool`.\n\n- parameters:\n  - threadPool: The `NIOThreadPool` that will be used for all the IO."},{"p":["ThreadSpecificVariable","init(value:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["value",1],[": ",17],["Value",18],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["value",1],[": ",17],["Value",18],[")",17]],"g":[["Value",0,0]],"d":"Initialize a new `ThreadSpecificVariable` with `value` for the calling thread. After calling this, the calling\nthread will see `currentValue == value` but on all other threads `currentValue` will be `nil` until changed.\n\n- parameters:\n  - value: The value to set for the calling thread."},{"p":["ThreadSpecificVariable","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"g":[["Value",0,0]],"d":"Initialize a new `ThreadSpecificVariable` without a current value (`currentValue == nil`)."},{"p":["MultiThreadedEventLoopGroup","init(numberOfThreads:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["numberOfThreads",1],[": ",17],["Int",18,147],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["numberOfThreads",1],[": ",17],["Int",18],[")",17]],"d":"Creates a `MultiThreadedEventLoopGroup` instance which uses `numberOfThreads`.\n\n- note: Don't forget to call `shutdownGracefully` or `syncShutdownGracefully` when you no longer need this\n        `EventLoopGroup`. If you forget to shut the `EventLoopGroup` down you will leak `numberOfThreads`\n        (kernel) threads which are costly resources. This is especially important in unit tests where one\n        `MultiThreadedEventLoopGroup` is started per test case.\n\n- arguments:\n    - numberOfThreads: The number of `Threads` to use."},{"p":["NonBlockingFileIO","defaultChunkSize"],"f":[["static",12],[" ",17],["let",12],[" ",17],["defaultChunkSize",7],[": ",17],["Int",18,147]],"s":[["static",12],[" ",17],["let",12],[" ",17],["defaultChunkSize",7],[": ",17],["Int",18]],"d":"The default and recommended chunk size."},{"p":["NonBlockingFileIO","defaultThreadPoolSize"],"f":[["static",12],[" ",17],["let",12],[" ",17],["defaultThreadPoolSize",7],[": ",17],["Int",18,147]],"s":[["static",12],[" ",17],["let",12],[" ",17],["defaultThreadPoolSize",7],[": ",17],["Int",18]],"d":"The default and recommended size for `NonBlockingFileIO`'s thread pool."},{"p":["MultiThreadedEventLoopGroup","currentEventLoop"],"f":[["static",12],[" ",17],["var",12],[" ",17],["currentEventLoop",7],[": ",17],["EventLoop",18,140],["? { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["currentEventLoop",7],[": ",17],["EventLoop",18],["?",17]],"d":"Returns the `EventLoop` for the calling thread.\n\n- returns: The current `EventLoop` for the calling thread or `nil` if none is assigned to the thread."},{"p":["NIOConnectionError","dnsAAAAError"],"f":[["var",12],[" ",17],["dnsAAAAError",7],[": ",17],["Error",18,153],["? { get }",17]],"s":[["var",12],[" ",17],["dnsAAAAError",7],[": ",17],["Error",18],["?",17]],"d":"The error we encountered doing the DNS AAAA lookup, if any."},{"p":["NIOConnectionError","connectionErrors"],"f":[["var",12],[" ",17],["connectionErrors",7],[": [",17],["SingleConnectionFailure",18,8],["] { get }",17]],"s":[["var",12],[" ",17],["connectionErrors",7],[": [",17],["SingleConnectionFailure",18],["]",17]],"d":"The errors we encountered during the connection attempts."},{"p":["NIOConnectionError","host"],"f":[["let",12],[" ",17],["host",7],[": ",17],["String",18,145]],"s":[["let",12],[" ",17],["host",7],[": ",17],["String",18]],"d":"The hostname SwiftNIO was trying to connect to."},{"p":["NIOConnectionError","port"],"f":[["let",12],[" ",17],["port",7],[": ",17],["Int",18,147]],"s":[["let",12],[" ",17],["port",7],[": ",17],["Int",18]],"d":"The port SwiftNIO was trying to connect to."},{"p":["NIOConnectionError","dnsAError"],"f":[["var",12],[" ",17],["dnsAError",7],[": ",17],["Error",18,153],["? { get }",17]],"s":[["var",12],[" ",17],["dnsAError",7],[": ",17],["Error",18],["?",17]],"d":"The error we encountered doing the DNS A lookup, if any."},{"p":["ThreadSpecificVariable","currentValue"],"f":[["var",12],[" ",17],["currentValue",7],[": ",17],["Value",18],["? { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["currentValue",7],[": ",17],["Value",18],["?",17]],"d":"The value for the current thread."},{"p":["SingleConnectionFailure","error"],"f":[["let",12],[" ",17],["error",7],[": ",17],["Error",18,153]],"s":[["let",12],[" ",17],["error",7],[": ",17],["Error",18]],"d":"The error we encountered."},{"p":["SingleConnectionFailure","target"],"f":[["let",12],[" ",17],["target",7],[": ",17],["SocketAddress",18,117]],"s":[["let",12],[" ",17],["target",7],[": ",17],["SocketAddress",18]],"d":"The target we were trying to connect to when we encountered the error."},{"p":["MultiThreadedEventLoopGroup","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,145],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"o":149},{"p":["MultiThreadedEventLoopGroup","withCurrentThreadAsEventLoop(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["withCurrentThreadAsEventLoop",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["EventLoop",18,140],[") -> ",17],["Void",18,152],[")",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["withCurrentThreadAsEventLoop",7],["((",17],["EventLoop",18],[") -> ",17],["Void",18],[")",17]],"d":"Convert the calling thread into an `EventLoop`.\n\nThis function will not return until the `EventLoop` has stopped. You can initiate stopping the `EventLoop` by\ncalling `eventLoop.shutdownGracefully` which will eventually make this function return.\n\n- parameters:\n    - callback: Called _on_ the `EventLoop` that the calling thread was converted to, providing you the\n                `EventLoop` reference. Just like usually on the `EventLoop`, do not block in `callback`."},{"p":["NIOThreadPool","runIfActive(eventLoop:_:)"],"f":[["func",12],[" ",17],["runIfActive",7],["<",17],["T",0],[">(",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[", ",17],["_",1],[" ",17],["body",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["EventLoopFuture",18,128],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["runIfActive",7],["<",17],["T",0],[">(",17],["eventLoop",1],[": ",17],["EventLoop",18],[", () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">",17]],"g":[["T",0,0]],"d":"Runs the submitted closure if the thread pool is still active, otherwise fails the promise.\nThe closure will be run on the thread pool so can do blocking work.\n\n- parameters:\n    - eventLoop: The `EventLoop` the returned `EventLoopFuture` will fire on.\n    - body: The closure which performs some blocking work to be done on the thread pool.\n- returns: The `EventLoopFuture` of `promise` fulfilled with the result (or error) of the passed closure."},{"p":["NIOThreadPool","shutdownGracefully(queue:_:)"],"f":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18,141],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,153],["?) -> ",17],["Void",18,152],[")",17]],"s":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18],[", (",17],["Error",18],["?) -> ",17],["Void",18],[")",17]],"d":"Gracefully shutdown this `NIOThreadPool`. All tasks will be run before shutdown will take place.\n\n- parameters:\n    - queue: The `DispatchQueue` used to executed the callback\n    - callback: The function to be executed once the shutdown is complete."},{"p":["NIOThreadPool","shutdownGracefully(_:)"],"f":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,153],["?) -> ",17],["Void",18,152],[")",17]],"s":[["func",12],[" ",17],["shutdownGracefully",7],["((",17],["Error",18],["?) -> ",17],["Void",18],[")",17]]},{"p":["NIOThreadPool","syncShutdownGracefully()"],"f":[["func",12],[" ",17],["syncShutdownGracefully",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["syncShutdownGracefully",7],["() ",17],["throws",12]]},{"p":["NIOThreadPool","start()"],"f":[["func",12],[" ",17],["start",7],["()",17]],"s":[["func",12],[" ",17],["start",7],["()",17]],"d":"Start the `NIOThreadPool` if not already started."},{"p":["NIOThreadPool","submit(_:)"],"f":[["func",12],[" ",17],["submit",7],["(",17],["_",1],[" ",17],["body",2],[": ",17],["@escaping",12],[" ",17],["NIOThreadPool",18,11],[".",17],["WorkItem",18,107],[")",17]],"s":[["func",12],[" ",17],["submit",7],["(",17],["NIOThreadPool",18],[".",17],["WorkItem",18],[")",17]],"d":"Submit a `WorkItem` to process.\n\n- note: This is a low-level method, in most cases the `runIfActive` method should be used.\n\n- parameters:\n    - body: The `WorkItem` to process by the `NIOThreadPool`."},{"p":["ClientBootstrap","channelOption(_:value:)"],"f":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,113]],"s":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18]],"c":[["Option",1,"ChannelOption",113]],"g":[["Option",0,0]],"d":"Specifies a `ChannelOption` to be applied to the `SocketChannel`.\n\n- parameters:\n    - option: The option to be applied.\n    - value: The value for the option.","o":132},{"p":["ClientBootstrap","connectTimeout(_:)"],"f":[["func",12],[" ",17],["connectTimeout",7],["(",17],["_",1],[" ",17],["timeout",2],[": ",17],["TimeAmount",18,110],[") -> ",17],["Self",18]],"s":[["func",12],[" ",17],["connectTimeout",7],["(",17],["TimeAmount",18],[") -> ",17],["Self",18]],"d":"Specifies a timeout to apply to a connection attempt.\n\n- parameters:\n    - timeout: The timeout that will apply to the connection attempt.","o":133},{"p":["ClientBootstrap","protocolHandlers(_:)"],"f":[["func",12],[" ",17],["protocolHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": ",17],["@escaping",12],[" () -> [",17],["ChannelHandler",18,118],["]) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["protocolHandlers",7],["(() -> [",17],["ChannelHandler",18],["]) -> ",17],["Self",18]],"d":"Sets the protocol handlers that will be added to the front of the `ChannelPipeline` right after the\n`channelInitializer` has been called.\n\nPer bootstrap, you can only set the `protocolHandlers` once. Typically, `protocolHandlers` are used for the TLS\nimplementation. Most notably, `NIOClientTCPBootstrap`, NIO's \"universal bootstrap\" abstraction, uses\n`protocolHandlers` to add the required `ChannelHandler`s for many TLS implementations.","o":134},{"p":["ClientBootstrap","channelInitializer(_:)"],"f":[["func",12],[" ",17],["channelInitializer",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["@escaping",12],[" (",17],["Channel",18,139],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["channelInitializer",7],["((",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["Self",18]],"d":"Initialize the connected `SocketChannel` with `initializer`. The most common task in initializer is to add\n`ChannelHandler`s to the `ChannelPipeline`.\n\nThe connected `Channel` will operate on `ByteBuffer` as inbound and `IOData` as outbound messages.\n\n- warning: The `handler` closure may be invoked _multiple times_ so it's usually the right choice to instantiate\n           `ChannelHandler`s within `handler`. The reason `handler` may be invoked multiple times is that to\n           successfully set up a connection multiple connections might be setup in the process. Assuming a\n           hostname that resolves to both IPv4 and IPv6 addresses, NIO will follow\n           [_Happy Eyeballs_](https://en.wikipedia.org/wiki/Happy_Eyeballs) and race both an IPv4 and an IPv6\n           connection. It is possible that both connections get fully established before the IPv4 connection\n           will be closed again because the IPv6 connection 'won the race'. Therefore the `channelInitializer`\n           might be called multiple times and it's important not to share stateful `ChannelHandler`s in more\n           than one `Channel`.\n\n- parameters:\n    - handler: A closure that initializes the provided `Channel`.","o":135},{"p":["ClientBootstrap","withConnectedSocket(descriptor:)"],"f":[["func",12],[" ",17],["withConnectedSocket",7],["(",17],["descriptor",1],[": ",17],["CInt",18,151],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withConnectedSocket",7],["(",17],["descriptor",1],[": ",17],["CInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"a":{"a":{"d":true,"r":"withConnectedSocket(_:)"}},"d":"Use the existing connected socket file descriptor.\n\n- parameters:\n    - descriptor: The _Unix file descriptor_ representing the connected stream socket.\n- returns: an `EventLoopFuture<Channel>` to deliver the `Channel`."},{"p":["ClientBootstrap","withConnectedSocket(_:)"],"f":[["func",12],[" ",17],["withConnectedSocket",7],["(",17],["_",1],[" ",17],["socket",2],[": ",17],["NIOBSDSocket",18,111],[".",17],["Handle",18,112],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withConnectedSocket",7],["(",17],["NIOBSDSocket",18],[".",17],["Handle",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Use the existing connected socket file descriptor.\n\n- parameters:\n    - descriptor: The _Unix file descriptor_ representing the connected stream socket.\n- returns: an `EventLoopFuture<Channel>` to deliver the `Channel`."},{"p":["ClientBootstrap","bind(to:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,117],[") -> ",17],["ClientBootstrap",18,12]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[") -> ",17],["ClientBootstrap",18]],"d":"Bind the `SocketChannel` to `address`.\n\nUsing `bind` is not necessary unless you need the local address to be bound to a specific address.\n\n- note: Using `bind` will disable Happy Eyeballs on this `Channel`.\n\n- parameters:\n    - address: The `SocketAddress` to bind on."},{"p":["ClientBootstrap","connect(unixDomainSocketPath:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,145],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `unixDomainSocket` path to connect to for the UDS `Channel` that will be established.\n\n- parameters:\n    - unixDomainSocketPath: The _Unix domain socket_ path to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected.","o":136},{"p":["ClientBootstrap","connect(to:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,117],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `address` to connect to for the TCP `Channel` that will be established.\n\n- parameters:\n    - address: The address to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected.","o":137},{"p":["ClientBootstrap","connect(host:port:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["host",1],[": ",17],["String",18,145],[", ",17],["port",1],[": ",17],["Int",18,147],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `host` and `port` to connect to for the TCP `Channel` that will be established.\n\n- parameters:\n    - host: The host to connect to.\n    - port: The port to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected.","o":138},{"p":["ClientBootstrap","resolver(_:)"],"f":[["func",12],[" ",17],["resolver",7],["(",17],["_",1],[" ",17],["resolver",2],[": ",17],["Resolver",18,0],["?) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["resolver",7],["(",17],["Resolver",18],["?) -> ",17],["Self",18]],"d":"Specifies the `Resolver` to use or `nil` if the default should be used.\n\n- parameters:\n    - resolver: The resolver that will be used during the connection attempt."},{"p":["ServerBootstrap","bindTimeout(_:)"],"f":[["func",12],[" ",17],["bindTimeout",7],["(",17],["_",1],[" ",17],["timeout",2],[": ",17],["TimeAmount",18,110],[") -> ",17],["Self",18]],"s":[["func",12],[" ",17],["bindTimeout",7],["(",17],["TimeAmount",18],[") -> ",17],["Self",18]],"d":"Specifies a timeout to apply to a bind attempt. Currently unsupported.\n\n- parameters:\n    - timeout: The timeout that will apply to the bind attempt."},{"p":["ServerBootstrap","withBoundSocket(descriptor:)"],"f":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["descriptor",1],[": ",17],["CInt",18,151],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["descriptor",1],[": ",17],["CInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"a":{"a":{"d":true,"r":"withBoundSocket(_:)"}},"d":"Use the existing bound socket file descriptor.\n\n- parameters:\n    - descriptor: The _Unix file descriptor_ representing the bound stream socket."},{"p":["ServerBootstrap","withBoundSocket(_:)"],"f":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["_",1],[" ",17],["socket",2],[": ",17],["NIOBSDSocket",18,111],[".",17],["Handle",18,112],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["NIOBSDSocket",18],[".",17],["Handle",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Use the existing bound socket file descriptor.\n\n- parameters:\n    - descriptor: The _Unix file descriptor_ representing the bound stream socket."},{"p":["ServerBootstrap","childChannelOption(_:value:)"],"f":[["func",12],[" ",17],["childChannelOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,113]],"s":[["func",12],[" ",17],["childChannelOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18]],"c":[["Option",1,"ChannelOption",113]],"g":[["Option",0,0]],"d":"Specifies a `ChannelOption` to be applied to the accepted `SocketChannel`s.\n\n- parameters:\n    - option: The option to be applied.\n    - value: The value for the option."},{"p":["ServerBootstrap","serverChannelOption(_:value:)"],"f":[["func",12],[" ",17],["serverChannelOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,113]],"s":[["func",12],[" ",17],["serverChannelOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18]],"c":[["Option",1,"ChannelOption",113]],"g":[["Option",0,0]],"d":"Specifies a `ChannelOption` to be applied to the `ServerSocketChannel`.\n\n- note: To specify options for the accepted `SocketChannel`s, look at `ServerBootstrap.childChannelOption`.\n\n- parameters:\n    - option: The option to be applied.\n    - value: The value for the option."},{"p":["ServerBootstrap","childChannelInitializer(_:)"],"f":[["func",12],[" ",17],["childChannelInitializer",7],["(",17],["_",1],[" ",17],["initializer",2],[": ",17],["@escaping",12],[" (",17],["Channel",18,139],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["childChannelInitializer",7],["((",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["Self",18]],"d":"Initialize the accepted `SocketChannel`s with `initializer`. The most common task in initializer is to add\n`ChannelHandler`s to the `ChannelPipeline`. Note that if the `initializer` fails then the error will be\nfired in the *parent* channel.\n\n- warning: The `initializer` will be invoked once for every accepted connection. Therefore it's usually the\n           right choice to instantiate stateful `ChannelHandler`s within the closure to make sure they are not\n           accidentally shared across `Channel`s. There are expert use-cases where stateful handler need to be\n           shared across `Channel`s in which case the user is responsible to synchronise the state access\n           appropriately.\n\nThe accepted `Channel` will operate on `ByteBuffer` as inbound and `IOData` as outbound messages.\n\n- parameters:\n    - initializer: A closure that initializes the provided `Channel`."},{"p":["ServerBootstrap","serverChannelInitializer(_:)"],"f":[["func",12],[" ",17],["serverChannelInitializer",7],["(",17],["_",1],[" ",17],["initializer",2],[": ",17],["@escaping",12],[" (",17],["Channel",18,139],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["serverChannelInitializer",7],["((",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["Self",18]],"d":"Initialize the `ServerSocketChannel` with `initializer`. The most common task in initializer is to add\n`ChannelHandler`s to the `ChannelPipeline`.\n\nThe `ServerSocketChannel` uses the accepted `Channel`s as inbound messages.\n\n- note: To set the initializer for the accepted `SocketChannel`s, look at `ServerBootstrap.childChannelInitializer`.\n\n- parameters:\n    - initializer: A closure that initializes the provided `Channel`."},{"p":["ServerBootstrap","bind(unixDomainSocketPath:cleanupExistingSocketFile:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,145],[", ",17],["cleanupExistingSocketFile",1],[": ",17],["Bool",18,146],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[", ",17],["cleanupExistingSocketFile",1],[": ",17],["Bool",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `ServerSocketChannel` to a UNIX Domain Socket.\n\n- parameters:\n    - unixDomainSocketPath: The _Unix domain socket_ path to bind to. `unixDomainSocketPath` must not exist, it will be created by the system.\n    - cleanupExistingSocketFile: Whether to cleanup an existing socket file at `path`."},{"p":["ServerBootstrap","bind(unixDomainSocketPath:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,145],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `ServerSocketChannel` to a UNIX Domain Socket.\n\n- parameters:\n    - unixDomainSocketPath: The _Unix domain socket_ path to bind to. `unixDomainSocketPath` must not exist, it will be created by the system."},{"p":["ServerBootstrap","bind(to:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,117],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `ServerSocketChannel` to `address`.\n\n- parameters:\n    - address: The `SocketAddress` to bind on."},{"p":["ServerBootstrap","bind(host:port:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["host",1],[": ",17],["String",18,145],[", ",17],["port",1],[": ",17],["Int",18,147],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `ServerSocketChannel` to `host` and `port`.\n\n- parameters:\n    - host: The host to bind on.\n    - port: The port to bind on."},{"p":["NIOPipeBootstrap","channelOption(_:value:)"],"f":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,113]],"s":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18]],"c":[["Option",1,"ChannelOption",113]],"g":[["Option",0,0]],"d":"Specifies a `ChannelOption` to be applied to the `PipeChannel`.\n\n- parameters:\n    - option: The option to be applied.\n    - value: The value for the option."},{"p":["NIOPipeBootstrap","channelInitializer(_:)"],"f":[["func",12],[" ",17],["channelInitializer",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["@escaping",12],[" (",17],["Channel",18,139],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["channelInitializer",7],["((",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["Self",18]],"d":"Initialize the connected `PipeChannel` with `initializer`. The most common task in initializer is to add\n`ChannelHandler`s to the `ChannelPipeline`.\n\nThe connected `Channel` will operate on `ByteBuffer` as inbound and outbound messages. Please note that\n`IOData.fileRegion` is _not_ supported for `PipeChannel`s because `sendfile` only works on sockets.\n\n- parameters:\n    - handler: A closure that initializes the provided `Channel`."},{"p":["NIOPipeBootstrap","withInputOutputDescriptor(_:)"],"f":[["func",12],[" ",17],["withInputOutputDescriptor",7],["(",17],["_",1],[" ",17],["fileDescriptor",2],[": ",17],["CInt",18,151],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withInputOutputDescriptor",7],["(",17],["CInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Create the `PipeChannel` with the provided file descriptor which is used for both input & output.\n\nThis method is useful for specialilsed use-cases where you want to use `NIOPipeBootstrap` for say a serial line.\n\n- note: If this method returns a succeeded future, SwiftNIO will close `fileDescriptor` when the `Channel`\n        becomes inactive. You _must not_ do any further operations with `fileDescriptor`, including `close`.\n        If this method returns a failed future, you still own the file descriptor and are responsible for\n        closing it.\n\n- parameters:\n    - fileDescriptor: The _Unix file descriptor_ for the input & output.\n- returns: an `EventLoopFuture<Channel>` to deliver the `Channel`."},{"p":["NIOPipeBootstrap","withPipes(inputDescriptor:outputDescriptor:)"],"f":[["func",12],[" ",17],["withPipes",7],["(",17],["inputDescriptor",1],[": ",17],["CInt",18,151],[", ",17],["outputDescriptor",1],[": ",17],["CInt",18,151],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withPipes",7],["(",17],["inputDescriptor",1],[": ",17],["CInt",18],[", ",17],["outputDescriptor",1],[": ",17],["CInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Create the `PipeChannel` with the provided input and output file descriptors.\n\nThe input and output file descriptors must be distinct. If you have a single file descriptor, consider using\n`ClientBootstrap.withConnectedSocket(descriptor:)` if it's a socket or\n`NIOPipeBootstrap.withInputOutputDescriptor` if it is not a socket.\n\n- note: If this method returns a succeeded future, SwiftNIO will close `inputDescriptor` and `outputDescriptor`\n        when the `Channel` becomes inactive. You _must not_ do any further operations `inputDescriptor` or\n        `outputDescriptor`, including `close`.\n        If this method returns a failed future, you still own the file descriptors and are responsible for\n        closing them.\n\n- parameters:\n    - inputDescriptor: The _Unix file descriptor_ for the input (ie. the read side).\n    - outputDescriptor: The _Unix file descriptor_ for the output (ie. the write side).\n- returns: an `EventLoopFuture<Channel>` to deliver the `Channel`."},{"p":["DatagramBootstrap","channelOption(_:value:)"],"f":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,113]],"s":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18]],"c":[["Option",1,"ChannelOption",113]],"g":[["Option",0,0]],"d":"Specifies a `ChannelOption` to be applied to the `DatagramChannel`.\n\n- parameters:\n    - option: The option to be applied.\n    - value: The value for the option."},{"p":["DatagramBootstrap","withBoundSocket(descriptor:)"],"f":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["descriptor",1],[": ",17],["CInt",18,151],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["descriptor",1],[": ",17],["CInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"a":{"a":{"d":true,"r":"withBoundSocket(_:)"}},"d":"Use the existing bound socket file descriptor.\n\n- parameters:\n    - descriptor: The _Unix file descriptor_ representing the bound datagram socket."},{"p":["DatagramBootstrap","withBoundSocket(_:)"],"f":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["_",1],[" ",17],["socket",2],[": ",17],["NIOBSDSocket",18,111],[".",17],["Handle",18,112],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["withBoundSocket",7],["(",17],["NIOBSDSocket",18],[".",17],["Handle",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Use the existing bound socket file descriptor.\n\n- parameters:\n    - descriptor: The _Unix file descriptor_ representing the bound datagram socket."},{"p":["DatagramBootstrap","channelInitializer(_:)"],"f":[["func",12],[" ",17],["channelInitializer",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["@escaping",12],[" (",17],["Channel",18,139],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["channelInitializer",7],["((",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["Self",18]],"d":"Initialize the bound `DatagramChannel` with `initializer`. The most common task in initializer is to add\n`ChannelHandler`s to the `ChannelPipeline`.\n\n- parameters:\n    - handler: A closure that initializes the provided `Channel`."},{"p":["DatagramBootstrap","bind(unixDomainSocketPath:cleanupExistingSocketFile:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,145],[", ",17],["cleanupExistingSocketFile",1],[": ",17],["Bool",18,146],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[", ",17],["cleanupExistingSocketFile",1],[": ",17],["Bool",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `DatagramChannel` to a UNIX Domain Socket.\n\n- parameters:\n    - unixDomainSocketPath: The path of the UNIX Domain Socket to bind on. `path` must not exist, it will be created by the system.\n    - cleanupExistingSocketFile: Whether to cleanup an existing socket file at `path`."},{"p":["DatagramBootstrap","bind(unixDomainSocketPath:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,145],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `DatagramChannel` to a UNIX Domain Socket.\n\n- parameters:\n    - unixDomainSocketPath: The path of the UNIX Domain Socket to bind on. `path` must not exist, it will be created by the system."},{"p":["DatagramBootstrap","bind(to:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,117],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `DatagramChannel` to `address`.\n\n- parameters:\n    - address: The `SocketAddress` to bind on."},{"p":["DatagramBootstrap","bind(host:port:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["host",1],[": ",17],["String",18,145],[", ",17],["port",1],[": ",17],["Int",18,147],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Channel",18,139],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Bind the `DatagramChannel` to `host` and `port`.\n\n- parameters:\n    - host: The host to bind on.\n    - port: The port to bind on."},{"p":["NonBlockingFileIO","openFile(path:mode:flags:eventLoop:)"],"f":[["func",12],[" ",17],["openFile",7],["(",17],["path",1],[": ",17],["String",18,145],[", ",17],["mode",1],[": ",17],["NIOFileHandle",18,114],[".",17],["Mode",18,115],[", ",17],["flags",1],[": ",17],["NIOFileHandle",18,114],[".",17],["Flags",18,116],[" = .default, ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<",17],["NIOFileHandle",18,114],[">",17]],"s":[["func",12],[" ",17],["openFile",7],["(",17],["path",1],[": ",17],["String",18],[", ",17],["mode",1],[": ",17],["NIOFileHandle",18],[".",17],["Mode",18],[", ",17],["flags",1],[": ",17],["NIOFileHandle",18],[".",17],["Flags",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NIOFileHandle",18],[">",17]],"d":"Open the file at `path` with specified access mode and POSIX flags on a private thread pool which is separate from any `EventLoop` thread.\n\nThis function will return (a future) of the `NIOFileHandle` associated with the file opened.\nThe caller must close the returned `NIOFileHandle` when it's no longer needed.\n\n- parameters:\n    - path: The path of the file to be opened for writing.\n    - mode: File access mode.\n    - flags: Additional POSIX flags.\n    - eventLoop: The `EventLoop` on which the returned `EventLoopFuture` will fire.\n- returns: An `EventLoopFuture` containing the `NIOFileHandle`."},{"p":["NonBlockingFileIO","openFile(path:eventLoop:)"],"f":[["func",12],[" ",17],["openFile",7],["(",17],["path",1],[": ",17],["String",18,145],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<(",17],["NIOFileHandle",18,114],[", ",17],["FileRegion",18,109],[")>",17]],"s":[["func",12],[" ",17],["openFile",7],["(",17],["path",1],[": ",17],["String",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<(",17],["NIOFileHandle",18],[", ",17],["FileRegion",18],[")>",17]],"d":"Open the file at `path` for reading on a private thread pool which is separate from any `EventLoop` thread.\n\nThis function will return (a future) of the `NIOFileHandle` associated with the file opened and a `FileRegion`\ncomprising of the whole file. The caller must close the returned `NIOFileHandle` when it's no longer needed.\n\n- note: The reason this returns the `NIOFileHandle` and the `FileRegion` is that both the opening of a file as well as the querying of its size are blocking.\n\n- parameters:\n    - path: The path of the file to be opened for reading.\n    - eventLoop: The `EventLoop` on which the returned `EventLoopFuture` will fire.\n- returns: An `EventLoopFuture` containing the `NIOFileHandle` and the `FileRegion` comprising the whole file."},{"p":["NonBlockingFileIO","readFileSize(fileHandle:eventLoop:)"],"f":[["func",12],[" ",17],["readFileSize",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Int64",18,154],[">",17]],"s":[["func",12],[" ",17],["readFileSize",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Int64",18],[">",17]],"d":"Returns the length of the file associated with `fileHandle`.\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to read from.\n  - eventLoop: The `EventLoop` to create the returned `EventLoopFuture` from.\n- returns: An `EventLoopFuture` which is fulfilled if the write was successful or fails on error."},{"p":["NonBlockingFileIO","changeFileSize(fileHandle:size:eventLoop:)"],"f":[["func",12],[" ",17],["changeFileSize",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["size",1],[": ",17],["Int64",18,154],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<()>",17]],"s":[["func",12],[" ",17],["changeFileSize",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["size",1],[": ",17],["Int64",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<()>",17]],"d":"Changes the file size of `fileHandle` to `size`.\n\nIf `size` is smaller than the current file size, the remaining bytes will be truncated and are lost. If `size`\nis larger than the current file size, the gap will be filled with zero bytes.\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to write to.\n  - size: The new file size in bytes to write.\n  - eventLoop: The `EventLoop` to create the returned `EventLoopFuture` from.\n- returns: An `EventLoopFuture` which is fulfilled if the write was successful or fails on error."},{"p":["NonBlockingFileIO","readChunked(fileHandle:fromOffset:byteCount:chunkSize:allocator:eventLoop:chunkHandler:)"],"f":[["func",12],[" ",17],["readChunked",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["fromOffset",1],[" ",17],["fileOffset",2],[": ",17],["Int64",18,154],[", ",17],["byteCount",1],[": ",17],["Int",18,147],[", ",17],["chunkSize",1],[": ",17],["Int",18,147],[" = NonBlockingFileIO.defaultChunkSize, ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,130],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[", ",17],["chunkHandler",1],[": ",17],["@escaping",12],[" (",17],["ByteBuffer",18,108],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">",17]],"s":[["func",12],[" ",17],["readChunked",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["fromOffset",1],[": ",17],["Int64",18],[", ",17],["byteCount",1],[": ",17],["Int",18],[", ",17],["chunkSize",1],[": ",17],["Int",18],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[", ",17],["chunkHandler",1],[": (",17],["ByteBuffer",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Read `byteCount` bytes from offset `fileOffset` in chunks of `chunkSize` bytes from `fileHandle` in `NonBlockingFileIO`'s private thread\npool which is separate from any `EventLoop` thread.\n\n`chunkHandler` will be called on `eventLoop` for every chunk that was read. Assuming `byteCount` is greater than\nzero and there are enough bytes available `chunkHandler` will be called `1 + |_ byteCount / chunkSize _|`\ntimes, delivering `chunkSize` bytes each time. If less than `byteCount` bytes can be read from `descriptor`,\n`chunkHandler` will be called less often with the last invocation possibly being of less than `chunkSize` bytes.\n\nThe allocation and reading of a subsequent chunk will only be attempted when `chunkHandler` succeeds.\n\nThis method will not use the file descriptor's seek pointer which means there is no danger of reading from the\nsame `NIOFileHandle` in multiple threads.\n\n- note: `readChunked(fileRegion:chunkSize:allocator:eventLoop:chunkHandler:)` should be preferred as it uses\n        `FileRegion` object instead of raw `NIOFileHandle`s.\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to read from.\n  - byteCount: The number of bytes to read from `fileHandle`.\n  - chunkSize: The size of the individual chunks to deliver.\n  - allocator: A `ByteBufferAllocator` used to allocate space for the chunks.\n  - eventLoop: The `EventLoop` to call `chunkHandler` on.\n  - chunkHandler: Called for every chunk read. The next chunk will be read upon successful completion of the returned `EventLoopFuture`. If the returned `EventLoopFuture` fails, the overall operation is aborted.\n- returns: An `EventLoopFuture` which is the result of the overall operation. If either the reading of `fileHandle` or `chunkHandler` fails, the `EventLoopFuture` will fail too. If the reading of `fileHandle` as well as `chunkHandler` always succeeded, the `EventLoopFuture` will succeed too."},{"p":["NonBlockingFileIO","readChunked(fileHandle:byteCount:chunkSize:allocator:eventLoop:chunkHandler:)"],"f":[["func",12],[" ",17],["readChunked",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["byteCount",1],[": ",17],["Int",18,147],[", ",17],["chunkSize",1],[": ",17],["Int",18,147],[" = NonBlockingFileIO.defaultChunkSize, ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,130],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[", ",17],["chunkHandler",1],[": ",17],["@escaping",12],[" (",17],["ByteBuffer",18,108],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">",17]],"s":[["func",12],[" ",17],["readChunked",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["byteCount",1],[": ",17],["Int",18],[", ",17],["chunkSize",1],[": ",17],["Int",18],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[", ",17],["chunkHandler",1],[": (",17],["ByteBuffer",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Read `byteCount` bytes in chunks of `chunkSize` bytes from `fileHandle` in `NonBlockingFileIO`'s private thread\npool which is separate from any `EventLoop` thread.\n\n`chunkHandler` will be called on `eventLoop` for every chunk that was read. Assuming `byteCount` is greater than\nzero and there are enough bytes available `chunkHandler` will be called `1 + |_ byteCount / chunkSize _|`\ntimes, delivering `chunkSize` bytes each time. If less than `byteCount` bytes can be read from `descriptor`,\n`chunkHandler` will be called less often with the last invocation possibly being of less than `chunkSize` bytes.\n\nThe allocation and reading of a subsequent chunk will only be attempted when `chunkHandler` succeeds.\n\n- note: `readChunked(fileRegion:chunkSize:allocator:eventLoop:chunkHandler:)` should be preferred as it uses\n        `FileRegion` object instead of raw `NIOFileHandle`s. In case you do want to use raw `NIOFileHandle`s,\n        please consider using `readChunked(fileHandle:fromOffset:chunkSize:allocator:eventLoop:chunkHandler:)`\n        because it doesn't use the file descriptor's seek pointer (which may be shared with other file\n        descriptors and even across processes.)\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to read from.\n  - byteCount: The number of bytes to read from `fileHandle`.\n  - chunkSize: The size of the individual chunks to deliver.\n  - allocator: A `ByteBufferAllocator` used to allocate space for the chunks.\n  - eventLoop: The `EventLoop` to call `chunkHandler` on.\n  - chunkHandler: Called for every chunk read. The next chunk will be read upon successful completion of the returned `EventLoopFuture`. If the returned `EventLoopFuture` fails, the overall operation is aborted.\n- returns: An `EventLoopFuture` which is the result of the overall operation. If either the reading of `fileHandle` or `chunkHandler` fails, the `EventLoopFuture` will fail too. If the reading of `fileHandle` as well as `chunkHandler` always succeeded, the `EventLoopFuture` will succeed too."},{"p":["NonBlockingFileIO","readChunked(fileRegion:chunkSize:allocator:eventLoop:chunkHandler:)"],"f":[["func",12],[" ",17],["readChunked",7],["(",17],["fileRegion",1],[": ",17],["FileRegion",18,109],[", ",17],["chunkSize",1],[": ",17],["Int",18,147],[" = NonBlockingFileIO.defaultChunkSize, ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,130],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[", ",17],["chunkHandler",1],[": ",17],["@escaping",12],[" (",17],["ByteBuffer",18,108],[") -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">) -> ",17],["EventLoopFuture",18,128],["<",17],["Void",18,152],[">",17]],"s":[["func",12],[" ",17],["readChunked",7],["(",17],["fileRegion",1],[": ",17],["FileRegion",18],[", ",17],["chunkSize",1],[": ",17],["Int",18],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[", ",17],["chunkHandler",1],[": (",17],["ByteBuffer",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Read a `FileRegion` in chunks of `chunkSize` bytes on `NonBlockingFileIO`'s private thread\npool which is separate from any `EventLoop` thread.\n\n`chunkHandler` will be called on `eventLoop` for every chunk that was read. Assuming `fileRegion.readableBytes` is greater than\nzero and there are enough bytes available `chunkHandler` will be called `1 + |_ fileRegion.readableBytes / chunkSize _|`\ntimes, delivering `chunkSize` bytes each time. If less than `fileRegion.readableBytes` bytes can be read from the file,\n`chunkHandler` will be called less often with the last invocation possibly being of less than `chunkSize` bytes.\n\nThe allocation and reading of a subsequent chunk will only be attempted when `chunkHandler` succeeds.\n\nThis method will not use the file descriptor's seek pointer which means there is no danger of reading from the\nsame `FileRegion` in multiple threads.\n\n- parameters:\n  - fileRegion: The file region to read.\n  - chunkSize: The size of the individual chunks to deliver.\n  - allocator: A `ByteBufferAllocator` used to allocate space for the chunks.\n  - eventLoop: The `EventLoop` to call `chunkHandler` on.\n  - chunkHandler: Called for every chunk read. The next chunk will be read upon successful completion of the returned `EventLoopFuture`. If the returned `EventLoopFuture` fails, the overall operation is aborted.\n- returns: An `EventLoopFuture` which is the result of the overall operation. If either the reading of `fileHandle` or `chunkHandler` fails, the `EventLoopFuture` will fail too. If the reading of `fileHandle` as well as `chunkHandler` always succeeded, the `EventLoopFuture` will succeed too."},{"p":["NonBlockingFileIO","read(fileHandle:fromOffset:byteCount:allocator:eventLoop:)"],"f":[["func",12],[" ",17],["read",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["fromOffset",1],[" ",17],["fileOffset",2],[": ",17],["Int64",18,154],[", ",17],["byteCount",1],[": ",17],["Int",18,147],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,130],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<",17],["ByteBuffer",18,108],[">",17]],"s":[["func",12],[" ",17],["read",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["fromOffset",1],[": ",17],["Int64",18],[", ",17],["byteCount",1],[": ",17],["Int",18],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["ByteBuffer",18],[">",17]],"d":"Read `byteCount` bytes starting at `fileOffset` from `fileHandle` in `NonBlockingFileIO`'s private thread pool\nwhich is separate from any `EventLoop` thread.\n\nThe returned `ByteBuffer` will not have less than `byteCount` bytes unless we hit end-of-file in which\ncase the `ByteBuffer` will contain the bytes available to read.\n\nThis method will not use the file descriptor's seek pointer which means there is no danger of reading from the\nsame `fileHandle` in multiple threads.\n\n- note: Only use this function for small enough `byteCount`s as it will need to allocate enough memory to hold `byteCount` bytes.\n- note: `read(fileRegion:allocator:eventLoop:)` should be preferred as it uses `FileRegion` object instead of raw `NIOFileHandle`s.\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to read.\n  - fileOffset: The offset to read from.\n  - byteCount: The number of bytes to read from `fileHandle`.\n  - allocator: A `ByteBufferAllocator` used to allocate space for the returned `ByteBuffer`.\n  - eventLoop: The `EventLoop` to create the returned `EventLoopFuture` from.\n- returns: An `EventLoopFuture` which delivers a `ByteBuffer` if the read was successful or a failure on error."},{"p":["NonBlockingFileIO","read(fileHandle:byteCount:allocator:eventLoop:)"],"f":[["func",12],[" ",17],["read",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["byteCount",1],[": ",17],["Int",18,147],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,130],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<",17],["ByteBuffer",18,108],[">",17]],"s":[["func",12],[" ",17],["read",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["byteCount",1],[": ",17],["Int",18],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["ByteBuffer",18],[">",17]],"d":"Read `byteCount` bytes from `fileHandle` in `NonBlockingFileIO`'s private thread pool which is separate from any `EventLoop` thread.\n\nThe returned `ByteBuffer` will not have less than `byteCount` bytes unless we hit end-of-file in which\ncase the `ByteBuffer` will contain the bytes available to read.\n\n- note: Only use this function for small enough `byteCount`s as it will need to allocate enough memory to hold `byteCount` bytes.\n- note: `read(fileRegion:allocator:eventLoop:)` should be preferred as it uses `FileRegion` object instead of\n        raw `NIOFileHandle`s. In case you do want to use raw `NIOFileHandle`s,\n        please consider using `read(fileHandle:fromOffset:byteCount:allocator:eventLoop:)`\n        because it doesn't use the file descriptor's seek pointer (which may be shared with other file\n        descriptors and even across processes.)\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to read.\n  - byteCount: The number of bytes to read from `fileHandle`.\n  - allocator: A `ByteBufferAllocator` used to allocate space for the returned `ByteBuffer`.\n  - eventLoop: The `EventLoop` to create the returned `EventLoopFuture` from.\n- returns: An `EventLoopFuture` which delivers a `ByteBuffer` if the read was successful or a failure on error."},{"p":["NonBlockingFileIO","read(fileRegion:allocator:eventLoop:)"],"f":[["func",12],[" ",17],["read",7],["(",17],["fileRegion",1],[": ",17],["FileRegion",18,109],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,130],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<",17],["ByteBuffer",18,108],[">",17]],"s":[["func",12],[" ",17],["read",7],["(",17],["fileRegion",1],[": ",17],["FileRegion",18],[", ",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["ByteBuffer",18],[">",17]],"d":"Read a `FileRegion` in `NonBlockingFileIO`'s private thread pool which is separate from any `EventLoop` thread.\n\nThe returned `ByteBuffer` will not have less than `fileRegion.readableBytes` unless we hit end-of-file in which\ncase the `ByteBuffer` will contain the bytes available to read.\n\nThis method will not use the file descriptor's seek pointer which means there is no danger of reading from the\nsame `FileRegion` in multiple threads.\n\n- note: Only use this function for small enough `FileRegion`s as it will need to allocate enough memory to hold `fileRegion.readableBytes` bytes.\n- note: In most cases you should prefer one of the `readChunked` functions.\n\n- parameters:\n  - fileRegion: The file region to read.\n  - allocator: A `ByteBufferAllocator` used to allocate space for the returned `ByteBuffer`.\n  - eventLoop: The `EventLoop` to create the returned `EventLoopFuture` from.\n- returns: An `EventLoopFuture` which delivers a `ByteBuffer` if the read was successful or a failure on error."},{"p":["NonBlockingFileIO","write(fileHandle:buffer:eventLoop:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["buffer",1],[": ",17],["ByteBuffer",18,108],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<()>",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["buffer",1],[": ",17],["ByteBuffer",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<()>",17]],"d":"Write `buffer` to `fileHandle` in `NonBlockingFileIO`'s private thread pool which is separate from any `EventLoop` thread.\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to write to.\n  - buffer: The `ByteBuffer` to write.\n  - eventLoop: The `EventLoop` to create the returned `EventLoopFuture` from.\n- returns: An `EventLoopFuture` which is fulfilled if the write was successful or fails on error."},{"p":["NonBlockingFileIO","write(fileHandle:toOffset:buffer:eventLoop:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,114],[", ",17],["toOffset",1],[": ",17],["Int64",18,154],[", ",17],["buffer",1],[": ",17],["ByteBuffer",18,108],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18,140],[") -> ",17],["EventLoopFuture",18,128],["<()>",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["toOffset",1],[": ",17],["Int64",18],[", ",17],["buffer",1],[": ",17],["ByteBuffer",18],[", ",17],["eventLoop",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<()>",17]],"d":"Write `buffer` starting from `toOffset` to `fileHandle` in `NonBlockingFileIO`'s private thread pool which is separate from any `EventLoop` thread.\n\n- parameters:\n  - fileHandle: The `NIOFileHandle` to write to.\n  - toOffset: The file offset to write to.\n  - buffer: The `ByteBuffer` to write.\n  - eventLoop: The `EventLoop` to create the returned `EventLoopFuture` from.\n- returns: An `EventLoopFuture` which is fulfilled if the write was successful or fails on error."},{"p":["MultiThreadedEventLoopGroup","makeIterator()"],"f":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["EventLoopIterator",18,129]],"s":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["EventLoopIterator",18]],"d":"Returns an `EventLoopIterator` over the `EventLoop`s in this `MultiThreadedEventLoopGroup`.\n\n- returns: `EventLoopIterator`","o":120},{"p":["MultiThreadedEventLoopGroup","shutdownGracefully(queue:_:)"],"f":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18,141],[", ",17],["_",1],[" ",17],["handler",2],[": ",17],["@escaping",12],[" (",17],["Error",18,153],["?) -> ",17],["Void",18,152],[")",17]],"s":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18],[", (",17],["Error",18],["?) -> ",17],["Void",18],[")",17]],"d":"Shut this `MultiThreadedEventLoopGroup` down which causes the `EventLoop`s and their associated threads to be\nshut down and release their resources.\n\nEven though calling `shutdownGracefully` more than once should be avoided, it is safe to do so and execution\nof the `handler` is guaranteed.\n\n- parameters:\n   - queue: The `DispatchQueue` to run `handler` on when the shutdown operation completes.\n   - handler: The handler which is called after the shutdown operation completes. The parameter will be `nil`\n              on success and contain the `Error` otherwise.","o":121},{"p":["MultiThreadedEventLoopGroup","any()"],"f":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18,140]],"s":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18]],"d":"Returns the current `EventLoop` if we are on an `EventLoop` of this `MultiThreadedEventLoopGroup` instance.\n\n- returns: The `EventLoop`.","o":122},{"p":["MultiThreadedEventLoopGroup","next()"],"f":[["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18,140]],"s":[["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18]],"d":"Returns the next `EventLoop` from this `MultiThreadedEventLoopGroup`.\n\n`MultiThreadedEventLoopGroup` uses _round robin_ across all its `EventLoop`s to select the next one.\n\n- returns: The next `EventLoop` to use.","o":123},{"p":["Resolver","cancelQueries()"],"f":[["func",12],[" ",17],["cancelQueries",7],["()",17]],"s":[["func",12],[" ",17],["cancelQueries",7],["()",17]],"d":"Cancel all outstanding DNS queries.\n\nThis method is called whenever queries that have not completed no longer have their\nresults needed. The resolver should, if possible, abort any outstanding queries and\nclean up their state.\n\nThis method is not guaranteed to terminate the outstanding queries."},{"p":["Resolver","initiateAQuery(host:port:)"],"f":[["func",12],[" ",17],["initiateAQuery",7],["(",17],["host",1],[": ",17],["String",18,145],[", ",17],["port",1],[": ",17],["Int",18,147],[") -> ",17],["EventLoopFuture",18,128],["<[",17],["SocketAddress",18,117],["]>",17]],"s":[["func",12],[" ",17],["initiateAQuery",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") -> ",17],["EventLoopFuture",18],["<[",17],["SocketAddress",18],["]>",17]],"d":"Initiate a DNS A query for a given host.\n\n- parameters:\n    - host: The hostname to do an A lookup on.\n    - port: The port we'll be connecting to.\n- returns: An `EventLoopFuture` that fires with the result of the lookup."},{"p":["Resolver","initiateAAAAQuery(host:port:)"],"f":[["func",12],[" ",17],["initiateAAAAQuery",7],["(",17],["host",1],[": ",17],["String",18,145],[", ",17],["port",1],[": ",17],["Int",18,147],[") -> ",17],["EventLoopFuture",18,128],["<[",17],["SocketAddress",18,117],["]>",17]],"s":[["func",12],[" ",17],["initiateAAAAQuery",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") -> ",17],["EventLoopFuture",18],["<[",17],["SocketAddress",18],["]>",17]],"d":"Initiate a DNS AAAA query for a given host.\n\n- parameters:\n    - host: The hostname to do an AAAA lookup on.\n    - port: The port we'll be connecting to.\n- returns: An `EventLoopFuture` that fires with the result of the lookup."},{"p":["NIOThreadPool","WorkItem"],"f":[["typealias",12],[" ",17],["WorkItem",7],[" = (",17],["NIOThreadPool",18,11],[".",17],["WorkItemState",18,1],[") -> ",17],["Void",18,152]],"s":[["typealias",12],[" ",17],["WorkItem",7]],"d":"The work that should be done by the `NIOThreadPool`."}],"edges":{"conformer":[1,142,[],1,143,[],2,142,[],2,143,[],2,153,[],2,155,[],5,153,[],5,155,[],6,153,[],6,155,[],7,153,[],7,155,[],9,153,[],9,155,[],10,153,[],10,155,[],12,131,[],17,119,[],17,148,[]],"feature":[124,17,125,17,126,17,127,17,144,1,144,2,150,17],"member":[1,11,2,4,6,3,18,1,19,1,20,2,21,11,22,12,23,12,24,13,25,13,26,13,27,14,28,14,29,15,30,15,31,4,32,16,33,16,34,17,35,4,36,4,37,17,38,5,39,5,40,5,41,5,42,5,43,16,44,8,45,8,46,17,47,17,48,11,49,11,50,11,51,11,52,11,53,11,54,12,55,12,56,12,57,12,58,12,59,12,60,12,61,12,62,12,63,12,64,12,65,13,66,13,67,13,68,13,69,13,70,13,71,13,72,13,73,13,74,13,75,13,76,14,77,14,78,14,79,14,80,15,81,15,82,15,83,15,84,15,85,15,86,15,87,15,88,4,89,4,90,4,91,4,92,4,93,4,94,4,95,4,96,4,97,4,98,4,99,4,100,17,101,17,102,17,103,17,107,11],"requirement":[104,0,105,0,106,0]},"sourcemap":[{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/BSDSocketAPICommon.swift","symbols":[323,14,9]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/Bootstrap.swift","symbols":[65,19,13,85,23,26,103,23,25,119,11,24,143,16,71,162,16,70,175,16,69,186,16,68,195,16,65,204,16,75,214,16,74,222,16,73,233,16,72,251,20,66,260,16,67,438,19,12,468,23,23,480,11,22,510,16,57,521,16,56,533,16,54,542,16,55,551,16,64,564,16,60,580,16,63,623,16,62,635,16,61,651,20,58,661,16,59,768,19,15,784,23,30,796,11,29,810,16,83,821,16,80,832,20,81,841,16,82,857,16,87,867,16,86,875,16,85,886,16,84,963,19,14,978,23,28,990,11,27,1008,16,77,1019,16,76,1049,16,78,1075,16,79]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/HappyEyeballs.swift","symbols":[40,14,8,42,15,45,45,15,44,50,14,5,52,15,40,55,15,41,58,32,42,61,32,38,64,32,39]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/MultiThreadedEventLoopGroup.swift","symbols":[53,19,17,133,23,34,168,22,37,179,16,100,188,16,103,195,16,102,218,16,101,310,23,47,334,15,46]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/NIOThreadPool.swift","symbols":[19,12,3,22,18,6,41,19,11,44,16,1,46,13,18,48,13,19,52,21,107,73,16,49,110,16,53,130,11,21,162,16,52,224,16,48,242,16,50,246,16,51]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/NonBlockingFileIO.swift","symbols":[30,14,4,32,22,36,35,22,35,38,16,2,42,13,20,51,11,31,75,16,94,114,16,93,152,16,92,238,16,97,265,16,96,295,16,95,362,16,91,378,16,90,397,16,98,411,16,99,471,16,89,495,16,88]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/Resolver.swift","symbols":[24,16,0,31,9,105,39,9,106,48,9,104]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/System.swift","symbols":[609,14,7,617,14,10]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.39.0/.build/checkouts/swift-nio/Sources/NIOPosix/Thread.swift","symbols":[144,19,16,171,11,33,182,23,32,188,15,43]}]}