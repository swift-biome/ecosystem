{"culture":"NIOTLS","dependencies":[{"package":"swift-atomics","modules":["Atomics"]},{"package":"swift-nio","modules":["NIO","NIOConcurrencyHelpers","NIOCore","NIOEmbedded","NIOPosix","_NIODataStructures"]}],"extensions":[],"partitions":[{"namespace":"NIOTLS","communities":[{"community":"enum","startIndex":0,"endIndex":3},{"community":"class","startIndex":3,"endIndex":5},{"community":"enum.case","startIndex":5,"endIndex":11},{"community":"init","startIndex":11,"endIndex":14},{"community":"property","startIndex":14,"endIndex":15},{"community":"method","startIndex":15,"endIndex":19},{"community":"typealias","startIndex":19,"endIndex":23}]}],"identifiers":["s6NIOTLS10ALPNResultO","s6NIOTLS12TLSUserEventO","s6NIOTLS9SNIResultO","s6NIOTLS10SNIHandlerC","s6NIOTLS37ApplicationProtocolNegotiationHandlerC","s6NIOTLS10ALPNResultO10negotiatedyACSScACmF","s6NIOTLS10ALPNResultO8fallbackyA2CmF","s6NIOTLS12TLSUserEventO17shutdownCompletedyA2CmF","s6NIOTLS12TLSUserEventO18handshakeCompletedyACSSSg_tcACmF","s6NIOTLS9SNIResultO8fallbackyA2CmF","s6NIOTLS9SNIResultO8hostnameyACSScACmF","s6NIOTLS10SNIHandlerC18sniCompleteHandlerAC7NIOCore15EventLoopFutureCyytGAA9SNIResultOc_tcfc","s6NIOTLS37ApplicationProtocolNegotiationHandlerC012alpnCompleteE0AC7NIOCore15EventLoopFutureCyytGAA10ALPNResultO_AE7Channel_ptc_tcfc","s6NIOTLS37ApplicationProtocolNegotiationHandlerC012alpnCompleteE0AC7NIOCore15EventLoopFutureCyytGAA10ALPNResultOc_tcfc","s6NIOTLS10SNIHandlerC16cumulationBuffer7NIOCore04ByteD0VSgvp","s6NIOTLS10SNIHandlerC10decodeLast7context6buffer7seenEOF7NIOCore13DecodingStateOAH21ChannelHandlerContextC_AH10ByteBufferVzSbtKF","s6NIOTLS10SNIHandlerC6decode7context6buffer7NIOCore13DecodingStateOAG21ChannelHandlerContextC_AG10ByteBufferVztF","s6NIOTLS37ApplicationProtocolNegotiationHandlerC11channelRead7context4datay7NIOCore07ChannelE7ContextC_AG6NIOAnyVtF","s6NIOTLS37ApplicationProtocolNegotiationHandlerC25userInboundEventTriggered7context5eventy7NIOCore07ChannelE7ContextC_yptF","s6NIOTLS10SNIHandlerC10InboundOuta","s6NIOTLS10SNIHandlerC9InboundIna","s6NIOTLS37ApplicationProtocolNegotiationHandlerC10InboundOuta","s6NIOTLS37ApplicationProtocolNegotiationHandlerC9InboundIna","s7NIOCore10ByteBufferV","s7NIOCore13DecodingStateO","s7NIOCore14ChannelHandlerP","s7NIOCore14ChannelHandlerPAAE12handlerAdded7contextyAA0bC7ContextC_tF","s7NIOCore14ChannelHandlerPAAE14handlerRemoved7contextyAA0bC7ContextC_tF","s7NIOCore15EventLoopFutureC","s7NIOCore20ByteToMessageDecoderP","s7NIOCore20ByteToMessageDecoderP10InboundOutQa","s7NIOCore20ByteToMessageDecoderP10decodeLast7context6buffer7seenEOFAA13DecodingStateOAA21ChannelHandlerContextC_AA0B6BufferVzSbtKF","s7NIOCore20ByteToMessageDecoderP12decoderAdded7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderP14decoderRemoved7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderP6decode7context6bufferAA13DecodingStateOAA21ChannelHandlerContextC_AA0B6BufferVztKF","s7NIOCore20ByteToMessageDecoderPAAE12decoderAdded7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderPAAE14decoderRemoved7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderPAAE14wrapInboundOutyAA6NIOAnyV0gH0QzF","s7NIOCore20ByteToMessageDecoderPAAE18shouldReclaimBytes6bufferSbAA0B6BufferV_tF","s7NIOCore21ChannelHandlerContextC","s7NIOCore21ChannelInboundHandlerP","s7NIOCore21ChannelInboundHandlerP04wrapC3OutyAA6NIOAnyV0cF0QzF","s7NIOCore21ChannelInboundHandlerP06unwrapC2Iny0cF0QzAA6NIOAnyVF","s7NIOCore21ChannelInboundHandlerP0C2InQa","s7NIOCore21ChannelInboundHandlerP0C3OutQa","s7NIOCore21ChannelInboundHandlerPAAE04wrapC3OutyAA6NIOAnyV0cF0QzF","s7NIOCore21ChannelInboundHandlerPAAE06unwrapC2Iny0cF0QzAA6NIOAnyVF","s7NIOCore22_ChannelInboundHandlerP04userC14EventTriggered7context5eventyAA0bD7ContextC_yptF","s7NIOCore22_ChannelInboundHandlerP11channelRead7context4datayAA0bD7ContextC_AA6NIOAnyVtF","s7NIOCore23RemovableChannelHandlerP","s7NIOCore23RemovableChannelHandlerP06removeD07context12removalTokenyAA0cD7ContextC_AH07RemovalH0VtF","s7NIOCore23RemovableChannelHandlerPAAE06removeD07context12removalTokenyAA0cD7ContextC_AH07RemovalH0VtF","s7NIOCore6NIOAnyV","s7NIOCore7ChannelP","sSQ","sSQsE2neoiySbx_xtFZ","sSS","sSb","sSq","ss4Voida","ss8SendableP"],"vertices":[{"p":["ALPNResult"],"f":[["enum",12],[" ",17],["ALPNResult",7]],"s":[["enum",12],[" ",17],["ALPNResult",7]],"d":"The result of an ALPN negotiation.\n\nIn a system expecting an ALPN negotiation to occur, a wide range of\npossible things can happen. In the best case scenario it is possible for\nthe server and client to agree on a protocol to speak, in which case this\nwill be `.negotiated` with the relevant protocol provided as the associated\nvalue. However, if for any reason it was not possible to negotiate a\nprotocol, whether because one peer didn't support ALPN or because there was no\nprotocol overlap, we should `fallback` to a default choice of some kind.\n\nExactly what to do when falling back is the responsibility of a specific\nimplementation."},{"p":["TLSUserEvent"],"f":[["enum",12],[" ",17],["TLSUserEvent",7]],"s":[["enum",12],[" ",17],["TLSUserEvent",7]],"d":"Common user events sent by all TLS implementations."},{"p":["SNIResult"],"f":[["enum",12],[" ",17],["SNIResult",7]],"s":[["enum",12],[" ",17],["SNIResult",7]],"d":"The result of the SNI parsing. If `hostname`, then the enum also\ncontains the hostname received in the SNI extension. If `fallback`,\nthen either we could not parse the SNI extension or it was not there\nat all."},{"p":["SNIHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["SNIHandler",7]],"s":[["class",12],[" ",17],["SNIHandler",7]],"d":"A channel handler that can be used to arbitrarily edit a channel\npipeline based on the hostname requested in the Server Name Indication\nportion of the TLS Client Hello.\n\nThis handler is most commonly used when configuring TLS, to control\nwhich certificates are going to be shown to the client. It can also be used\nto ensure that only the resources required to serve a given virtual host are\nactually present in the channel pipeline.\n\nThis handler does not depend on any specific TLS implementation. Instead, it parses\nthe Client Hello itself, directly. This allows it to be generic across all possible\nTLS backends that can be used with NIO. It also allows for the pipeline change to\nbe done asynchronously, providing more flexibility about how the user configures the\npipeline."},{"p":["ApplicationProtocolNegotiationHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["ApplicationProtocolNegotiationHandler",7]],"s":[["class",12],[" ",17],["ApplicationProtocolNegotiationHandler",7]],"d":"A helper `ChannelInboundHandler` that makes it easy to swap channel pipelines\nbased on the result of an ALPN negotiation.\n\nThe standard pattern used by applications that want to use ALPN is to select\nan application protocol based on the result, optionally falling back to some\ndefault protocol. To do this in SwiftNIO requires that the channel pipeline be\nreconfigured based on the result of the ALPN negotiation. This channel handler\nencapsulates that logic in a generic form that doesn't depend on the specific\nTLS implementation in use by using `TLSUserEvent`\n\nThe user of this channel handler provides a single closure that is called with\nan `ALPNResult` when the ALPN negotiation is complete. Based on that result\nthe user is free to reconfigure the `ChannelPipeline` as required, and should\nreturn an `EventLoopFuture` that will complete when the pipeline is reconfigured.\n\nUntil the `EventLoopFuture` completes, this channel handler will buffer inbound\ndata. When the `EventLoopFuture` completes, the buffered data will be replayed\ndown the channel. Then, finally, this channel handler will automatically remove\nitself from the channel pipeline, leaving the pipeline in its final\nconfiguration."},{"p":["ALPNResult","negotiated(_:)"],"f":[["case",12],[" ",17],["negotiated",7],["(",17],["String",18,56],[")",17]],"s":[["case",12],[" ",17],["negotiated",7],["(",17],["String",18],[")",17]],"d":"ALPN negotiation succeeded. The associated value is the ALPN token that\nwas negotiated."},{"p":["ALPNResult","fallback"],"f":[["case",12],[" ",17],["fallback",7]],"s":[["case",12],[" ",17],["fallback",7]],"d":"ALPN negotiation either failed, or never took place. The application\nshould fall back to a default protocol choice or close the connection."},{"p":["TLSUserEvent","shutdownCompleted"],"f":[["case",12],[" ",17],["shutdownCompleted",7]],"s":[["case",12],[" ",17],["shutdownCompleted",7]],"d":"The TLS connection has been successfully and cleanly shut down.\nNo further application data can be sent or received at this time."},{"p":["TLSUserEvent","handshakeCompleted(negotiatedProtocol:)"],"f":[["case",12],[" ",17],["handshakeCompleted",7],["(",17],["negotiatedProtocol",1],[": ",17],["String",18,56],["?)",17]],"s":[["case",12],[" ",17],["handshakeCompleted",7],["(",17],["negotiatedProtocol",1],[": ",17],["String",18],["?)",17]],"d":"The TLS handshake has completed. If ALPN or NPN were used,\nthe negotiated protocol is provided as `negotiatedProtocol`."},{"p":["SNIResult","fallback"],"f":[["case",12],[" ",17],["fallback",7]],"s":[["case",12],[" ",17],["fallback",7]]},{"p":["SNIResult","hostname(_:)"],"f":[["case",12],[" ",17],["hostname",7],["(",17],["String",18,56],[")",17]],"s":[["case",12],[" ",17],["hostname",7],["(",17],["String",18],[")",17]]},{"p":["SNIHandler","init(sniCompleteHandler:)"],"f":[["@preconcurrency",3],[" ",17],["init",10],["(",17],["sniCompleteHandler",1],[": ",17],["@escaping",12],[" (",17],["SNIResult",18,2],[") -> ",17],["EventLoopFuture",18,28],["<",17],["Void",18,59],[">)",17]],"s":[["init",10],["(",17],["sniCompleteHandler",1],[": (",17],["SNIResult",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">)",17]]},{"p":["ApplicationProtocolNegotiationHandler","init(alpnCompleteHandler:)"],"f":[["@preconcurrency",3],[" ",17],["init",10],["(",17],["alpnCompleteHandler",1],[": ",17],["@escaping",12],[" (",17],["ALPNResult",18,0],[", ",17],["Channel",18,53],[") -> ",17],["EventLoopFuture",18,28],["<",17],["Void",18,59],[">)",17]],"s":[["init",10],["(",17],["alpnCompleteHandler",1],[": (",17],["ALPNResult",18],[", ",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">)",17]],"d":"Create an `ApplicationProtocolNegotiationHandler` with the given completion\ncallback.\n\n- Parameter alpnCompleteHandler: The closure that will fire when ALPN\n  negotiation has completed."},{"p":["ApplicationProtocolNegotiationHandler","init(alpnCompleteHandler:)"],"f":[["@preconcurrency",3],[" ",17],["convenience",12],[" ",17],["init",10],["(",17],["alpnCompleteHandler",1],[": ",17],["@escaping",12],[" (",17],["ALPNResult",18,0],[") -> ",17],["EventLoopFuture",18,28],["<",17],["Void",18,59],[">)",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["alpnCompleteHandler",1],[": (",17],["ALPNResult",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">)",17]],"d":"Create an `ApplicationProtocolNegotiationHandler` with the given completion\ncallback.\n\n- Parameter alpnCompleteHandler: The closure that will fire when ALPN\n  negotiation has completed."},{"p":["SNIHandler","cumulationBuffer"],"f":[["var",12],[" ",17],["cumulationBuffer",7],[": ",17],["Optional",18,58],["<",17],["ByteBuffer",18,23],[">",17]],"s":[["var",12],[" ",17],["cumulationBuffer",7],[": ",17],["Optional",18],["<",17],["ByteBuffer",18],[">",17]]},{"p":["SNIHandler","decodeLast(context:buffer:seenEOF:)"],"f":[["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,39],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,23],[", ",17],["seenEOF",1],[": ",17],["Bool",18,57],[") ",17],["throws",12],[" -> ",17],["DecodingState",18,24]],"s":[["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[", ",17],["seenEOF",1],[": ",17],["Bool",18],[") ",17],["throws",12],[" -> ",17],["DecodingState",18]],"o":31},{"p":["SNIHandler","decode(context:buffer:)"],"f":[["func",12],[" ",17],["decode",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,39],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,23],[") -> ",17],["DecodingState",18,24]],"s":[["func",12],[" ",17],["decode",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[") -> ",17],["DecodingState",18]],"o":34},{"p":["ApplicationProtocolNegotiationHandler","channelRead(context:data:)"],"f":[["func",12],[" ",17],["channelRead",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,39],[", ",17],["data",1],[": ",17],["NIOAny",18,52],[")",17]],"s":[["func",12],[" ",17],["channelRead",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["data",1],[": ",17],["NIOAny",18],[")",17]],"o":48},{"p":["ApplicationProtocolNegotiationHandler","userInboundEventTriggered(context:event:)"],"f":[["func",12],[" ",17],["userInboundEventTriggered",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,39],[", ",17],["event",1],[": ",17],["Any",12],[")",17]],"s":[["func",12],[" ",17],["userInboundEventTriggered",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["event",1],[": ",17],["Any",12],[")",17]],"o":47},{"p":["SNIHandler","InboundOut"],"f":[["typealias",12],[" ",17],["InboundOut",7],[" = ",17],["ByteBuffer",18,23]],"s":[["typealias",12],[" ",17],["InboundOut",7]],"o":30},{"p":["SNIHandler","InboundIn"],"f":[["typealias",12],[" ",17],["InboundIn",7],[" = ",17],["ByteBuffer",18,23]],"s":[["typealias",12],[" ",17],["InboundIn",7]]},{"p":["ApplicationProtocolNegotiationHandler","InboundOut"],"f":[["typealias",12],[" ",17],["InboundOut",7],[" = ",17],["Any",12]],"s":[["typealias",12],[" ",17],["InboundOut",7]],"o":44},{"p":["ApplicationProtocolNegotiationHandler","InboundIn"],"f":[["typealias",12],[" ",17],["InboundIn",7],[" = ",17],["Any",12]],"s":[["typealias",12],[" ",17],["InboundIn",7]],"o":43}],"edges":{"conformer":[0,54,[],0,60,[],1,54,[],1,60,[],2,54,[],2,60,[],3,29,[],3,60,[],4,25,[],4,40,[],4,49,[],4,60,[]],"feature":[26,4,27,4,35,3,36,3,37,3,38,3,45,4,46,4,51,4,55,0,55,1,55,2],"member":[5,0,6,0,7,1,8,1,9,2,10,2,11,3,12,4,13,4,14,3,15,3,16,3,17,4,18,4,19,3,20,3,21,4,22,4]},"sourcemap":[{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.41.1/.build/checkouts/swift-nio/Sources/NIOTLS/ApplicationProtocolNegotiationHandler.swift","symbols":[28,12,0,31,9,5,35,9,6,58,19,4,59,21,22,60,21,21,76,27,12,100,39,13,118,16,18,131,16,17]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.41.1/.build/checkouts/swift-nio/Sources/NIOTLS/SNIHandler.swift","symbols":[35,12,2,36,9,9,37,9,10,96,19,3,97,15,14,98,21,20,99,21,19,108,27,11,121,16,15,127,16,16]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.41.1/.build/checkouts/swift-nio/Sources/NIOTLS/TLSEvents.swift","symbols":[17,12,1,20,9,8,24,9,7]}]}