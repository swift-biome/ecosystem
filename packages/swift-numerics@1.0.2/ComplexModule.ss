{"culture":"ComplexModule","dependencies":[{"package":"swift-numerics","modules":["RealModule"]}],"extensions":[],"partitions":[{"namespace":"ComplexModule","communities":[{"community":"struct","startIndex":0,"endIndex":1},{"community":"init","startIndex":1,"endIndex":11},{"community":"type.property","startIndex":11,"endIndex":15},{"community":"property","startIndex":15,"endIndex":33},{"community":"type.method","startIndex":33,"endIndex":53},{"community":"method","startIndex":53,"endIndex":55},{"community":"type.op","startIndex":55,"endIndex":64},{"community":"typealias","startIndex":64,"endIndex":66}]}],"identifiers":["s13ComplexModule0A0V","s13ComplexModule0A0V14integerLiteralACyxGSi_tcfc","s13ComplexModule0A0V6length5phaseACyxGx_xtcfc","s13ComplexModule0A0V7exactlyACyxGSgqd___tcSzRd__lufc","s13ComplexModule0A0V9imaginaryACyxGx_tcfc","s13ComplexModule0A0VAASBRzrlE7exactlyACyxGSgACyqd__G_tc04RealB00D0Rd__SBRd__lufc","s13ComplexModule0A0VAASBRzrlEyACyxGACyqd__Gc04RealB00C0Rd__SBRd__lufc","s13ComplexModule0A0VAASeRzrlE4fromACyxGs7Decoder_p_tKcfc","s13ComplexModule0A0VyACyxGqd__cSzRd__lufc","s13ComplexModule0A0VyACyxGx_xtcfc","s13ComplexModule0A0VyACyxGxcfc","s13ComplexModule0A0V1iACyxGvpZ","s13ComplexModule0A0V3oneACyxGvpZ","s13ComplexModule0A0V4zeroACyxGvpZ","s13ComplexModule0A0V8infinityACyxGvpZ","s13ComplexModule0A0V10normalizedACyxGSgvp","s13ComplexModule0A0V10reciprocalACyxGSgvp","s13ComplexModule0A0V11descriptionSSvp","s13ComplexModule0A0V11isSubnormalSbvp","s13ComplexModule0A0V13canonicalizedACyxGvp","s13ComplexModule0A0V13lengthSquaredxvp","s13ComplexModule0A0V16debugDescriptionSSvp","s13ComplexModule0A0V4realxvp","s13ComplexModule0A0V5phasexvp","s13ComplexModule0A0V5polarx6length_x5phasetvp","s13ComplexModule0A0V6isZeroSbvp","s13ComplexModule0A0V6lengthxvp","s13ComplexModule0A0V8isFiniteSbvp","s13ComplexModule0A0V8isNormalSbvp","s13ComplexModule0A0V9conjugateACyxGvp","s13ComplexModule0A0V9imaginaryxvp","s13ComplexModule0A0V9magnitudexvp","s13ComplexModule0A0VAA16_Differentiation14DifferentiableRz13TangentVectorAdEPQzRszrlE04zeroeF11InitializerACyxGycvp","s13ComplexModule0A0V11expMinusOneyACyxGAEFZ","s13ComplexModule0A0V3cosyACyxGAEFZ","s13ComplexModule0A0V3expyACyxGAEFZ","s13ComplexModule0A0V3log7onePlusACyxGAF_tFZ","s13ComplexModule0A0V3logyACyxGAEFZ","s13ComplexModule0A0V3powyACyxGAE_AEtFZ","s13ComplexModule0A0V3powyACyxGAE_SitFZ","s13ComplexModule0A0V3sinyACyxGAEFZ","s13ComplexModule0A0V3tanyACyxGAEFZ","s13ComplexModule0A0V4acosyACyxGAEFZ","s13ComplexModule0A0V4asinyACyxGAEFZ","s13ComplexModule0A0V4atanyACyxGAEFZ","s13ComplexModule0A0V4coshyACyxGAEFZ","s13ComplexModule0A0V4rootyACyxGAE_SitFZ","s13ComplexModule0A0V4sinhyACyxGAEFZ","s13ComplexModule0A0V4sqrtyACyxGAEFZ","s13ComplexModule0A0V4tanhyACyxGAEFZ","s13ComplexModule0A0V5acoshyACyxGAEFZ","s13ComplexModule0A0V5asinhyACyxGAEFZ","s13ComplexModule0A0V5atanhyACyxGAEFZ","s13ComplexModule0A0V4hash4intoys6HasherVz_tF","s13ComplexModule0A0VAASERzrlE6encode2toys7Encoder_p_tKF","s13ComplexModule0A0V1doiyACyxGAE_AEtFZ","s13ComplexModule0A0V1moiyACyxGAE_AEtFZ","s13ComplexModule0A0V1poiyACyxGAE_AEtFZ","s13ComplexModule0A0V1soiyACyxGAE_AEtFZ","s13ComplexModule0A0V2deoiyyACyxGz_AEtFZ","s13ComplexModule0A0V2eeoiySbACyxG_AEtFZ","s13ComplexModule0A0V2meoiyyACyxGz_AEtFZ","s13ComplexModule0A0V2peoiyyACyxGz_AEtFZ","s13ComplexModule0A0V2seoiyyACyxGz_AEtFZ","s13ComplexModule0A0V18IntegerLiteralTypea","s13ComplexModule0A0VAA16_Differentiation14DifferentiableRz13TangentVectorAdEPQzRszrlEAFa","s10RealModule0A0P","s10RealModule14AlgebraicFieldP","s10RealModule14AlgebraicFieldP10reciprocalxSgvp","s10RealModule14AlgebraicFieldP1doiyxx_xtFZ","s10RealModule14AlgebraicFieldP2deoiyyxz_xtFZ","s10RealModule14AlgebraicFieldPAAE10reciprocalxSgvp","s10RealModule14AlgebraicFieldPAAE1doiyxx_xtFZ","s10RealModule19ElementaryFunctionsP","s10RealModule19ElementaryFunctionsP11expMinusOneyxxFZ","s10RealModule19ElementaryFunctionsP3cosyxxFZ","s10RealModule19ElementaryFunctionsP3expyxxFZ","s10RealModule19ElementaryFunctionsP3log7onePlusxx_tFZ","s10RealModule19ElementaryFunctionsP3logyxxFZ","s10RealModule19ElementaryFunctionsP3powyxx_SitFZ","s10RealModule19ElementaryFunctionsP3powyxx_xtFZ","s10RealModule19ElementaryFunctionsP3sinyxxFZ","s10RealModule19ElementaryFunctionsP3tanyxxFZ","s10RealModule19ElementaryFunctionsP4acosyxxFZ","s10RealModule19ElementaryFunctionsP4asinyxxFZ","s10RealModule19ElementaryFunctionsP4atanyxxFZ","s10RealModule19ElementaryFunctionsP4coshyxxFZ","s10RealModule19ElementaryFunctionsP4rootyxx_SitFZ","s10RealModule19ElementaryFunctionsP4sinhyxxFZ","s10RealModule19ElementaryFunctionsP4sqrtyxxFZ","s10RealModule19ElementaryFunctionsP4tanhyxxFZ","s10RealModule19ElementaryFunctionsP5acoshyxxFZ","s10RealModule19ElementaryFunctionsP5asinhyxxFZ","s10RealModule19ElementaryFunctionsP5atanhyxxFZ","s16_Differentiation14DifferentiableP","s16_Differentiation14DifferentiableP13TangentVectorQa","sSB","sSE","sSE6encode2toys7Encoder_p_tKF","sSH","sSH4hash4intoys6HasherVz_tF","sSQ","sSQ2eeoiySbx_xtFZ","sSQsE2neoiySbx_xtFZ","sSS","sSb","sSe","sSe4fromxs7Decoder_p_tKcfc","sSi","sSj","sSj10RealModuleSF9MagnitudeRpzrlE20isApproximatelyEqual2to17absoluteTolerance08relativeI0Sbx_A2CtF","sSj10RealModuleSF9MagnitudeRpzrlE20isApproximatelyEqual2to17relativeTolerance4normSbx_A2CxXEtF","sSj1moiyxx_xtFZ","sSj2meoiyyxz_xtFZ","sSj7exactlyxSgqd___tcSzRd__lufc","sSj9magnitude9MagnitudeQzvp","sSz","ss13SignedNumericP","ss13SignedNumericPsE1sopyxxFZ","ss13SignedNumericPsE6negateyyF","ss18AdditiveArithmeticP","ss18AdditiveArithmeticP10RealModuleE20isApproximatelyEqual2to17absoluteTolerance08relativeJ04normSbx_qd__qd__qd__xXEtSFRd__lF","ss18AdditiveArithmeticP1poiyxx_xtFZ","ss18AdditiveArithmeticP1soiyxx_xtFZ","ss18AdditiveArithmeticP2peoiyyxz_xtFZ","ss18AdditiveArithmeticP2seoiyyxz_xtFZ","ss18AdditiveArithmeticP4zeroxvpZ","ss18AdditiveArithmeticPsE1popyxxFZ","ss18AdditiveArithmeticPsE2peoiyyxz_xtFZ","ss18AdditiveArithmeticPsE2seoiyyxz_xtFZ","ss18AdditiveArithmeticPss27ExpressibleByIntegerLiteralRzrlE4zeroxvpZ","ss23CustomStringConvertibleP","ss23CustomStringConvertibleP11descriptionSSvp","ss23CustomStringConvertibleP12_RegexParserE21halfWidthCornerQuotedSSvp","ss27ExpressibleByIntegerLiteralP","ss27ExpressibleByIntegerLiteralP07integerD0x0cD4TypeQz_tcfc","ss27ExpressibleByIntegerLiteralP0cD4TypeQa","ss28CustomDebugStringConvertibleP","ss28CustomDebugStringConvertibleP16debugDescriptionSSvp","ss6HasherV","ss7DecoderP","ss7EncoderP"],"vertices":[{"p":["Complex"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["Complex",7],["<",17],["RealType",0],["> ",17],["where",12],[" ",17],["RealType",18],[" : ",17],["Real",18,66]],"s":[["struct",12],[" ",17],["Complex",7]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"d":"A complex number represented by real and imaginary parts.\n\nTODO: introductory text on complex numbers\n\nImplementation notes:\n-\nThis type does not provide heterogeneous real/complex arithmetic,\nnot even the natural vector-space operations like real * complex.\nThere are two reasons for this choice: first, Swift broadly avoids\nmixed-type arithmetic when the operation can be adequately expressed\nby a conversion and homogeneous arithmetic. Second, with the current\ntypechecker rules, it would lead to undesirable ambiguity in common\nexpressions (see README.md for more details).\n\nUnlike C's `_Complex` and C++'s `std::complex<>` types, we do not\nattempt to make meaningful semantic distinctions between different\nrepresentations of infinity or NaN. Any Complex value with at least\none non-finite component is simply \"non-finite\". In as much as\npossible, we use the semantics of the point at infinity on the\nRiemann sphere for such values. This approach simplifies the number of\nedge cases that need to be considered for multiplication, division, and\nthe elementary functions considerably.\n\n`.magnitude` does not return the Euclidean norm; it uses the \"infinity\nnorm\" (`max(|real|,|imaginary|)`) instead. There are two reasons for this\nchoice: first, it's simply faster to compute on most hardware. Second,\nthere exist values for which the Euclidean norm cannot be represented\n(consider a number with `.real` and `.imaginary` both equal to\n`RealType.greatestFiniteMagnitude`; the Euclidean norm would be\n`.sqrt(2) * .greatestFiniteMagnitude`, which overflows). Using\nthe infinity norm avoids this problem entirely without significant\ndownsides. You can access the Euclidean norm using the `length`\nproperty."},{"p":["Complex","init(integerLiteral:)"],"f":[["init",10],["(",17],["integerLiteral",1],[" ",17],["value",2],[": ",17],["Int",18,108],[")",17]],"s":[["init",10],["(",17],["integerLiteral",1],[": ",17],["Int",18],[")",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":135},{"p":["Complex","init(length:phase:)"],"f":[["init",10],["(",17],["length",1],[": ",17],["RealType",18],[", ",17],["phase",1],[": ",17],["RealType",18],[")",17]],"s":[["init",10],["(",17],["length",1],[": ",17],["RealType",18],[", ",17],["phase",1],[": ",17],["RealType",18],[")",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"d":"Creates a complex value specified with polar coordinates.\n\nEdge cases:\n-\n- Negative lengths are interpreted as reflecting the point through the\n  origin, i.e.:\n  ```\n  Complex(length: -r, phase: θ) == -Complex(length: r, phase: θ)\n  ```\n- For any `θ`, even `.infinity` or `.nan`:\n  ```\n  Complex(length: .zero, phase: θ) == .zero\n  ```\n- For any `θ`, even `.infinity` or `.nan`, if `r` is infinite then:\n  ```\n  Complex(length: r, phase: θ) == .infinity\n  ```\n- Otherwise, `θ` must be finite, or a precondition failure occurs.\n\nSee also:\n-\n- `.length`\n- `.phase`\n- `.polar`"},{"p":["Complex","init(exactly:)"],"f":[["init",10],["?<",17],["Other",0],[">(",17],["exactly",1],[" ",17],["real",2],[": ",17],["Other",18],[") ",17],["where",12],[" ",17],["Other",18],[" : ",17],["BinaryInteger",18,116]],"s":[["init",10],["?<",17],["Other",0],[">(",17],["exactly",1],[": ",17],["Other",18],[")",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66],["Other",1,"BinaryInteger",116]],"g":[["RealType",0,0],["Other",0,1]],"d":"The complex number with specified real part and zero imaginary part,\nif it can be constructed without rounding.","o":114},{"p":["Complex","init(imaginary:)"],"f":[["init",10],["(",17],["imaginary",1],[": ",17],["RealType",18],[")",17]],"s":[["init",10],["(",17],["imaginary",1],[": ",17],["RealType",18],[")",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"d":"The complex number with specified imaginary part and zero real part.\n\nEquivalent to `Complex(0, imaginary)`."},{"p":["Complex","init(exactly:)"],"f":[["init",10],["?<",17],["Other",0],[">(",17],["exactly",1],[" ",17],["other",2],[": ",17],["Complex",18,0],["<",17],["Other",18],[">) ",17],["where",12],[" ",17],["Other",18],[" : ",17],["Real",18,66],[", ",17],["Other",18],[" : ",17],["BinaryFloatingPoint",18,96]],"s":[["init",10],["?<",17],["Other",0],[">(",17],["exactly",1],[": ",17],["Complex",18],["<",17],["Other",18],[">)",17]],"e":[["RealType",1,"Real",66],["RealType",1,"BinaryFloatingPoint",96]],"c":[["RealType",1,"Real",66],["RealType",1,"BinaryFloatingPoint",96],["Other",1,"Real",66],["Other",1,"BinaryFloatingPoint",96]],"g":[["RealType",0,0],["Other",0,1]],"d":"`other`, if it can be represented exactly in this type; otherwise `nil`."},{"p":["Complex","init(_:)"],"f":[["init",10],["<",17],["Other",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["Complex",18,0],["<",17],["Other",18],[">) ",17],["where",12],[" ",17],["Other",18],[" : ",17],["Real",18,66],[", ",17],["Other",18],[" : ",17],["BinaryFloatingPoint",18,96]],"s":[["init",10],["<",17],["Other",0],[">(",17],["Complex",18],["<",17],["Other",18],[">)",17]],"e":[["RealType",1,"Real",66],["RealType",1,"BinaryFloatingPoint",96]],"c":[["RealType",1,"Real",66],["RealType",1,"BinaryFloatingPoint",96],["Other",1,"Real",66],["Other",1,"BinaryFloatingPoint",96]],"g":[["RealType",0,0],["Other",0,1]],"d":"`other` rounded to the nearest representable value of this type."},{"p":["Complex","init(from:)"],"f":[["init",10],["(",17],["from",1],[" ",17],["decoder",2],[": ",17],["Decoder",18,140],[") ",17],["throws",12]],"s":[["init",10],["(",17],["from",1],[": ",17],["Decoder",18],[") ",17],["throws",12]],"e":[["RealType",1,"Real",66],["RealType",1,"Decodable",106]],"c":[["RealType",1,"Real",66],["RealType",1,"Decodable",106]],"g":[["RealType",0,0]],"o":107},{"p":["Complex","init(_:)"],"f":[["init",10],["<",17],["Other",0],[">(",17],["_",1],[" ",17],["real",2],[": ",17],["Other",18],[") ",17],["where",12],[" ",17],["Other",18],[" : ",17],["BinaryInteger",18,116]],"s":[["init",10],["<",17],["Other",0],[">(",17],["Other",18],[")",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66],["Other",1,"BinaryInteger",116]],"g":[["RealType",0,0],["Other",0,1]],"d":"The complex number with specified real part and zero imaginary part.\n\nEquivalent to `Complex(RealType(real), 0)`."},{"p":["Complex","init(_:_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["real",2],[": ",17],["RealType",18],[", ",17],["_",1],[" ",17],["imaginary",2],[": ",17],["RealType",18],[")",17]],"s":[["init",10],["(",17],["RealType",18],[", ",17],["RealType",18],[")",17]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"d":"A complex number constructed by specifying the real and imaginary parts."},{"p":["Complex","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["real",2],[": ",17],["RealType",18],[")",17]],"s":[["init",10],["(",17],["RealType",18],[")",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"d":"The complex number with specified real part and zero imaginary part.\n\nEquivalent to `Complex(real, 0)`."},{"p":["Complex","i"],"f":[["static",12],[" ",17],["var",12],[" ",17],["i",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],["> { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["i",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"d":"The imaginary unit.\n\nSee also:\n-\n- .zero\n- .one\n- .infinity"},{"p":["Complex","one"],"f":[["static",12],[" ",17],["var",12],[" ",17],["one",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],["> { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["one",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"d":"The multiplicative identity, with real part one and imaginary part zero.\n\nSee also:\n-\n- .zero\n- .i\n- .infinity"},{"p":["Complex","zero"],"f":[["static",12],[" ",17],["var",12],[" ",17],["zero",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],["> { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["zero",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"d":"The additive identity, with real and imaginary parts both zero.\n\nSee also:\n-\n- .one\n- .i\n- .infinity","o":126},{"p":["Complex","infinity"],"f":[["static",12],[" ",17],["var",12],[" ",17],["infinity",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],["> { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["infinity",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"d":"The point at infinity.\n\nSee also:\n-\n- .zero\n- .one\n- .i"},{"p":["Complex","normalized"],"f":[["var",12],[" ",17],["normalized",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["normalized",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">?",17]],"e":[["RealType",1,"Real",66]],"d":"A normalized complex number with the same phase as this value.\n\nIf such a value cannot be produced (because the phase of zero and\ninfinity is undefined), `nil` is returned."},{"p":["Complex","reciprocal"],"f":[["var",12],[" ",17],["reciprocal",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["reciprocal",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">?",17]],"e":[["RealType",1,"Real",66]],"d":"The reciprocal of this value, if it can be computed without undue\noverflow or underflow.\n\nIf z.reciprocal is non-nil, you can safely replace division by z with\nmultiplication by this value. It is not advantageous to do this for an\nisolated division, but if you are dividing many values by a single\ndenominator, this may sometimes be a significant performance win.\n\nA typical use case looks something like this:\n```\nfunc divide<T: Real>(data: [Complex<T>], by divisor: Complex<T>) -> [Complex<T>] {\n  // If divisor is well-scaled, multiply by reciprocal.\n  if let recip = divisor.reciprocal {\n    return data.map { $0 * recip }\n  }\n  // Fallback on using division.\n  return data.map { $0 / divisor }\n}\n```\n\nError Bounds:\n\nUnlike real types, when working with complex types, multiplying by the\nreciprocal instead of dividing cannot change the result. If the\nreciprocal is non-nil, the two computations are always equivalent.","o":68},{"p":["Complex","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,104],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"e":[["RealType",1,"Real",66]],"o":132},{"p":["Complex","isSubnormal"],"f":[["var",12],[" ",17],["isSubnormal",7],[": ",17],["Bool",18,105],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isSubnormal",7],[": ",17],["Bool",18]],"e":[["RealType",1,"Real",66]],"d":"True if this value is subnormal.\n\nA complex number is subnormal if it is finite, not normal, and not zero.\nWhen the result of a computation is subnormal, underflow has occurred and\nthe result generally does not have full precision.\n\nSee also:\n-\n- `.isFinite`\n- `.isNormal`\n- `.isZero`"},{"p":["Complex","canonicalized"],"f":[["var",12],[" ",17],["canonicalized",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["canonicalized",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"d":"A \"canonical\" representation of the value.\n\nFor normal complex numbers with a RealType conforming to\nBinaryFloatingPoint (the common case), the result is simply this value\nunmodified. For zeros, the result has the representation (+0, +0). For\ninfinite values, the result has the representation (+inf, +0).\n\nIf the RealType admits non-canonical representations, the x and y\ncomponents are canonicalized in the result.\n\nThis is mainly useful for interoperation with other languages, where\nyou may want to reduce each equivalence class to a single representative\nbefore passing across language boundaries, but it may also be useful\nfor some serialization tasks. It's also a useful implementation detail\nfor some primitive operations."},{"p":["Complex","lengthSquared"],"f":[["var",12],[" ",17],["lengthSquared",7],[": ",17],["RealType",18],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["lengthSquared",7],[": ",17],["RealType",18]],"e":[["RealType",1,"Real",66]],"d":"The squared length `(real*real + imaginary*imaginary)`.\n\nThis property is more efficient to compute than `length`, but is\nhighly prone to overflow or underflow; for finite values that are\nnot well-scaled, `lengthSquared` is often either zero or\ninfinity, even when `length` is a finite number. Use this property\nonly when you are certain that this value is well-scaled.\n\nFor many cases, `.magnitude` can be used instead, which is similarly\ncheap to compute and always returns a representable value.\n\nSee also:\n-\n- `.length`\n- `.magnitude`"},{"p":["Complex","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,104],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]],"e":[["RealType",1,"Real",66]],"o":138},{"p":["Complex","real"],"f":[["var",12],[" ",17],["real",7],[": ",17],["RealType",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["real",7],[": ",17],["RealType",18]],"e":[["RealType",1,"Real",66]],"d":"The real part of this complex value.\n\nIf `z` is not finite, `z.real` is `.nan`."},{"p":["Complex","phase"],"f":[["var",12],[" ",17],["phase",7],[": ",17],["RealType",18],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["phase",7],[": ",17],["RealType",18]],"e":[["RealType",1,"Real",66]],"d":"The phase (angle, or \"argument\").\n\nReturns the angle (measured above the real axis) in radians. If\nthe complex value is zero or infinity, the phase is not defined,\nand `nan` is returned.\n\nEdge cases:\n-\nIf the complex value is zero or non-finite, phase is `nan`.\n\nSee also:\n-\n- `.length`\n- `.polar`\n- `init(r:θ:)`"},{"p":["Complex","polar"],"f":[["var",12],[" ",17],["polar",7],[": (length",17],[": ",17],["RealType",18],[", phase",17],[": ",17],["RealType",18],[") { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["polar",7],[": (length",17],[": ",17],["RealType",18],[", phase",17],[": ",17],["RealType",18],[")",17]],"e":[["RealType",1,"Real",66]],"d":"The length and phase (or polar coordinates) of this value.\n\nEdge cases:\n-\nIf the complex value is zero or non-finite, phase is `.nan`.\nIf the complex value is non-finite, length is `.infinity`.\n\nSee also:\n-\n- `.length`\n- `.phase`\n- `init(r:θ:)`"},{"p":["Complex","isZero"],"f":[["var",12],[" ",17],["isZero",7],[": ",17],["Bool",18,105],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isZero",7],[": ",17],["Bool",18]],"e":[["RealType",1,"Real",66]],"d":"True if this value is zero.\n\nA complex number is zero if *both* the real and imaginary components\nare zero.\n\nSee also:\n-\n- `.isFinite`\n- `.isNormal`\n- `.isSubnormal`"},{"p":["Complex","length"],"f":[["var",12],[" ",17],["length",7],[": ",17],["RealType",18],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["length",7],[": ",17],["RealType",18]],"e":[["RealType",1,"Real",66]],"d":"The Euclidean norm (a.k.a. 2-norm, `sqrt(real*real + imaginary*imaginary)`).\n\nThis property takes care to avoid spurious over- or underflow in\nthis computation. For example:\n\n    let x: Float = 3.0e+20\n    let x: Float = 4.0e+20\n    let naive = sqrt(x*x + y*y) // +Inf\n    let careful = Complex(x, y).length // 5.0e+20\n\nNote that it *is* still possible for this property to overflow,\nbecause the length can be as much as sqrt(2) times larger than\neither component, and thus may not be representable in the real type.\n\nFor most use cases, you can use the cheaper `.magnitude`\nproperty (which computes the ∞-norm) instead, which always produces\na representable result.\n\nEdge cases:\n-\nIf a complex value is not finite, its `.length` is `infinity`.\n\nSee also:\n-\n- `.magnitude`\n- `.lengthSquared`\n- `.phase`\n- `.polar`\n- `init(r:θ:)`"},{"p":["Complex","isFinite"],"f":[["var",12],[" ",17],["isFinite",7],[": ",17],["Bool",18,105],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isFinite",7],[": ",17],["Bool",18]],"e":[["RealType",1,"Real",66]],"d":"True if this value is finite.\n\nA complex value is finite if neither component is an infinity or nan.\n\nSee also:\n-\n- `.isNormal`\n- `.isSubnormal`\n- `.isZero`"},{"p":["Complex","isNormal"],"f":[["var",12],[" ",17],["isNormal",7],[": ",17],["Bool",18,105],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isNormal",7],[": ",17],["Bool",18]],"e":[["RealType",1,"Real",66]],"d":"True if this value is normal.\n\nA complex number is normal if it is finite and *either* the real or\nimaginary component is normal. A floating-point number representing\none of the components is normal if its exponent allows a full-precision\nrepresentation.\n\nSee also:\n-\n- `.isFinite`\n- `.isSubnormal`\n- `.isZero`"},{"p":["Complex","conjugate"],"f":[["var",12],[" ",17],["conjugate",7],[": ",17],["Complex",18,0],["<",17],["RealType",18],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["conjugate",7],[": ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"d":"The complex conjugate of this value."},{"p":["Complex","imaginary"],"f":[["var",12],[" ",17],["imaginary",7],[": ",17],["RealType",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["imaginary",7],[": ",17],["RealType",18]],"e":[["RealType",1,"Real",66]],"d":"The imaginary part of this complex value.\n\nIf `z` is not finite, `z.imaginary` is `.nan`."},{"p":["Complex","magnitude"],"f":[["var",12],[" ",17],["magnitude",7],[": ",17],["RealType",18],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["magnitude",7],[": ",17],["RealType",18]],"e":[["RealType",1,"Real",66]],"d":"The ∞-norm of the value (`max(abs(real), abs(imaginary))`).\n\nIf you need the Euclidean norm (a.k.a. 2-norm) use the `length` or\n`lengthSquared` properties instead.\n\nEdge cases:\n-\n- If `z` is not finite, `z.magnitude` is `.infinity`.\n- If `z` is zero, `z.magnitude` is `0`.\n- Otherwise, `z.magnitude` is finite and non-zero.\n\nSee also:\n-\n- `.length`\n- `.lengthSquared`","o":115},{"p":["Complex","zeroTangentVectorInitializer"],"f":[["var",12],[" ",17],["zeroTangentVectorInitializer",7],[": () -> ",17],["Complex",18,0],["<",17],["RealType",18],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["zeroTangentVectorInitializer",7],[": () -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66],["RealType",1,"Differentiable",94],["RealType",2,"RealType.TangentVector"]]},{"p":["Complex","expMinusOne(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["expMinusOne",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["expMinusOne",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":74},{"p":["Complex","cos(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["cos",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["cos",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":75},{"p":["Complex","exp(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["exp",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["exp",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"d":"The complex exponential function e^z whose base `e` is the base of the\nnatural logarithm.\n\nMathematically, this operation can be expanded in terms of the `Real`\noperations `exp`, `cos` and `sin` as follows:\n```\nexp(x + iy) = exp(x) exp(iy)\n            = exp(x) cos(y) + i exp(x) sin(y)\n```\nNote that naive evaluation of this expression in floating-point would be\nprone to premature overflow, since `cos` and `sin` both have magnitude\nless than 1 for most inputs (i.e. `exp(x)` may be infinity when\n`exp(x) cos(y)` would not be).","o":76},{"p":["Complex","log(onePlus:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["log",7],["(",17],["onePlus",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["log",7],["(",17],["onePlus",1],[": ",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":77},{"p":["Complex","log(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["log",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["log",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":78},{"p":["Complex","pow(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["pow",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["_",1],[" ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["pow",7],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":80},{"p":["Complex","pow(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["pow",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,108],[") -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["pow",7],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Int",18],[") -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":79},{"p":["Complex","sin(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["sin",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["sin",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":81},{"p":["Complex","tan(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["tan",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["tan",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":82},{"p":["Complex","acos(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["acos",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["acos",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":83},{"p":["Complex","asin(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["asin",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["asin",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":84},{"p":["Complex","atan(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["atan",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["atan",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":85},{"p":["Complex","cosh(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["cosh",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["cosh",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":86},{"p":["Complex","root(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["root",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,108],[") -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["root",7],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Int",18],[") -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":87},{"p":["Complex","sinh(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["sinh",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["sinh",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":88},{"p":["Complex","sqrt(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["sqrt",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["sqrt",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":89},{"p":["Complex","tanh(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["tanh",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["tanh",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":90},{"p":["Complex","acosh(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["acosh",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["acosh",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":91},{"p":["Complex","asinh(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["asinh",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["asinh",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":92},{"p":["Complex","atanh(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["atanh",7],["(",17],["_",1],[" ",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["atanh",7],["(",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":93},{"p":["Complex","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,139],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":100},{"p":["Complex","encode(to:)"],"f":[["func",12],[" ",17],["encode",7],["(",17],["to",1],[" ",17],["encoder",2],[": ",17],["Encoder",18,141],[") ",17],["throws",12]],"s":[["func",12],[" ",17],["encode",7],["(",17],["to",1],[": ",17],["Encoder",18],[") ",17],["throws",12]],"e":[["RealType",1,"Real",66],["RealType",1,"Encodable",97]],"c":[["RealType",1,"Real",66],["RealType",1,"Encodable",97]],"g":[["RealType",0,0]],"o":98},{"p":["Complex","/(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["/",7],[" ",17],["(",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["/",7],[" ",17],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":69},{"p":["Complex","*(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["*",7],[" ",17],["(",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["*",7],[" ",17],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":112},{"p":["Complex","+(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["+",7],[" ",17],["(",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["+",7],[" ",17],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":122},{"p":["Complex","-(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["z",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Complex",18],["<",17],["RealType",18],[">",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":123},{"p":["Complex","/=(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["/=",7],[" ",17],["(",17],["z",2],[": ",17],["inout",12],[" ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["/=",7],[" ",17],["(",17],["inout",12],[" ",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">)",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":70},{"p":["Complex","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["a",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["b",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">) -> ",17],["Bool",18,105]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">) -> ",17],["Bool",18]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":102},{"p":["Complex","*=(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["*=",7],[" ",17],["(",17],["z",2],[": ",17],["inout",12],[" ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["*=",7],[" ",17],["(",17],["inout",12],[" ",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">)",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":113},{"p":["Complex","+=(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["+=",7],[" ",17],["(",17],["z",2],[": ",17],["inout",12],[" ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["+=",7],[" ",17],["(",17],["inout",12],[" ",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">)",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":124},{"p":["Complex","-=(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["-=",7],[" ",17],["(",17],["z",2],[": ",17],["inout",12],[" ",17],["Complex",18,0],["<",17],["RealType",18],[">, ",17],["w",2],[": ",17],["Complex",18,0],["<",17],["RealType",18],[">)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["-=",7],[" ",17],["(",17],["inout",12],[" ",17],["Complex",18],["<",17],["RealType",18],[">, ",17],["Complex",18],["<",17],["RealType",18],[">)",17]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":125},{"p":["Complex","IntegerLiteralType"],"f":[["typealias",12],[" ",17],["IntegerLiteralType",7],[" = ",17],["Int",18,108]],"s":[["typealias",12],[" ",17],["IntegerLiteralType",7]],"e":[["RealType",1,"Real",66]],"c":[["RealType",1,"Real",66]],"g":[["RealType",0,0]],"o":136},{"p":["Complex","TangentVector"],"f":[["typealias",12],[" ",17],["TangentVector",7],[" = ",17],["Complex",18,0],["<",17],["RealType",18],[">",17]],"s":[["typealias",12],[" ",17],["TangentVector",7]],"e":[["RealType",1,"Real",66],["RealType",1,"Differentiable",94],["RealType",2,"RealType.TangentVector"]],"c":[["RealType",1,"Real",66],["RealType",1,"Differentiable",94],["RealType",2,"RealType.TangentVector"]],"g":[["RealType",0,0]],"o":95}],"edges":{"conformer":[0,67,[["RealType",1,"Real",66]],0,73,[["RealType",1,"Real",66]],0,94,[["RealType",1,"Real",66],["RealType",1,"Differentiable",94],["RealType",2,"RealType.TangentVector"]],0,97,[["RealType",1,"Real",66],["RealType",1,"Encodable",97]],0,99,[["RealType",1,"Real",66]],0,101,[["RealType",1,"Real",66]],0,106,[["RealType",1,"Real",66],["RealType",1,"Decodable",106]],0,109,[["RealType",1,"Real",66]],0,117,[["RealType",1,"Real",66]],0,120,[["RealType",1,"Real",66]],0,131,[["RealType",1,"Real",66]],0,134,[["RealType",1,"Real",66]],0,137,[["RealType",1,"Real",66]]],"feature":[71,0,72,0,103,0,110,0,111,0,118,0,119,0,121,0,127,0,128,0,129,0,130,0,133,0],"member":[1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,0,29,0,30,0,31,0,32,0,33,0,34,0,35,0,36,0,37,0,38,0,39,0,40,0,41,0,42,0,43,0,44,0,45,0,46,0,47,0,48,0,49,0,50,0,51,0,52,0,53,0,54,0,55,0,56,0,57,0,58,0,59,0,60,0,61,0,62,0,63,0,64,0,65,0]},"sourcemap":[{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-numerics@1.0.2/.build/checkouts/swift-numerics/Sources/ComplexModule/Arithmetic.swift","symbols":[16,21,57,21,21,58,26,21,62,31,21,63,86,21,56,91,21,55,101,21,61,106,21,59,149,13,15,185,13,16]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-numerics@1.0.2/.build/checkouts/swift-numerics/Sources/ComplexModule/Complex.swift","symbols":[47,14,0,65,9,9,76,13,22,87,13,30,103,20,13,115,20,12,127,20,11,139,20,14,145,13,29,159,13,27,176,13,28,192,13,18,207,13,25,227,13,31,248,13,19,261,9,10,269,9,4,277,9,8,284,9,3,289,19,64,292,9,1,300,9,6,306,9,5,320,21,60,332,14,53,351,9,7,360,14,54,369,13,17,378,13,21,416,13,26,448,13,20,471,13,23,488,13,24,517,9,2]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-numerics@1.0.2/.build/checkouts/swift-numerics/Sources/ComplexModule/Differentiable.swift","symbols":[16,19,65,19,13,32]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-numerics@1.0.2/.build/checkouts/swift-numerics/Sources/ComplexModule/ElementaryFunctions.swift","symbols":[55,21,35,70,21,33,140,21,45,170,21,47,186,21,49,210,21,34,216,21,40,223,21,41,230,21,37,330,21,36,363,21,42,371,21,43,380,21,44,386,21,50,395,21,51,401,21,52,416,21,38,421,21,39,434,21,48,463,21,46]}]}