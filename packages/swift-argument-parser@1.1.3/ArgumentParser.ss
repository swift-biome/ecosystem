{"culture":"ArgumentParser","dependencies":[{"package":"swift-argument-parser","modules":["ArgumentParserToolInfo"]}],"extensions":[{"name":"ArgumentParser","source":"# ``ArgumentParser``\n\nStraightforward, type-safe argument parsing for Swift.\n\n## Overview\n\nBy using `ArgumentParser`, you can create a command-line interface tool\nby declaring simple Swift types.\nBegin by declaring a type that defines\nthe information that you need to collect from the command line.\nDecorate each stored property with one of `ArgumentParser`'s property wrappers,\ndeclare conformance to ``ParsableCommand``,\nand implement your command's logic in its `run()` method.\n\n```swift\nimport ArgumentParser\n\n@main\nstruct Repeat: ParsableCommand {\n    @Argument(help: \"The phrase to repeat.\")\n    var phrase: String\n\n    @Option(help: \"The number of times to repeat 'phrase'.\")\n    var count: Int?\n\n    mutating func run() throws {\n        let repeatCount = count ?? 2\n        for _ in 0..<repeatCount {\n            print(phrase)\n        }\n    }\n}\n```\n\nWhen a user executes your command, \nthe `ArgumentParser` library parses the command-line arguments,\ninstantiates your command type,\nand then either calls your `run()` method or exits with a useful message.\n\n![The output of the Repeat command, declared above.](repeat.png)\n\n#### Additional Resources\n\n- [`ArgumentParser` on GitHub](https://github.com/apple/swift-argument-parser/)\n- [`ArgumentParser` on the Swift Forums](https://forums.swift.org/c/related-projects/argumentparser/60)\n\n## Topics\n\n### Essentials\n\n- <doc:GettingStarted>\n- ``ParsableCommand``\n- ``AsyncParsableCommand``\n- <doc:CommandsAndSubcommands>\n- <doc:CustomizingCommandHelp>\n\n### Arguments, Options, and Flags\n\n- <doc:DeclaringArguments>\n- ``Argument``\n- ``Option``\n- ``Flag``\n- ``OptionGroup``\n- ``ParsableArguments``\n\n### Property Customization\n\n- <doc:CustomizingHelp>\n- ``ArgumentHelp``\n- ``ArgumentVisibility``\n- ``NameSpecification``\n\n### Custom Types\n\n- ``ExpressibleByArgument``\n- ``EnumerableFlag``\n\n### Validation and Errors\n\n- <doc:Validation>\n- ``ValidationError``\n- ``CleanExit``\n- ``ExitCode``\n\n### Shell Completion Scripts\n\n- <doc:InstallingCompletionScripts>\n- <doc:CustomizingCompletions>\n- ``CompletionKind``\n\n### Advanced Topics\n\n- <doc:ManualParsing>\n- <doc:ExperimentalFeatures>\n"},{"name":"ParsableArguments","source":"# ``ArgumentParser/ParsableArguments``\n\n## Topics\n\n### Handling Validation\n\n- ``validate()-5r0ge``\n\n### Parsing a Type\n\n- ``parse(_:)``\n- ``parseOrExit(_:)``\n\n### Exiting a Program\n\n- ``exit(withError:)``\n\n### Generating Help Text\n\n- ``helpMessage(includeHidden:columns:)``\n\n### Handling Errors\n\n- ``message(for:)``\n- ``fullMessage(for:)``\n- ``exitCode(for:)``\n\n### Generating Completion Scripts\n\n- ``completionScript(for:)``\n- ``CompletionShell``\n\n### Infrequently Used APIs\n\n- ``init()``\n"},{"name":"OptionGroup","source":"# ``ArgumentParser/OptionGroup``\n\n## Topics\n\n### Creating an Option Group\n\n- ``init(visibility:)``\n\n### Infrequently Used APIs\n\n- ``init()``\n- ``init(from:)``\n- ``wrappedValue``\n- ``description``\n\n\n"},{"name":"CommandConfiguration","source":"# ``ArgumentParser/CommandConfiguration``\n\n## Topics\n\n### Creating a Configuration\n\n- ``init(commandName:abstract:usage:discussion:version:shouldDisplay:subcommands:defaultSubcommand:helpNames:)``\n\n### Customizing the Help Screen\n\n- ``abstract``\n- ``discussion``\n- ``usage``\n- ``helpNames``\n\n### Declaring Subcommands\n\n- ``subcommands``\n- ``defaultSubcommand``\n\n### Defining Command Properties\n\n- ``commandName``\n- ``version``\n- ``shouldDisplay``\n\n### Deprecated APIs\n\n- ``init(commandName:abstract:discussion:version:shouldDisplay:subcommands:defaultSubcommand:helpNames:)``\n\n"},{"name":"Flag","source":"# ``ArgumentParser/Flag``\n\n## Topics\n\n### Boolean Flags\n\n- ``init(wrappedValue:name:help:)``\n\n### Boolean Flags with Inversions\n\n- ``init(wrappedValue:name:inversion:exclusivity:help:)``\n- ``init(name:inversion:exclusivity:help:)-12okg``\n- ``init(name:inversion:exclusivity:help:)-1h8f7``\n- ``FlagInversion``\n\n### Counted Flags\n\n- ``init(name:help:)``\n\n### Custom Enumerable Flags\n\n- ``init(help:)``\n- ``init(exclusivity:help:)-38n7u``\n- ``init(exclusivity:help:)-5fggj``\n- ``init(wrappedValue:exclusivity:help:)``\n- ``init(wrappedValue:help:)``\n\n### Infrequently Used APIs\n\n- ``init(from:)``\n- ``wrappedValue``\n\n### Supporting Types\n\n- ``FlagExclusivity``\n\n### Deprecated APIs\n\n- ``init()``\n"},{"name":"Argument","source":"# ``ArgumentParser/Argument``\n\n## Topics\n\n### Single Arguments\n\n- ``init(help:completion:)-6pqzn``\n- ``init(help:completion:transform:)``\n- ``init(help:completion:)-4p94d``\n- ``init(wrappedValue:help:completion:)``\n- ``init(wrappedValue:help:completion:transform:)``\n\n### Array Arguments\n\n- ``init(parsing:help:completion:)``\n- ``init(parsing:help:completion:transform:)``\n- ``init(wrappedValue:parsing:help:completion:)``\n- ``init(wrappedValue:parsing:help:completion:transform:)``\n- ``ArgumentArrayParsingStrategy``\n\n### Infrequently Used APIs\n\n- ``init()``\n- ``init(from:)``\n- ``wrappedValue``\n"},{"name":"ParsableCommand","source":"# ``ArgumentParser/ParsableCommand``\n\n`ParsableCommand` types are the basic building blocks for command-line tools built using `ArgumentParser`. To create a command, declare properties using the `@Argument`, `@Option`, and `@Flag` property wrappers, or include groups of options with `@OptionGroup`. Finally, implement your command's functionality in the ``run()-7p2fr`` method.\n\n```swift\n@main\nstruct Repeat: ParsableCommand {\n    @Argument(help: \"The phrase to repeat.\")\n    var phrase: String\n\n    @Option(help: \"The number of times to repeat 'phrase'.\")\n    var count: Int?\n\n    mutating func run() throws {\n        let repeatCount = count ?? 2\n        for _ in 0..<repeatCount {\n            print(phrase)\n        }\n    }\n}\n```\n\n## Topics\n\n### Essentials\n\n- <doc:CommandsAndSubcommands>\n- <doc:CustomizingCommandHelp>\n\n### Implementing a Command's Behavior\n\n- ``run()-7p2fr``\n- ``ParsableArguments/validate()-5r0ge``\n\n### Customizing a Command\n\n- ``configuration-35km1``\n- ``CommandConfiguration``\n\n### Generating Help Text\n\n- ``helpMessage(for:includeHidden:columns:)``\n\n### Starting the Program\n\n- ``main()``\n- ``main(_:)``\n\n### Manually Parsing Input\n\n- ``parseAsRoot(_:)``\n\n"},{"name":"AsyncParsableCommand","source":"# ``ArgumentParser/AsyncParsableCommand``\n\nTo use `async`/`await` code in your commands' `run()` method implementations, follow these steps:\n\n1. For the root command in your command-line tool, declare conformance to `AsyncParsableCommand`, even if that command doesn't use asynchronous code.\n2. Apply the `@main` attribute to the root command. (Note: If your root command is in a `main.swift` file, rename the file to the name of the command.)\n3. For any command that needs to use asynchronous code, declare conformance to `AsyncParsableCommand` and mark the `run()` method as `async`. No changes are needed for commands that don't use asynchronous code.\n\n\n### Usage in Swift 5.5\n\nIn Swift 5.5, you need to declare a separate, standalone type as your asynchronous `@main` entry point. Instead of designating your root command as `@main`, as described above, use the code snippet below, replacing the placeholder with the name of your own root command. Otherwise, follow the steps above to use `async`/`await` code within your commands' `run()` methods.\n\n```swift\n@main struct AsyncMain: AsyncMainProtocol {\n    typealias Command = <#RootCommand#>\n}\n```\n\n## Topics\n\n### Implementing a Command's Behavior\n\n- ``run()``\n\n### Starting the Program\n\n- ``main()``\n- ``AsyncMainProtocol``\n\n"},{"name":"Option","source":"# ``ArgumentParser/Option``\n\n## Topics\n\n### Single Options\n\n- ``init(name:parsing:help:completion:)-4yske``\n- ``init(name:parsing:help:completion:)-7slrf``\n- ``init(name:parsing:help:completion:transform:)-2wf44``\n- ``init(wrappedValue:name:parsing:help:completion:)-7ilku``\n- ``init(wrappedValue:name:parsing:help:completion:transform:)-2llve``\n- ``SingleValueParsingStrategy``\n\n### Array Options\n\n- ``init(name:parsing:help:completion:)-238hg``\n- ``init(name:parsing:help:completion:transform:)-74hnp``\n- ``init(wrappedValue:name:parsing:help:completion:)-1dtbf``\n- ``init(wrappedValue:name:parsing:help:completion:transform:)-1kpto``\n- ``ArrayParsingStrategy``\n\n### Infrequently Used APIs\n\n- ``init()``\n- ``init(from:)``\n- ``wrappedValue``\n\n### Deprecated APIs\n\n- ``init(wrappedValue:name:parsing:completion:help:)``\n"},{"name":"GettingStarted","source":"# Getting Started with ArgumentParser\n\nLearn to set up and customize a simple command-line tool.\n\n## Overview\n\nThis guide walks through building an example command. You'll learn about the different tools that `ArgumentParser` provides for defining a command's options, customizing the interface, and providing help text for your user.\n\n## Adding ArgumentParser as a Dependency\n\nLet's write a tool called `count` that reads an input file, counts the words, and writes the result to an output file.\n\nFirst, we need to add `swift-argument-parser` as a dependency to our package, \nand then include `\"ArgumentParser\"` as a dependency for our executable target.\nOur \"Package.swift\" file ends up looking like this:\n\n```swift\n// swift-tools-version:5.5\nimport PackageDescription\n\nlet package = Package(\n    name: \"Count\",\n    dependencies: [\n        .package(url: \"https://github.com/apple/swift-argument-parser.git\", from: \"1.0.0\"),\n    ],\n    targets: [\n        .target(\n            name: \"count\",\n            dependencies: [.product(name: \"ArgumentParser\", package: \"swift-argument-parser\")]),\n    ]\n)\n```\n\n## Building Our First Command\n\nOnce we've built the `count` tool, we'll be able to run it like this:\n\n```\n% count readme.md readme.counts\nCounting words in 'readme.md' and writing the result into 'readme.counts'.\n```\n\nWe'll define the initial version of the command as a type that conforms to the `ParsableCommand` protocol:\n\n```swift\nimport ArgumentParser\n\n@main\nstruct Count: ParsableCommand {\n    @Argument var inputFile: String\n    @Argument var outputFile: String\n    \n    mutating func run() throws {\n        print(\"\"\"\n            Counting words in '\\(inputFile)' \\\n            and writing the result into '\\(outputFile)'.\n            \"\"\")\n            \n        // Read 'inputFile', count the words, and save to 'outputFile'.\n    }\n}\n```\n\nIn the code above, the `inputFile` and `outputFile` properties use the `@Argument` property wrapper. `ArgumentParser` uses this wrapper to denote a positional command-line input — because `inputFile` is specified first in the `Count` type, it's the first value read from the command line, and `outputFile` is the second.\n\nWe've implemented the command's logic in its `run()` method. Here, we're printing out a message confirming the names of the files the user gave. (You can find a full implementation of the completed command at the end of this guide.)\n\nFinally, you designate the `Count` command as the program's entry point by applying the `@main` attribute. When running your command, the `ArgumentParser` library parses the command-line arguments, verifies that they match up with what we've defined in `Count`, and either calls the `run()` method or exits with a helpful message.\n\n\n## Working with Named Options\n\nOur `count` tool may have a usability problem — it's not immediately clear whether a user should provide the input file first, or the output file. Instead of using positional arguments for our two inputs, let's specify that they should be labeled options:\n\n```\n% count --input-file readme.md --output-file readme.counts\nCounting words in 'readme.md' and writing the result into 'readme.counts'.\n```\n\nWe do this by using the `@Option` property wrapper instead of `@Argument`:\n\n```swift\nstruct Count: ParsableCommand {\n    @Option var inputFile: String\n    @Option var outputFile: String\n    \n    mutating func run() throws {\n        print(\"\"\"\n            Counting words in '\\(inputFile)' \\\n            and writing the result into '\\(outputFile)'.\n            \"\"\")\n            \n        // Read 'inputFile', count the words, and save to 'outputFile'.\n    }\n}\n```\n\nThe `@Option` property wrapper denotes a command-line input that looks like `--name <value>`, deriving its name from the name of your property. \n\nThis interface has a trade-off for the users of our `count` tool: With `@Argument`, users don't need to type as much, but they have to remember whether to provide the input file or the output file first. Using `@Option` makes the user type a little more, but the distinction between values is explicit. Options are order-independent, as well, so the user can name the input and output files in either order:\n\n```\n% count --output-file readme.counts --input-file readme.md\nCounting words in 'readme.md' and writing the result into 'readme.counts'.\n```\n\n## Adding a Flag\n\nNext, we want to add a `--verbose` flag to our tool, and only print the message if the user specifies that option:\n\n```\n% count --input-file readme.md --output-file readme.counts\n(no output)\n% count --verbose --input-file readme.md --output-file readme.counts\nCounting words in 'readme.md' and writing the result into 'readme.counts'.\n```\n\nLet's change our `Count` type to look like this:\n\n```swift\nstruct Count: ParsableCommand {\n    @Option var inputFile: String\n    @Option var outputFile: String\n    @Flag var verbose = false\n    \n    mutating func run() throws {\n        if verbose {\n            print(\"\"\"\n                Counting words in '\\(inputFile)' \\\n                and writing the result into '\\(outputFile)'.\n                \"\"\")\n        }\n \n        // Read 'inputFile', count the words, and save to 'outputFile'.\n    }\n}\n```\n\nThe `@Flag` property wrapper denotes a command-line input that looks like `--name`, deriving its name from the name of your property. Flags are most frequently used for Boolean values, like the `verbose` property here.\n\n\n## Using Custom Names\n\nWe can customize the names of our options and add an alternative to the `verbose` flag so that users can specify `-v` instead of `--verbose`. The new interface will look like this:\n\n```\n% count -v -i readme.md -o readme.counts\nCounting words in 'readme.md' and writing the result into 'readme.counts'.\n% count --input readme.md --output readme.counts -v\nCounting words in 'readme.md' and writing the result into 'readme.counts'.\n% count -o readme.counts -i readme.md --verbose\nCounting words in 'readme.md' and writing the result into 'readme.counts'.\n```\n\nCustomize the input names by passing `name` parameters to the `@Option` and `@Flag` initializers:\n\n```swift\nstruct Count: ParsableCommand {\n    @Option(name: [.short, .customLong(\"input\")])\n    var inputFile: String\n\n    @Option(name: [.short, .customLong(\"output\")])\n    var outputFile: String\n\n    @Flag(name: .shortAndLong)\n    var verbose = false\n    \n    mutating func run() throws { ... }\n}\n```\n\nThe default name specification is `.long`, which uses a property's name with a two-dash prefix. `.short` uses only the first letter of a property's name with a single-dash prefix, and allows combining groups of short options. You can specify custom short and long names with the `.customShort(_:)` and `.customLong(_:)` methods, respectively, or use the combined `.shortAndLong` property to specify the common case of both the short and long derived names.\n\n## Providing Help\n\n`ArgumentParser` automatically generates help for any command when a user provides the `-h` or `--help` flags:\n\n```\n% count --help\nUSAGE: count --input <input> --output <output> [--verbose]\n\nOPTIONS:\n  -i, --input <input>      \n  -o, --output <output>    \n  -v, --verbose            \n  -h, --help              Show help information.\n```\n\nThis is a great start — you can see that all the custom names are visible, and the help shows that values are expected for the `--input` and `--output` options. However, our custom options and flag don't have any descriptive text. Let's add that now by passing string literals as the `help` parameter:\n\n```swift\nstruct Count: ParsableCommand {\n    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")\n    var inputFile: String\n\n    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")\n    var outputFile: String\n\n    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")\n    var verbose = false\n\n    mutating func run() throws { ... }\n}\n```\n\nThe help screen now includes descriptions for each parameter:\n\n```\n% count -h\nUSAGE: count --input <input> --output <output> [--verbose]\n\nOPTIONS:\n  -i, --input <input>     A file to read. \n  -o, --output <output>   A file to save word counts to. \n  -v, --verbose           Print status updates while counting. \n  -h, --help              Show help information.\n\n```\n\n## The Complete Utility\n\nAs promised, here's the complete `count` command, for your experimentation:\n\n```swift\nimport ArgumentParser\nimport Foundation\n\n@main\nstruct Count: ParsableCommand {\n    static let configuration = CommandConfiguration(abstract: \"Word counter.\")\n    \n    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")\n    var inputFile: String\n\n    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")\n    var outputFile: String\n\n    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")\n    var verbose = false\n\n    mutating func run() throws {\n        if verbose {\n            print(\"\"\"\n                Counting words in '\\(inputFile)' \\\n                and writing the result into '\\(outputFile)'.\n                \"\"\")\n        }\n \n        guard let input = try? String(contentsOfFile: inputFile) else {\n            throw RuntimeError(\"Couldn't read from '\\(inputFile)'!\")\n        }\n        \n        let words = input.components(separatedBy: .whitespacesAndNewlines)\n            .map { word in\n                word.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)\n                    .lowercased()\n            }\n            .compactMap { word in word.isEmpty ? nil : word }\n        \n        let counts = Dictionary(grouping: words, by: { $0 })\n            .mapValues { $0.count }\n            .sorted(by: { $0.value > $1.value })\n        \n        if verbose {\n            print(\"Found \\(counts.count) words.\")\n        }\n        \n        let output = counts.map { word, count in \"\\(word): \\(count)\" }\n            .joined(separator: \"\\n\")\n        \n        guard let _ = try? output.write(toFile: outputFile, atomically: true, encoding: .utf8) else {\n            throw RuntimeError(\"Couldn't write to '\\(outputFile)'!\")\n        }\n    }\n}\n\nstruct RuntimeError: Error, CustomStringConvertible {\n    var description: String\n    \n    init(_ description: String) {\n        self.description = description\n    }\n}\n```\n"},{"name":"ManualParsing","source":"# Manual Parsing and Testing\n\nProvide your own array of command-line inputs or work directly with parsed command-line arguments.\n\n## Overview\n\nFor most programs, denoting the root command type as `@main` is all that's necessary. As the program's entry point, that type parses the command-line arguments to find the correct command from your tree of nested subcommands, instantiates and validates the result, and executes the chosen command. For more control, however, you can perform each of those steps manually.\n\n## Parsing Arguments\n\nFor simple Swift scripts, and for those who prefer a straight-down-the-left-edge-of-the-screen scripting style, you can define a single ``ParsableArguments`` type to parse explicitly from the command-line arguments.\n\nLet's implement the `Select` command discussed in <doc:Validation>, but using a scripty style instead of the typical command. First, we define the options as a `ParsableArguments` type:\n\n```swift\nstruct SelectOptions: ParsableArguments {\n    @Option var count: Int = 1\n    @Argument var elements: [String] = []\n}\n```\n\nThe next step is to parse our options from the command-line input:\n\n```swift\nlet options = SelectOptions.parseOrExit()\n```\n\nThe static ``ParsableArguments/parseOrExit(_:)`` method either returns a fully initialized instance of the type, or exits with an error message and code. Alternatively, you can call the throwing ``ParsableArguments/parse(_:)`` method if you'd like to catch any errors that arise during parsing.\n\nWe can perform validation on the inputs and exit the script if necessary:\n\n```swift\nguard options.elements.count >= options.count else {\n    let error = ValidationError(\"Please specify a 'count' less than the number of elements.\")\n    SelectOptions.exit(withError: error)\n}\n```\n\nAs you would expect, the ``ParsableArguments/exit(withError:)`` method includes usage information when you pass it a ``ValidationError``.\n\nFinally, we print out the requested number of elements:\n\n```swift\nlet chosen = options.elements\n    .shuffled()\n    .prefix(options.count)\nprint(chosen.joined(separator: \"\\n\"))\n```\n\n## Parsing Commands\n\nManually parsing commands is a little more complex than parsing a simple `ParsableArguments` type. The result of parsing from a tree of subcommands may be of a different type than the root of the tree, so the static ``ParsableCommand/parseAsRoot(_:)`` method returns a type-erased ``ParsableCommand``.\n\nLet's see how this works by using the `Math` command and subcommands defined in <doc:CommandsAndSubcommands>. This time, instead of calling `Math.main()`, we'll call `Math.parseAsRoot()`, and switch over the result:\n\n```swift\ndo {\n    var command = try Math.parseAsRoot()\n\n    switch command {\n    case var command as Math.Add:\n        print(\"You chose to add \\(command.options.values.count) values.\")\n        command.run()\n    default:\n        print(\"You chose to do something else.\")\n        try command.run()\n    }\n} catch {\n    Math.exit(withError: error)\n}\n```\nOur new logic intercepts the command between validation and running, and outputs an additional message:\n\n```\n% math 10 15 7\nYou chose to add 3 values.\n32\n% math multiply 10 15 7\nYou chose to do something else.\n1050\n```\n\n## Providing Command-Line Input\n\nAll of the parsing methods — `parse()`, `parseOrExit()`, and `parseAsRoot()` — can optionally take an array of command-line inputs as an argument. You can use this capability to test your commands, to perform pre-parse filtering of the command-line arguments, or to manually execute commands from within the same or another target.\n\nLet's update our `select` script above to strip out any words that contain all capital letters before parsing the inputs.\n\n```swift\nlet noShoutingArguments = CommandLine.arguments.dropFirst().filter { phrase in\n    phrase.uppercased() != phrase\n}\nlet options = SelectOptions.parseOrExit(noShoutingArguments)\n```\n\nNow when we call our command, the parser won't even see the capitalized words — `HEY` won't ever be printed:\n\n```\n% select hi howdy HEY --count 2\nhi\nhowdy\n% select hi howdy HEY --count 2\nhowdy\nhi\n```\n"},{"name":"InstallingCompletionScripts","source":"# Generating and Installing Completion Scripts\n\nInstall shell completion scripts generated by your command-line tool. \n\n## Overview\n\nCommand-line tools that you build with `ArgumentParser` include a built-in option for generating completion scripts, with support for Bash, Z shell, and Fish. To generate completions, run your command with the `--generate-completion-script` option to generate completions for your specific shell.\n\n```\n$ example --generate-completion-script bash\n#compdef example\nlocal context state state_descr line\n_example_commandname=\"example\"\ntypeset -A opt_args\n\n_example() {\n    integer ret=1\n    local -a args\n    ...\n}\n\n_example\n```\n\nThe correct method of installing a completion script can depend on both your shell and your configuration.\n\n### Installing Zsh Completions\n\nIf you have [`oh-my-zsh`](https://ohmyz.sh) installed, you already have a directory of automatically loading completion scripts — `.oh-my-zsh/completions`. Copy your new completion script to that directory.\n\n```\n$ example --generate-completion-script zsh > ~/.oh-my-zsh/completions/_example\n```\n\n> Your completion script must have the following filename format: `_example`.\n\nWithout `oh-my-zsh`, you'll need to add a path for completion scripts to your function path, and turn on completion script autoloading. First, add these lines to `~/.zshrc`:\n\n```\nfpath=(~/.zsh/completion $fpath)\nautoload -U compinit\ncompinit\n```\n\nNext, create a directory at `~/.zsh/completion` and copy the completion script to the new directory.\n\n### Installing Bash Completions\n\nIf you have [`bash-completion`](https://github.com/scop/bash-completion) installed, you can just copy your new completion script to the `/usr/local/etc/bash_completion.d` directory.\n\nWithout `bash-completion`, you'll need to source the completion script directly. Copy it to a directory such as `~/.bash_completions/`, and then add the following line to `~/.bash_profile` or `~/.bashrc`:\n\n```\nsource ~/.bash_completions/example.bash\n```\n\n### Installing Fish Completions\n\nCopy the completion script to any path listed in the environment variable `$fish_completion_path`.  For example, a typical location is `~/.config/fish/completions/your_script.fish`.\n"},{"name":"DeclaringArguments","source":"# Declaring Arguments, Options, and Flags\n\nUse the `@Argument`, `@Option` and `@Flag` property wrappers to declare the command-line interface for your command.\n\n## Overview\n\nWhen creating commands, you can define three primary kinds of command-line inputs:\n\n- *Arguments* are values given by a user and are read in order from first to last (see ``Argument``). For example, this command is called with three file names as arguments:\n\n  ```\n  % example file1.swift file2.swift file3.swift\n  ```\n\n- *Options* are named key-value pairs. Keys start with one or two dashes (`-` or `--`), and a user can separate the key and value with an equal sign (`=`) or a space (see ``Option``). This command is called with two options:\n\n  ```\n  % example --count=5 --index 2\n  ```\n\n- *Flags* are like options, but without a paired value. Instead, their presence indicates a particular value (see ``Flag``). This command is called with two flags:\n\n  ```\n  % example --verbose --strip-whitespace\n  ```\n\nThe three preceding examples could be calls of this `Example` command:\n\n```swift\nstruct Example: ParsableCommand {\n    @Argument var files: [String] = []\n    @Option var count: Int?\n    @Option var index = 0\n    @Flag var verbose = false\n    @Flag var stripWhitespace = false\n}\n```\n\nThis example shows how `ArgumentParser` provides defaults that speed up your initial development process:\n\n- Option and flag names are derived from the names of your command's properties.\n- What kinds of inputs are valid, and whether arguments are required, is based on your properties' types and default values.\n\nIn this example, all of the properties have default values (optional properties default to `nil`).\n\nUsers must provide values for all properties with no implicit or specified default. For example, this command would require one integer argument and a string with the key `--user-name`.\n\n```swift\nstruct Example: ParsableCommand {\n    @Option var userName: String\n    @Argument var value: Int\n}\n```\n\nWhen called without both values, the command exits with an error:\n\n```\n% example 5\nError: Missing '--user-name <user-name>'\nUsage: example --user-name <user-name> <value>\n  See 'example --help' for more information.\n% example --user-name kjohnson\nError: Missing '<value>'\nUsage: example --user-name <user-name> <value>\n  See 'example --help' for more information.\n```\n\nWhen providing a default value for an array property, any user-supplied values replace the entire default.\n\n```swift\nstruct Lucky: ParsableCommand {\n    @Argument var numbers = [7, 14, 21]\n\n    mutating func run() throws {\n        print(\"\"\"\n        Your lucky numbers are:\n        \\(numbers.map(String.init).joined(separator: \" \"))\n        \"\"\")\n    }\n}\n```\n\n```\n% lucky \nYour lucky numbers are:\n7 14 21\n% lucky 1 2 3\nYour lucky numbers are:\n1 2 3\n```\n\n## Customizing option and flag names\n\nBy default, options and flags derive the name that you use on the command line from the name of the property, such as `--count` and `--index`. Camel-case names are converted to lowercase with hyphen-separated words, like `--strip-whitespace`.\n\nYou can override this default by specifying one or more name specifications in the `@Option` or `@Flag` initializers. This command demonstrates the four name specifications:\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag(name: .long)  // Same as the default\n    var stripWhitespace = false\n\n    @Flag(name: .short)\n    var verbose = false\n\n    @Option(name: .customLong(\"count\"))\n    var iterationCount: Int\n\n    @Option(name: [.customShort(\"I\"), .long])\n    var inputFile: String\n}\n```\n\n* Specifying `.long` or `.short` uses the property's name as the source of the command-line name. Long names use the whole name, prefixed by two dashes, while short names are a single character prefixed by a single dash. In this example, the `stripWhitespace` and `verbose` flags are specified in this way:\n\n  ```\n  % example --strip-whitespace -v\n  ```\n\n* Specifying `.customLong(_:)` or `.customShort(_:)` uses the given string or character as the long or short name for the property.\n\n  ```\n  % example --count 10 -I file1.swift\n  ```\n\n* Use array literal syntax to specify multiple names. The `inputFile` property can alternatively be given with the default long name:\n\n  ```\n  % example --input-file file1.swift\n  ```\n\n**Note:** You can also pass `withSingleDash: true` to `.customLong` to create a single-dash flag or option, such as `-verbose`. Use this name specification only when necessary, such as when migrating a legacy command-line interface. Using long names with a single-dash prefix can lead to ambiguity with combined short names: it may not be obvious whether `-file` is a single option or the combination of the four short options `-f`, `-i`, `-l`, and `-e`.\n\n\n## Parsing custom types\n\nArguments and options can be parsed from any type that conforms to the ``ExpressibleByArgument`` protocol. Standard library integer and floating-point types, strings, and Booleans all conform to `ExpressibleByArgument`.\n\nYou can make your own custom types conform to `ExpressibleByArgument` by implementing ``ExpressibleByArgument/init(argument:)``:\n\n```swift\nstruct Path: ExpressibleByArgument {\n    var pathString: String\n\n    init?(argument: String) {\n        self.pathString = argument\n    }\n}\n\nstruct Example: ParsableCommand {\n    @Argument var inputFile: Path\n}\n```\n\nThe library provides a default implementation for `RawRepresentable` types, like string-backed enumerations, so you only need to declare conformance.\n\n```swift\nenum ReleaseMode: String, ExpressibleByArgument {\n    case debug, release\n}\n\nstruct Example: ParsableCommand {\n    @Option var mode: ReleaseMode\n\n    mutating func run() throws {\n        print(mode)\n    }\n}\n```\n\nThe user can provide the raw values on the command line, which are then converted to your custom type. Only valid values are allowed:\n\n```\n% example --mode release\nrelease\n% example --mode future\nError: The value 'future' is invalid for '--mode <mode>'\n```\n\nTo use a non-`ExpressibleByArgument` type for an argument or option, you can instead provide a throwing `transform` function that converts the parsed string to your desired type. This is a good idea for custom types that are more complex than a `RawRepresentable` type, or for types you don't define yourself.\n\n```swift\nenum Format {\n    case text\n    case other(String)\n\n    init(_ string: String) throws {\n        if string == \"text\" {\n            self = .text\n        } else {\n            self = .other(string)\n        }\n    }\n}\n\nstruct Example: ParsableCommand {\n    @Argument(transform: Format.init)\n    var format: Format\n}\n```\n\nThrow an error from the `transform` function to indicate that the user provided an invalid value for that type. See <doc:Validation> for more about customizing `transform` function errors.\n\n## Using flag inversions, enumerations, and counts\n\nFlags are most frequently used for `Bool` properties. You can generate a `true`/`false` pair of flags by specifying a flag inversion:\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag(inversion: .prefixedNo)\n    var index = true\n\n    @Flag(inversion: .prefixedEnableDisable)\n    var requiredElement: Bool\n\n    mutating func run() throws {\n        print(index, requiredElement)\n    }\n}\n```\n\nWhen declaring a flag with an inversion, set the default by specifying `true` or `false` as the property's initial value. If you want to require that the user specify one of the two inversions, leave off the default value.\n\nIn the `Example` command defined above, a flag is required for the `requiredElement` property. The specified prefixes are prepended to the long names for the flags:\n\n```\n% example --enable-required-element\ntrue true\n% example --no-index --disable-required-element\nfalse false\n% example --index\nError: Missing one of: '--enable-required-element', '--disable-required-element'\n```\n\nTo create a flag with custom names for a Boolean value, to provide an exclusive choice between more than two names, or for collecting multiple values from a set of defined choices, define an enumeration that conforms to the `EnumerableFlag` protocol.\n\n```swift\nenum CacheMethod: String, EnumerableFlag {\n    case inMemoryCache\n    case persistentCache\n}\n\nenum Color: String, EnumerableFlag {\n    case pink, purple, silver\n}\n\nstruct Example: ParsableCommand {\n    @Flag var cacheMethod: CacheMethod\n    @Flag var colors: [Color] = []\n\n    mutating func run() throws {\n        print(cacheMethod)\n        print(colors)\n    }\n}\n```\n\nThe flag names in this case are drawn from the raw values — for information about customizing the names and help text, see the  ``EnumerableFlag`` documentation.\n\n```\n% example --in-memory-cache --pink --silver\n.inMemoryCache\n[.pink, .silver]\n% example\nError: Missing one of: '--in-memory-cache', '--persistent-cache'\n```\n\nFinally, when a flag is of type `Int`, the value is parsed as a count of the number of times that the flag is specified.\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag(name: .shortAndLong)\n    var verbose: Int\n\n    mutating func run() throws {\n        print(\"Verbosity level: \\(verbose)\")\n    }\n}\n```\n\nIn this example, `verbose` defaults to zero, and counts the number of times that `-v` or `--verbose` is given.\n\n```\n% example --verbose\nVerbosity level: 1\n% example -vvvv\nVerbosity level: 4\n```\n\n\n## Specifying default values\n\nYou can specify default values for almost all supported argument, option, and flag types using normal property initialization syntax:\n\n```swift\nenum CustomFlag: String, EnumerableFlag {\n    case foo, bar, baz\n}\n\nstruct Example: ParsableCommand {\n    @Flag\n    var booleanFlag = false\n\n    @Flag\n    var arrayFlag: [CustomFlag] = [.foo, .baz]\n\n    @Option\n    var singleOption = 0\n\n    @Option\n    var arrayOption = [\"bar\", \"qux\"]\n\n    @Argument\n    var singleArgument = \"quux\"\n\n    @Argument\n    var arrayArgument = [\"quux\", \"quuz\"]\n}\n```\n\nThis includes all of the variants of the argument types above (including `@Option(transform: ...)`, etc.), with a few notable exceptions:\n- `Optional`-typed values (which default to `nil` and for which a default would not make sense, as the value could never be `nil`)\n- `Int` flags (which are used for counting the number of times a flag is specified and therefore default to `0`)\n\nIf a default is not specified, the user must provide a value for that argument/option/flag or will receive an error that the value is missing.\n\nYou must also always specify a default of `false` for a non-optional `Bool` flag, as in the example above. This makes the behavior consistent with both normal Swift properties (which either must be explicitly initialized or optional to initialize a `struct`/`class` containing them) and the other property types.\n\n\n## Specifying a parsing strategy\n\nWhen parsing a list of command-line inputs, `ArgumentParser` distinguishes between dash-prefixed keys and un-prefixed values. When looking for the value for a key, only an un-prefixed value will be selected by default.\n\nFor example, this command defines a `--verbose` flag, a `--name` option, and an optional `file` argument:\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag var verbose = false\n    @Option var name: String\n    @Argument var file: String?\n\n    mutating func run() throws {\n        print(\"Verbose: \\(verbose), name: \\(name), file: \\(file ?? \"none\")\")\n    }\n}\n```\n\nWhen calling this command, the value for `--name` must be given immediately after the key. If the `--verbose` flag is placed in between, parsing fails with an error:\n\n```\n% example --verbose --name Tomás\nVerbose: true, name: Tomás, file: none\n% example --name --verbose Tomás\nError: Missing value for '--name <name>'\nUsage: example [--verbose] --name <name> [<file>]\n  See 'example --help' for more information.\n```\n\nParsing options as arrays is similar — only adjacent key-value pairs are recognized by default.\n\n### Alternative single-value parsing strategies\n\nYou can change this behavior by providing a different parsing strategy in the `@Option` initializer. **Be careful when selecting any of the alternative parsing strategies** — they may lead your command-line tool to have unexpected behavior for users!\n\nThe `.unconditional` parsing strategy uses the immediate next input for the value of the option, even if it starts with a dash. If `name` were instead defined as `@Option(parsing: .unconditional) var name: String`, the second attempt would result in `\"--verbose\"` being read as the value of `name`:\n\n```\n% example --name --verbose Tomás\nVerbose: false, name: --verbose, file: Tomás\n```\n\nThe `.scanningForValue` strategy, on the other hand, looks ahead in the list of command-line inputs and uses the first un-prefixed value as the input, even if that requires skipping over other flags or options.  If `name` were defined as `@Option(parsing: .scanningForValue) var name: String`, the parser would look ahead to find `Tomás`, then pick up parsing where it left off to get the `--verbose` flag:\n\n```\n% example --name --verbose Tomás\nVerbose: true, name: Tomás, file: none\n```\n\n### Alternative array parsing strategies\n\nThe default strategy for parsing options as arrays is to read each value from a key-value pair. For example, this command expects zero or more input file names:\n\n```swift\nstruct Example: ParsableCommand {\n    @Option var file: [String] = []\n    @Flag var verbose = false\n\n    mutating func run() throws {\n        print(\"Verbose: \\(verbose), files: \\(file)\")\n    }\n}\n```\n\nAs with single values, each time the user provides the `--file` key, they must also provide a value:\n\n```\n% example --verbose --file file1.swift --file file2.swift\nVerbose: true, files: [\"file1.swift\", \"file2.swift\"]\n% example --file --verbose file1.swift --file file2.swift\nError: Missing value for '--file <file>'\nUsage: example [--file <file> ...] [--verbose]\n  See 'example --help' for more information.\n```\n\nThe `.unconditionalSingleValue` parsing strategy uses whatever input follows the key as its value, even if that input is dash-prefixed. If `file` were defined as `@Option(parsing: .unconditionalSingleValue) var file: [String]`, then the resulting array could include strings that look like options:\n\n```\n% example --file file1.swift --file --verbose\nVerbose: false, files: [\"file1.swift\", \"--verbose\"]\n```\n\nThe `.upToNextOption` parsing strategy uses the inputs that follow the option key until reaching a dash-prefixed input. If `file` were defined as `@Option(parsing: .upToNextOption) var file: [String]`, then the user could specify multiple files without repeating `--file`:\n\n```\n% example --file file1.swift file2.swift\nVerbose: false, files: [\"file1.swift\", \"file2.swift\"]\n% example --file file1.swift file2.swift --verbose\nVerbose: true, files: [\"file1.swift\", \"file2.swift\"]\n```\n\nFinally, the `.remaining` parsing strategy uses all the inputs that follow the option key, regardless of their prefix. If `file` were defined as `@Option(parsing: .remaining) var file: [String]`, then the user would need to specify `--verbose` before the `--file` key for it to be recognized as a flag:\n\n```\n% example --verbose --file file1.swift file2.swift\nVerbose: true, files: [\"file1.swift\", \"file2.swift\"]\n% example --file file1.swift file2.swift --verbose\nVerbose: false, files: [\"file1.swift\", \"file2.swift\", \"--verbose\"]\n```\n\n### Alternative positional argument parsing strategies\n\nThe default strategy for parsing arrays of positional arguments is to ignore  all dash-prefixed command-line inputs. For example, this command accepts a `--verbose` flag and a list of file names as positional arguments:\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag var verbose = false\n    @Argument var files: [String] = []\n\n    mutating func run() throws {\n        print(\"Verbose: \\(verbose), files: \\(files)\")\n    }\n}\n```\n\nThe `files` argument array uses the default `.remaining` parsing strategy, so it only picks up values that don't have a prefix:\n\n```\n% example --verbose file1.swift file2.swift\nVerbose: true, files: [\"file1.swift\", \"file2.swift\"]\n% example --verbose file1.swift file2.swift --other\nError: Unexpected argument '--other'\nUsage: example [--verbose] [<files> ...]\n  See 'example --help' for more information.\n```\n\nAny input after the `--` terminator is automatically treated as positional input, so users can provide dash-prefixed values that way even with the default configuration:\n\n```\n% example --verbose -- file1.swift file2.swift --other\nVerbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]\n```\n\nThe `.unconditionalRemaining` parsing strategy uses whatever input is left after parsing known options and flags, even if that input is dash-prefixed, including the terminator itself. If `files` were defined as `@Argument(parsing: .unconditionalRemaining) var files: [String]`, then the resulting array would also include strings that look like options:\n\n```\n% example --verbose file1.swift file2.swift --other\nVerbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]\n% example -- --verbose file1.swift file2.swift --other\nVerbose: false, files: [\"--\", \"--verbose\", \"file1.swift\", \"file2.swift\", \"--other\"]\n```\n"},{"name":"ExperimentalFeatures","source":"# Experimental Features\n\nLearn about ArgumentParser's experimental features.\n\n## Overview\n\nCommand-line programs built using `ArgumentParser` may include some built-in experimental features, available with the prefix `--experimental`. These features should not be considered stable while still prefixed, as future releases may change their behavior or remove them.\n\nIf you have any feedback on experimental features, please [open a GitHub issue][issue].\n\n## List of Experimental Features\n\n| Name | Description | related PRs | Version |\n| ------------- | ------------- | ------------- | ------------- |\n| `--experimental-dump-help`  | Dumps command/argument/help information as JSON | [#310][] [#335][] | 0.5.0 or newer |\n\n[#310]: https://github.com/apple/swift-argument-parser/pull/310\n[#335]: https://github.com/apple/swift-argument-parser/pull/335\n[issue]: https://github.com/apple/swift-argument-parser/issues/new/choose \n"},{"name":"CustomizingCompletions","source":"# Customizing Completions\n\nProvide custom shell completions for your command-line tool's arguments and options.\n\n## Overview\n\n`ArgumentParser` provides default completions for any types that it can. For example, an `@Option` property that is a `CaseIterable` type will automatically have the correct values as completion suggestions.\n\nWhen declaring an option or argument, you can customize the completions that are offered by specifying a ``CompletionKind``. With this completion kind you can specify that the value should be a file, a directory, or one of a list of strings:\n\n```swift\nstruct Example: ParsableCommand {\n    @Option(help: \"The file to read from.\", completion: .file())\n    var input: String\n\n    @Option(help: \"The output directory.\", completion: .directory)\n    var outputDir: String\n\n    @Option(help: \"The preferred file format.\", completion: .list([\"markdown\", \"rst\"]))\n    var format: String\n\n    enum CompressionType: String, CaseIterable, ExpressibleByArgument {\n        case zip, gzip\n    }\n\n    @Option(help: \"The compression type to use.\")\n    var compression: CompressionType\n}\n```\n\nThe generated completion script will suggest only file names for the `--input` option, only directory names for `--output-dir`, and only the strings `markdown` and `rst` for `--format`. The `--compression` option uses the default completions for a `CaseIterable` type, so the completion script will suggest `zip` and `gzip`.\n\nYou can define the default completion kind for custom ``ExpressibleByArgument`` types by implementing ``ExpressibleByArgument/defaultCompletionKind-866se``. For example, any arguments or options with this `File` type will automatically use files for completions:\n\n```swift\nstruct File: Hashable, ExpressibleByArgument {\n    var path: String\n    \n    init?(argument: String) {\n        self.path = argument\n    }\n    \n    static var defaultCompletionKind: CompletionKind {\n        .file()\n    }\n}\n```\n\nFor even more control over the suggested completions, you can specify a function that will be called during completion by using the `.custom` completion kind.\n\n```swift\nfunc listExecutables(_ arguments: [String]) -> [String] {\n    // Generate the list of executables in the current directory\n}\n\nstruct SwiftRun {\n    @Option(help: \"The target to execute.\", completion: .custom(listExecutables))\n    var target: String?\n}\n```\n\nIn this example, when a user requests completions for the `--target` option, the completion script runs the `SwiftRun` command-line tool with a special syntax, calling the `listExecutables` function with an array of the arguments given so far.\n"},{"name":"CustomizingCommandHelp","source":"# Customizing Help for Commands\n\nDefine your command's abstract, extended discussion, or usage string, and set the flags used to invoke the help display.\n\n## Overview\n\nIn addition to configuring the command name and subcommands, as described in <doc:CommandsAndSubcommands>, you can also configure a command's help text by providing an abstract, discussion, or custom usage string.\n\n```swift\nstruct Repeat: ParsableCommand {\n    static var configuration = CommandConfiguration(\n        abstract: \"Repeats your input phrase.\",\n        usage: \"\"\"\n            repeat <phrase>\n            repeat --count <count> <phrase>\n            \"\"\",\n        discussion: \"\"\"\n            Prints to stdout forever, or until you halt the program.\n            \"\"\")\n\n    @Argument(help: \"The phrase to repeat.\")\n    var phrase: String\n\n    @Option(help: \"How many times to repeat.\")\n    var count: Int?\n\n    mutating func run() throws {\n        for _ in 0..<(count ?? 2) {\n            print(phrase) \n        }\n    }\n}\n```\n\nThe customized components now appear in the generated help screen:\n\n```\n% repeat --help\nOVERVIEW: Repeats your input phrase.\n\nPrints to stdout forever, or until you halt the program.\n\nUSAGE: repeat <phrase>\n       repeat --count <count> <phrase>\n\nARGUMENTS:\n  <phrase>                The phrase to repeat.\n\nOPTIONS:\n  -h, --help              Show help information.\n\n% repeat hello!\nhello!\nhello!\nhello!\nhello!\nhello!\nhello!\n...\n```\n\n## Modifying the Help Flag Names\n\nUsers can see the help screen for a command by passing either the `-h` or the `--help` flag, by default. If you need to use one of those flags for another purpose, you can provide alternative names when configuring a root command.\n\n```swift\nstruct Example: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        helpNames: [.long, .customShort(\"?\")])\n\n    @Option(name: .shortAndLong, help: \"The number of history entries to show.\")\n    var historyDepth: Int\n\n    mutating func run() throws {\n        printHistory(depth: historyDepth)\n    }\n}\n```\n\nWhen running the command, `-h` matches the short name of the `historyDepth` property, and `-?` displays the help screen.\n\n```\n% example -h 3\nnmap -v -sS -O 10.2.2.2\nsshnuke 10.2.2.2 -rootpw=\"Z1ON0101\"\nssh 10.2.2.2 -l root\n% example -?\nUSAGE: example --history-depth <history-depth>\n\nARGUMENTS:\n  <phrase>                The phrase to repeat.\n\nOPTIONS:\n  -h, --history-depth     The number of history entries to show.\n  -?, --help              Show help information.\n```\n\nWhen not overridden, custom help names are inherited by subcommands. In this example, the parent command defines `--help` and `-?` as its help names:\n\n```swift\nstruct Parent: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        subcommands: [Child.self],\n        helpNames: [.long, .customShort(\"?\")])\n\n    struct Child: ParsableCommand {\n        @Option(name: .shortAndLong, help: \"The host the server will run on.\")\n        var host: String\n    }\n}\n```\n\nThe `child` subcommand inherits the parent's help names, allowing the user to distinguish between the host argument (`-h`) and help (`-?`).\n\n```\n% parent child -h 192.0.0.0\n...\n% parent child -?\nUSAGE: parent child --host <host>\n\nOPTIONS:\n  -h, --host <host>       The host the server will run on.\n  -?, --help              Show help information.\n```\n\n## Hiding Commands\n\nYou may not want to show every one of your command as part of your command-line interface. To render a command invisible (but still usable), pass `shouldDisplay: false` to the ``CommandConfiguration`` initializer.\n\n## Generating Help Text Programmatically\n\nThe help screen is automatically shown to users when they call your command with the help flag. You can generate the same text from within your program by calling the `helpMessage()` method.\n\n```swift\nlet help = Repeat.helpMessage()\n// `help` matches the output above\n\nlet fortyColumnHelp = Repeat.helpMessage(columns: 40)\n// `fortyColumnHelp` is the same help screen, but wrapped to 40 columns\n```\n\nWhen generating help text for a subcommand, call `helpMessage(for:)` on the `ParsableCommand` type that represents the root of the command tree and pass the subcommand type as a parameter to ensure the correct display.\n"},{"name":"Validation","source":"# Providing Custom Validation\n\nProvide helpful feedback to users when things go wrong.\n\n## Overview\n\nWhile `ArgumentParser` validates that the inputs given by your user match the requirements and types that you define in each command, there are some requirements that can't easily be described in Swift's type system, such as the number of elements in an array, or an expected integer value.\n\n### Validating Command-Line Input\n\nTo validate your commands properties after parsing, implement the ``ParsableArguments/validate()-5r0ge`` method on any ``ParsableCommand`` or ``ParsableArguments`` type. Throwing an error from the `validate()` method causes the program to print a message to standard error and exit with an error code, preventing the `run()` method from being called with invalid inputs.\n\nHere's a command that prints out one or more random elements from the list you provide. Its `validate()` method catches three different errors that a user can make and throws a relevant error for each one.\n\n```swift\nstruct Select: ParsableCommand {\n    @Option var count: Int = 1\n    @Argument var elements: [String] = []\n\n    mutating func validate() throws {\n        guard count >= 1 else {\n            throw ValidationError(\"Please specify a 'count' of at least 1.\")\n        }\n\n        guard !elements.isEmpty else {\n            throw ValidationError(\"Please provide at least one element to choose from.\")\n        }\n\n        guard count <= elements.count else {\n            throw ValidationError(\"Please specify a 'count' less than the number of elements.\")\n        }\n    }\n\n    mutating func run() {\n        print(elements.shuffled().prefix(count).joined(separator: \"\\n\"))\n    }\n}\n```\n\nWhen you provide useful error messages, they can guide new users to success with your command-line tool!\n\n```\n% select\nError: Please provide at least one element to choose from.\nUsage: select [--count <count>] [<elements> ...]\n  See 'select --help' for more information.\n% select --count 2 hello\nError: Please specify a 'count' less than the number of elements.\nUsage: select [--count <count>] [<elements> ...]\n  See 'select --help' for more information.\n% select --count 0 hello hey hi howdy\nError: Please specify a 'count' of at least 1.\nUsage: select [--count <count>] [<elements> ...]\n  See 'select --help' for more information.\n% select --count 2 hello hey hi howdy\nhowdy\nhey\n```\n\n## Handling Post-Validation Errors\n\nThe ``ValidationError`` type is a special `ArgumentParser` error — a validation error's message is always accompanied by an appropriate usage string. You can throw other errors, from either the `validate()` or `run()` method to indicate that something has gone wrong that isn't validation-specific. Errors that conform to `CustomStringConvertible` or `LocalizedError` provide the best experience for users.\n\n```swift\nstruct LineCount: ParsableCommand {\n    @Argument var file: String\n\n    mutating func run() throws {\n        let contents = try String(contentsOfFile: file, encoding: .utf8)\n        let lines = contents.split(separator: \"\\n\")\n        print(lines.count)\n    }\n}\n```\n\nThe throwing `String(contentsOfFile:encoding:)` initializer fails when the user specifies an invalid file. `ArgumentParser` prints its error message to standard error and exits with an error code.\n\n```\n% line-count file1.swift\n37\n% line-count non-existing-file.swift\nError: The file “non-existing-file.swift” couldn’t be opened because\nthere is no such file.\n```\n\nIf you print your error output yourself, you still need to throw an error from `validate()` or `run()`, so that your command exits with the appropriate exit code. To avoid printing an extra error message, use the `ExitCode` error, which has static properties for success, failure, and validation errors, or lets you specify a specific exit code.\n\n```swift\nstruct RuntimeError: Error, CustomStringConvertible {\n    var description: String\n}\n\nstruct Example: ParsableCommand {\n    @Argument var inputFile: String\n\n    mutating func run() throws {\n        if !ExampleCore.processFile(inputFile) {\n            // ExampleCore.processFile(_:) prints its own errors\n            // and returns `false` on failure.\n            throw ExitCode.failure\n        }\n    }\n}\n```\n\n## Handling Transform Errors\n\nDuring argument and option parsing, you can use a closure to transform the command line strings to custom types. If this transformation fails, you can throw a `ValidationError`; its `message` property will be displayed to the user.\n\nIn addition, you can throw your own errors. Errors that conform to `CustomStringConvertible` or `LocalizedError` provide the best experience for users.\n\n```swift\nstruct ExampleTransformError: Error, CustomStringConvertible {\n  var description: String\n}\n\nstruct ExampleDataModel: Codable {\n  let identifier: UUID\n  let tokens: [String]\n  let tokenCount: Int\n\n  static func dataModel(_ jsonString: String) throws -> ExampleDataModel  {\n    guard let data = jsonString.data(using: .utf8) else { throw ValidationError(\"Badly encoded string, should be UTF-8\") }\n    return try JSONDecoder().decode(ExampleDataModel.self, from: data)\n  }\n}\n\nstruct Example: ParsableCommand {\n  // Reads in the argument string and attempts to transform it to\n  // an `ExampleDataModel` object using the `JSONDecoder`. If the\n  // string is not valid JSON, `decode` will throw an error and\n  // parsing will halt.\n  @Argument(transform: ExampleDataModel.dataModel)\n  var inputJSON: ExampleDataModel\n\n  // Specifiying this option will always cause the parser to exit\n  // and print the custom error.\n  @Option(transform: { throw ExampleTransformError(description: \"Trying to write to failOption always produces an error. Input: \\($0)\") })\n  var failOption: String?\n}\n```\n\nThrowing from a transform closure benefits users by providing context and can reduce development time by pinpointing issues quickly and more precisely.\n\n```\n% example '{\"Bad JSON\"}'\nError: The value '{\"Bad JSON\"}' is invalid for '<input-json>': dataCorrupted(Swift.DecodingError.Context(codingPath: [], debugDescription: \"The given data was not valid JSON.\", underlyingError: Optional(Error Domain=NSCocoaErrorDomain Code=3840 \"No value for key in object around character 11.\" UserInfo={NSDebugDescription=No value for key in object around character 11.})))\nUsage: example <input-json> --fail-option <fail-option>\n  See 'select --help' for more information.\n```\n\nWhile throwing standard library or Foundation errors adds context, custom errors provide the best experience for users and developers.\n\n```\n% example '{\"tokenCount\":0,\"tokens\":[],\"identifier\":\"F77D661C-C5B7-448E-9344-267B284F66AD\"}' --fail-option=\"Some Text Here!\"\nError: The value 'Some Text Here!' is invalid for '--fail-option <fail-option>': Trying to write to failOption always produces an error. Input: Some Text Here!\nUsage: example <input-json> --fail-option <fail-option>\n  See 'select --help' for more information.\n```\n"},{"name":"CustomizingHelp","source":"# Customizing Help\n\nSupport your users (and yourself) by providing rich help for arguments, options, and flags.\n\n## Overview\n\nYou can provide help text when declaring any `@Argument`, `@Option`, or `@Flag` by passing a string literal as the `help` parameter:\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag(help: \"Display extra information while processing.\")\n    var verbose = false\n\n    @Option(help: \"The number of extra lines to show.\")\n    var extraLines = 0\n\n    @Argument(help: \"The input file.\")\n    var inputFile: String?\n}\n```\n\nUsers see these strings in the automatically-generated help screen, which is triggered by the `-h` or `--help` flags, by default:\n\n```\n% example --help\nUSAGE: example [--verbose] [--extra-lines <extra-lines>] <input-file>\n\nARGUMENTS:\n  <input-file>            The input file.\n\nOPTIONS:\n  --verbose               Display extra information while processing.\n  --extra-lines <extra-lines>\n                          The number of extra lines to show. (default: 0)\n  -h, --help              Show help information.\n```\n\n## Customizing Help for Arguments\n\nFor more control over the help text, pass an ``ArgumentHelp`` instance instead of a string literal. The `ArgumentHelp` type can include an abstract (which is what the string literal becomes), a discussion, a value name to use in the usage string, and a visibility level for that argument.\n\nHere's the same command with some extra customization:\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag(help: \"Display extra information while processing.\")\n    var verbose = false\n\n    @Option(help: ArgumentHelp(\n        \"The number of extra lines to show.\",\n        valueName: \"n\"))\n    var extraLines = 0\n\n    @Argument(help: ArgumentHelp(\n        \"The input file.\",\n        discussion: \"If no input file is provided, the tool reads from stdin.\",\n        valueName: \"file\"))\n    var inputFile: String?\n}\n```\n\n...and the help screen:\n\n```\nUSAGE: example [--verbose] [--extra-lines <n>] [<file>]\n\nARGUMENTS:\n  <file>                  The input file.\n        If no input file is provided, the tool reads from stdin.\n\nOPTIONS:\n  --verbose               Display extra information while processing.\n  --extra-lines <n>       The number of extra lines to show. (default: 0)\n  -h, --help              Show help information.\n```\n\n### Controlling Argument Visibility\n\nYou can specify the visibility of any argument, option, or flag.\n\n```swift\nstruct Example: ParsableCommand {\n    @Flag(help: ArgumentHelp(\"Show extra info.\", visibility: .hidden))\n    var verbose: Bool = false\n\n    @Flag(help: ArgumentHelp(\"Use the legacy format.\", visibility: .private))\n    var useLegacyFormat: Bool = false\n}\n```\n\nThe `--verbose` flag is only visible in the extended help screen. The `--use-legacy-format` stays hidden even in the extended help screen, due to its `.private` visibility. \n\n```\n% example --help\nUSAGE: example\n\nOPTIONS:\n  -h, --help              Show help information.\n\n% example --help-hidden\nUSAGE: example [--verbose]\n\nOPTIONS:\n  --verbose               Show extra info.\n  -h, --help              Show help information.\n```\n\nAlternatively, you can group multiple arguments, options, and flags together as part of a ``ParsableArguments`` type, and set the visibility when including them as an `@OptionGroup` property.\n\n```swift\nstruct ExperimentalFlags: ParsableArguments {\n    @Flag(help: \"Use the remote access token. (experimental)\")\n    var experimentalUseRemoteAccessToken: Bool = false\n\n    @Flag(help: \"Use advanced security. (experimental)\")\n    var experimentalAdvancedSecurity: Bool = false\n}\n\nstruct Example: ParsableCommand {\n    @OptionGroup(visibility: .hidden)\n    var flags: ExperimentalFlags\n}\n```\n\nThe members of `ExperimentalFlags` are only shown in the extended help screen:\n\n```\n% example --help\nUSAGE: example\n\nOPTIONS:\n  -h, --help              Show help information.\n\n% example --help-hidden\nUSAGE: example [--experimental-use-remote-access-token] [--experimental-advanced-security]\n\nOPTIONS:\n  --experimental-use-remote-access-token\n                          Use the remote access token. (experimental)\n  --experimental-advanced-security\n                          Use advanced security. (experimental)\n  -h, --help              Show help information.\n```\n"},{"name":"CommandsAndSubcommands","source":"# Defining Commands and Subcommands\n\nBreak complex command-line tools into a tree of subcommands.\n\n## Overview\n\nWhen command-line programs grow larger, it can be useful to divide them into a group of smaller programs, providing an interface through subcommands. Utilities such as `git` and the Swift package manager are able to provide varied interfaces for each of their sub-functions by implementing subcommands such as `git branch` or `swift package init`.\n\nGenerally, these subcommands each have their own configuration options, as well as options that are shared across several or all aspects of the larger program.\n\nYou can build a program with commands and subcommands by defining multiple command types and specifying each command's subcommands in its configuration. For example, here's the interface of a `math` utility that performs operations on a series of values given on the command line.\n\n```\n% math add 10 15 7\n32\n% math multiply 10 15 7\n1050\n% math stats average 3 4 13 15 15\n10.0\n% math stats average --kind median 3 4 13 15 15\n13.0\n% math stats\nOVERVIEW: Calculate descriptive statistics.\n\nUSAGE: math stats <subcommand>\n\nOPTIONS:\n  -h, --help              Show help information.\n\nSUBCOMMANDS:\n  average                 Print the average of the values.\n  stdev                   Print the standard deviation of the values.\n  quantiles               Print the quantiles of the values (TBD).\n\n  See 'math help stats <subcommand>' for detailed help.\n```\n\nStart by defining the root `Math` command. You can provide a static ``ParsableCommand/configuration-35km1`` property for a command that specifies its subcommands and a default subcommand, if any.\n\n```swift\nstruct Math: ParsableCommand {\n    static var configuration = CommandConfiguration(\n        abstract: \"A utility for performing maths.\",\n        subcommands: [Add.self, Multiply.self, Statistics.self],\n        defaultSubcommand: Add.self)\n}\n```\n\n`Math` lists its three subcommands by their types; we'll see the definitions of `Add`, `Multiply`, and `Statistics` below. `Add` is also given as a default subcommand — this means that it is selected if a user leaves out a subcommand name:\n\n```\n% math 10 15 7\n32\n```\n\nNext, define a ``ParsableArguments`` type with properties that will be shared across multiple subcommands. Types that conform to `ParsableArguments` can be parsed from command-line arguments, but don't provide any execution through a `run()` method.\n\nIn this case, the `Options` type accepts a `--hexadecimal-output` flag and expects a list of integers.\n\n```swift\nstruct Options: ParsableArguments {\n    @Flag(name: [.long, .customShort(\"x\")], help: \"Use hexadecimal notation for the result.\")\n    var hexadecimalOutput = false\n\n    @Argument(help: \"A group of integers to operate on.\")\n    var values: [Int]\n}\n```\n\nIt's time to define our first two subcommands: `Add` and `Multiply`. Both of these subcommands include the arguments defined in the `Options` type by denoting that property with the `@OptionGroup` property wrapper (see ``OptionGroup``). `@OptionGroup` doesn't define any new arguments for a command; instead, it splats in the arguments defined by another `ParsableArguments` type.\n\n```swift\nextension Math {\n    struct Add: ParsableCommand {\n        static var configuration\n            = CommandConfiguration(abstract: \"Print the sum of the values.\")\n\n        @OptionGroup var options: Math.Options\n\n        mutating func run() {\n            let result = options.values.reduce(0, +)\n            print(format(result: result, usingHex: options.hexadecimalOutput))\n        }\n    }\n\n    struct Multiply: ParsableCommand {\n        static var configuration\n            = CommandConfiguration(abstract: \"Print the product of the values.\")\n\n        @OptionGroup var options: Math.Options\n\n        mutating func run() {\n            let result = options.values.reduce(1, *)\n            print(format(result: result, usingHex: options.hexadecimalOutput))\n        }\n    }\n}\n```\n\nNext, we'll define `Statistics`, the third subcommand of `Math`. The `Statistics` command specifies a custom command name (`stats`) in its configuration, overriding the default derived from the type name (`statistics`). It also declares two additional subcommands, meaning that it acts as a forked branch in the command tree, and not a leaf.\n\n```swift\nextension Math {\n    struct Statistics: ParsableCommand {\n        static var configuration = CommandConfiguration(\n            commandName: \"stats\",\n            abstract: \"Calculate descriptive statistics.\",\n            subcommands: [Average.self, StandardDeviation.self])\n    }\n}\n```\n\nLet's finish our subcommands with the `Average` and `StandardDeviation` types. Each of them has slightly different arguments, so they don't use the `Options` type defined above. Each subcommand is ultimately independent and can specify a combination of shared and unique arguments.\n\n```swift\nextension Math.Statistics {\n    struct Average: ParsableCommand {\n        static var configuration = CommandConfiguration(\n            abstract: \"Print the average of the values.\")\n\n        enum Kind: String, ExpressibleByArgument {\n            case mean, median, mode\n        }\n\n        @Option(help: \"The kind of average to provide.\")\n        var kind: Kind = .mean\n\n        @Argument(help: \"A group of floating-point values to operate on.\")\n        var values: [Double] = []\n\n        func calculateMean() -> Double { ... }\n        func calculateMedian() -> Double { ... }\n        func calculateMode() -> [Double] { ... }\n\n        mutating func run() {\n            switch kind {\n            case .mean:\n                print(calculateMean())\n            case .median:\n                print(calculateMedian())\n            case .mode:\n                let result = calculateMode()\n                    .map(String.init(describing:))\n                    .joined(separator: \" \")\n                print(result)\n            }\n        }\n    }\n\n    struct StandardDeviation: ParsableCommand {\n        static var configuration = CommandConfiguration(\n            commandName: \"stdev\",\n            abstract: \"Print the standard deviation of the values.\")\n\n        @Argument(help: \"A group of floating-point values to operate on.\")\n        var values: [Double] = []\n\n        mutating func run() {\n            if values.isEmpty {\n                print(0.0)\n            } else {\n                let sum = values.reduce(0, +)\n                let mean = sum / Double(values.count)\n                let squaredErrors = values\n                    .map { $0 - mean }\n                    .map { $0 * $0 }\n                let variance = squaredErrors.reduce(0, +) / Double(values.count)\n                let result = variance.squareRoot()\n                print(result)\n            }\n        }\n    }\n}\n```\n\nLast but not least, we add the `@main` attribute to the root of our command tree, to tell the compiler to use that as the program's entry point. Upon execution, this parses the command-line arguments, determines whether a subcommand was selected, and then instantiates and calls the `run()` method on that particular subcommand.\n\n```swift\n@main\nstruct Math: ParsableCommand {\n    // ...\n}\n```\n\nThat's it for this doubly-nested `math` command! This example is also provided as a part of the `swift-argument-parser` repository, so you can see it all together and experiment with it [here](https://github.com/apple/swift-argument-parser/blob/main/Examples/math/Math.swift).\n"}],"partitions":[{"namespace":"ArgumentParser","communities":[{"community":"protocol","startIndex":0,"endIndex":6},{"community":"associatedtype","startIndex":6,"endIndex":7},{"community":"struct","startIndex":7,"endIndex":26},{"community":"init","startIndex":26,"endIndex":74},{"community":"type.property","startIndex":74,"endIndex":116},{"community":"property","startIndex":116,"endIndex":146},{"community":"type.method","startIndex":146,"endIndex":178},{"community":"method","startIndex":178,"endIndex":183}]},{"namespace":"Swift","communities":[{"community":"init","startIndex":183,"endIndex":186}]}],"identifiers":["s14ArgumentParser013ExpressibleByA0P","s14ArgumentParser14EnumerableFlagP","s14ArgumentParser15ParsableCommandP","s14ArgumentParser17AsyncMainProtocolP","s14ArgumentParser17ParsableArgumentsP","s14ArgumentParser20AsyncParsableCommandP","s14ArgumentParser17AsyncMainProtocolP7CommandQa","s14ArgumentParser0A0V","s14ArgumentParser0A10VisibilityV","s14ArgumentParser0A20ArrayParsingStrategyV","s14ArgumentParser0A4HelpV","s14ArgumentParser11OptionGroupV","s14ArgumentParser13FlagInversionV","s14ArgumentParser14CompletionKindV","s14ArgumentParser15CompletionShellV","s14ArgumentParser15FlagExclusivityV","s14ArgumentParser15ValidationErrorV","s14ArgumentParser17NameSpecificationV","s14ArgumentParser17NameSpecificationV7ElementV","s14ArgumentParser20ArrayParsingStrategyV","s14ArgumentParser20CommandConfigurationV","s14ArgumentParser26SingleValueParsingStrategyV","s14ArgumentParser4FlagV","s14ArgumentParser6OptionV","s14ArgumentParser8ExitCodeV","s14ArgumentParser9CleanExitV","s14ArgumentParser013ExpressibleByA0P8argumentxSgSS_tcfc","s14ArgumentParser0A0V12wrappedValue4help10completion9transformACyxGx_AA0A4HelpVSgAA14CompletionKindVSgxSSKctcfc","s14ArgumentParser0A0V12wrappedValue7parsing4help10completion9transformACySayqd__GGAI_AA0A20ArrayParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgqd__SSKctcAIRszlufc","s14ArgumentParser0A0V12wrappedValue7parsing4help10completionACySayqd__GGAH_AA0A20ArrayParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgtcAHRszAA013ExpressibleByA0Rd__lufc","s14ArgumentParser0A0V4fromACyxGs7Decoder_p_tKcfc","s14ArgumentParser0A0V4help10completion9transformACyxGAA0A4HelpVSg_AA14CompletionKindVSgxSSKctcfc","s14ArgumentParser0A0V4help10completionACyqd__SgGAA0A4HelpVSg_AA14CompletionKindVSgtcAFRszAA013ExpressibleByA0Rd__lufc","s14ArgumentParser0A0V7parsing4help10completion9transformACySayqd__GGAA0A20ArrayParsingStrategyV_AA0A4HelpVSgAA14CompletionKindVSgqd__SSKctcAHRszlufc","s14ArgumentParser0A0V7parsing4help10completionACySayqd__GGAA0A20ArrayParsingStrategyV_AA0A4HelpVSgAA14CompletionKindVSgtcAGRszAA013ExpressibleByA0Rd__lufc","s14ArgumentParser0A0VA2A013ExpressibleByA0RzlE12wrappedValue4help10completionACyxGx_AA0A4HelpVSgAA14CompletionKindVSgtcfc","s14ArgumentParser0A0VA2A013ExpressibleByA0RzlE4help10completionACyxGAA0A4HelpVSg_AA14CompletionKindVSgtcfc","s14ArgumentParser0A4HelpV13stringLiteralACSS_tcfc","s14ArgumentParser0A4HelpV_10discussion9valueName10visibilityACSS_S2SSgAA0A10VisibilityVtcfc","s14ArgumentParser0A4HelpV_10discussion9valueName13shouldDisplayACSS_S2SSgSbtcfc","s14ArgumentParser11OptionGroupV10visibilityACyxGAA0A10VisibilityV_tcfc","s14ArgumentParser11OptionGroupV4fromACyxGs7Decoder_p_tKcfc","s14ArgumentParser11OptionGroupVACyxGycfc","s14ArgumentParser15CompletionShellV8rawValueACSgSS_tcfc","s14ArgumentParser15ValidationErrorVyACSScfc","s14ArgumentParser17NameSpecificationV12arrayLiteralA2C7ElementVd_tcfc","s14ArgumentParser17NameSpecificationVyACxcSTRzAC7ElementVADRtzlufc","s14ArgumentParser17ParsableArgumentsPxycfc","s14ArgumentParser20CommandConfigurationV11commandName8abstract10discussion7version13shouldDisplay11subcommands17defaultSubcommand9helpNamesACSSSg_S3SSbSayAA08ParsableC0_pXpGAaM_pXpSgAA0F13SpecificationVSgtcfc","s14ArgumentParser20CommandConfigurationV11commandName8abstract5usage10discussion7version13shouldDisplay11subcommands17defaultSubcommand9helpNamesACSSSg_SSAMS2SSbSayAA08ParsableC0_pXpGAaN_pXpSgAA0F13SpecificationVSgtcfc","s14ArgumentParser4FlagV11exclusivity4helpACyqd__SgGAA0C11ExclusivityV_AA0A4HelpVSgtcAFRszAA010EnumerableC0Rd__lufc","s14ArgumentParser4FlagV12wrappedValue4helpACySayqd__GGAF_AA0A4HelpVSgtcAFRszAA010EnumerableC0Rd__lufc","s14ArgumentParser4FlagV4fromACyxGs7Decoder_p_tKcfc","s14ArgumentParser4FlagV4helpACySayqd__GGAA0A4HelpVSg_tcAERszAA010EnumerableC0Rd__lufc","s14ArgumentParser4FlagVA2A010EnumerableC0RzlE11exclusivity4helpACyxGAA0C11ExclusivityV_AA0A4HelpVSgtcfc","s14ArgumentParser4FlagVA2A010EnumerableC0RzlE12wrappedValue11exclusivity4helpACyxGx_AA0C11ExclusivityVAA0A4HelpVSgtcfc","s14ArgumentParser4FlagVAASbRszlE12wrappedValue4name4helpACySbGSb_AA17NameSpecificationVAA0A4HelpVSgtcfc","s14ArgumentParser4FlagVAASbRszlE12wrappedValue4name9inversion11exclusivity4helpACySbGSb_AA17NameSpecificationVAA0C9InversionVAA0C11ExclusivityVAA0A4HelpVSgtcfc","s14ArgumentParser4FlagVAASbRszlE4name9inversion11exclusivity4helpACySbGAA17NameSpecificationV_AA0C9InversionVAA0C11ExclusivityVAA0A4HelpVSgtcfc","s14ArgumentParser4FlagVAASbSgRszlE4name9inversion11exclusivity4helpACyADGAA17NameSpecificationV_AA0C9InversionVAA0C11ExclusivityVAA0A4HelpVSgtcfc","s14ArgumentParser4FlagVAASiRszlE4name4helpACySiGAA17NameSpecificationV_AA0A4HelpVSgtcfc","s14ArgumentParser6OptionV12wrappedValue4name7parsing4help10completion9transformACySayqd__GGAJ_AA17NameSpecificationVAA20ArrayParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgqd__SSKctcAJRszlufc","s14ArgumentParser6OptionV12wrappedValue4name7parsing4help10completion9transformACyxGx_AA17NameSpecificationVAA06SingleE15ParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgxSSKctcfc","s14ArgumentParser6OptionV12wrappedValue4name7parsing4help10completionACySayqd__GGAI_AA17NameSpecificationVAA20ArrayParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgtcAIRszAA013ExpressibleByA0Rd__lufc","s14ArgumentParser6OptionV4fromACyxGs7Decoder_p_tKcfc","s14ArgumentParser6OptionV4name7parsing4help10completion9transformACySayqd__GGAA17NameSpecificationV_AA20ArrayParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgqd__SSKctcAIRszlufc","s14ArgumentParser6OptionV4name7parsing4help10completion9transformACyxGAA17NameSpecificationV_AA26SingleValueParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgxSSKctcfc","s14ArgumentParser6OptionV4name7parsing4help10completionACySayqd__GGAA17NameSpecificationV_AA20ArrayParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgtcAHRszAA013ExpressibleByA0Rd__lufc","s14ArgumentParser6OptionV4name7parsing4help10completionACyqd__SgGAA17NameSpecificationV_AA26SingleValueParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgtcAHRszAA013ExpressibleByA0Rd__lufc","s14ArgumentParser6OptionVA2A013ExpressibleByA0RzlE12wrappedValue4name7parsing10completion4helpACyxGx_AA17NameSpecificationVAA06SingleG15ParsingStrategyVAA14CompletionKindVSgAA0A4HelpVSgtcfc","s14ArgumentParser6OptionVA2A013ExpressibleByA0RzlE12wrappedValue4name7parsing4help10completionACyxGx_AA17NameSpecificationVAA06SingleG15ParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgtcfc","s14ArgumentParser6OptionVA2A013ExpressibleByA0RzlE4name7parsing4help10completionACyxGAA17NameSpecificationV_AA26SingleValueParsingStrategyVAA0A4HelpVSgAA14CompletionKindVSgtcfc","s14ArgumentParser8ExitCodeV8rawValueACs5Int32V_tcfc","s14ArgumentParser8ExitCodeVyACs5Int32Vcfc","s14ArgumentParser013ExpressibleByA0P15allValueStringsSaySSGvpZ","s14ArgumentParser013ExpressibleByA0P21defaultCompletionKindAA0fG0VvpZ","s14ArgumentParser013ExpressibleByA0PAAE15allValueStringsSaySSGvpZ","s14ArgumentParser013ExpressibleByA0PAAE21defaultCompletionKindAA0fG0VvpZ","s14ArgumentParser013ExpressibleByA0PAAs12CaseIterableRzSYRzSS8RawValueSYRtzrlE03allH7StringsSaySSGvpZ","s14ArgumentParser013ExpressibleByA0PAAs12CaseIterableRzrlE15allValueStringsSaySSGvpZ","s14ArgumentParser013ExpressibleByA0PAAs12CaseIterableRzrlE21defaultCompletionKindAA0hI0VvpZ","s14ArgumentParser0A10VisibilityV6hiddenACvpZ","s14ArgumentParser0A10VisibilityV7defaultACvpZ","s14ArgumentParser0A10VisibilityV7privateACvpZ","s14ArgumentParser0A20ArrayParsingStrategyV22unconditionalRemainingACvpZ","s14ArgumentParser0A20ArrayParsingStrategyV9remainingACvpZ","s14ArgumentParser0A4HelpV6hiddenACvpZ","s14ArgumentParser0A4HelpV7privateACvpZ","s14ArgumentParser13FlagInversionV10prefixedNoACvpZ","s14ArgumentParser13FlagInversionV21prefixedEnableDisableACvpZ","s14ArgumentParser14CompletionKindV7defaultACvpZ","s14ArgumentParser14CompletionKindV9directoryACvpZ","s14ArgumentParser15CompletionShellV3zshACvpZ","s14ArgumentParser15CompletionShellV4bashACvpZ","s14ArgumentParser15CompletionShellV4fishACvpZ","s14ArgumentParser15CompletionShellV8allCasesSayACGvpZ","s14ArgumentParser15FlagExclusivityV10chooseLastACvpZ","s14ArgumentParser15FlagExclusivityV11chooseFirstACvpZ","s14ArgumentParser15FlagExclusivityV9exclusiveACvpZ","s14ArgumentParser15ParsableCommandP13configurationAA0D13ConfigurationVvpZ","s14ArgumentParser15ParsableCommandPAAE13configurationAA0D13ConfigurationVvpZ","s14ArgumentParser17NameSpecificationV12shortAndLongACvpZ","s14ArgumentParser17NameSpecificationV4longACvpZ","s14ArgumentParser17NameSpecificationV5shortACvpZ","s14ArgumentParser17NameSpecificationV7ElementV4longAEvpZ","s14ArgumentParser17NameSpecificationV7ElementV5shortAEvpZ","s14ArgumentParser20ArrayParsingStrategyV11singleValueACvpZ","s14ArgumentParser20ArrayParsingStrategyV14upToNextOptionACvpZ","s14ArgumentParser20ArrayParsingStrategyV24unconditionalSingleValueACvpZ","s14ArgumentParser20ArrayParsingStrategyV9remainingACvpZ","s14ArgumentParser26SingleValueParsingStrategyV011scanningForD0ACvpZ","s14ArgumentParser26SingleValueParsingStrategyV13unconditionalACvpZ","s14ArgumentParser26SingleValueParsingStrategyV4nextACvpZ","s14ArgumentParser8ExitCodeV17validationFailureACvpZ","s14ArgumentParser8ExitCodeV7failureACvpZ","s14ArgumentParser8ExitCodeV7successACvpZ","s14ArgumentParser013ExpressibleByA0P23defaultValueDescriptionSSvp","s14ArgumentParser013ExpressibleByA0PAAE23defaultValueDescriptionSSvp","s14ArgumentParser0A0V11descriptionSSvp","s14ArgumentParser0A0V12wrappedValuexvp","s14ArgumentParser0A4HelpV10discussionSSvp","s14ArgumentParser0A4HelpV10visibilityAA0A10VisibilityVvp","s14ArgumentParser0A4HelpV13shouldDisplaySbvp","s14ArgumentParser0A4HelpV8abstractSSvp","s14ArgumentParser0A4HelpV9valueNameSSSgvp","s14ArgumentParser11OptionGroupV11descriptionSSvp","s14ArgumentParser11OptionGroupV12wrappedValuexvp","s14ArgumentParser15CompletionShellV8rawValueSSvp","s14ArgumentParser15ValidationErrorV11descriptionSSvp","s14ArgumentParser15ValidationErrorV7messageSSvp","s14ArgumentParser20CommandConfigurationV10discussionSSvp","s14ArgumentParser20CommandConfigurationV11commandNameSSSgvp","s14ArgumentParser20CommandConfigurationV11subcommandsSayAA08ParsableC0_pXpGvp","s14ArgumentParser20CommandConfigurationV13shouldDisplaySbvp","s14ArgumentParser20CommandConfigurationV17defaultSubcommandAA08ParsableC0_pXpSgvp","s14ArgumentParser20CommandConfigurationV5usageSSSgvp","s14ArgumentParser20CommandConfigurationV7versionSSvp","s14ArgumentParser20CommandConfigurationV8abstractSSvp","s14ArgumentParser20CommandConfigurationV9helpNamesAA17NameSpecificationVSgvp","s14ArgumentParser4FlagV11descriptionSSvp","s14ArgumentParser4FlagV12wrappedValuexvp","s14ArgumentParser6OptionV11descriptionSSvp","s14ArgumentParser6OptionV12wrappedValuexvp","s14ArgumentParser8ExitCodeV8rawValues5Int32Vvp","s14ArgumentParser8ExitCodeV9isSuccessSbvp","s14ArgumentParser9CleanExitV11descriptionSSvp","s14ArgumentParser14CompletionKindV12shellCommandyACSSFZ","s14ArgumentParser14CompletionKindV4file10extensionsACSaySSG_tFZ","s14ArgumentParser14CompletionKindV4listyACSaySSGFZ","s14ArgumentParser14CompletionKindV6customyACSaySSGAEcFZ","s14ArgumentParser14EnumerableFlagP4help3forAA0A4HelpVSgx_tFZ","s14ArgumentParser14EnumerableFlagP4name3forAA17NameSpecificationVx_tFZ","s14ArgumentParser14EnumerableFlagPAAE4help3forAA0A4HelpVSgx_tFZ","s14ArgumentParser14EnumerableFlagPAAE4name3forAA17NameSpecificationVx_tFZ","s14ArgumentParser15CompletionShellV12autodetectedACSgyFZ","s14ArgumentParser15ParsableCommandPAAE11helpMessage3for13includeHidden7columnsSSAaB_pXp_SbSiSgtFZ","s14ArgumentParser15ParsableCommandPAAE11helpMessage3for7columnsSSAaB_pXp_SiSgtFZ","s14ArgumentParser15ParsableCommandPAAE11parseAsRootyAaB_pSaySSGSgKFZ","s14ArgumentParser15ParsableCommandPAAE4mainyyFZ","s14ArgumentParser15ParsableCommandPAAE4mainyySaySSGSgFZ","s14ArgumentParser17AsyncMainProtocolPAAE4mainyyYaFZ","s14ArgumentParser17NameSpecificationV10customLong_14withSingleDashACSS_SbtFZ","s14ArgumentParser17NameSpecificationV11customShort_14allowingJoinedACSJ_SbtFZ","s14ArgumentParser17NameSpecificationV7ElementV10customLong_14withSingleDashAESS_SbtFZ","s14ArgumentParser17NameSpecificationV7ElementV11customShort_14allowingJoinedAESJ_SbtFZ","s14ArgumentParser17ParsableArgumentsPAAE11fullMessage3forSSs5Error_p_tFZ","s14ArgumentParser17ParsableArgumentsPAAE11helpMessage13includeHidden7columnsSSSb_SiSgtFZ","s14ArgumentParser17ParsableArgumentsPAAE11helpMessage7columnsSSSiSg_tFZ","s14ArgumentParser17ParsableArgumentsPAAE11parseOrExityxSaySSGSgFZ","s14ArgumentParser17ParsableArgumentsPAAE16completionScript3forSSAA15CompletionShellV_tFZ","s14ArgumentParser17ParsableArgumentsPAAE4exit9withErrors5NeverOs0G0_pSg_tFZ","s14ArgumentParser17ParsableArgumentsPAAE5parseyxSaySSGSgKFZ","s14ArgumentParser17ParsableArgumentsPAAE7message3forSSs5Error_p_tFZ","s14ArgumentParser17ParsableArgumentsPAAE8exitCode3forAA04ExitF0Vs5Error_p_tFZ","s14ArgumentParser20AsyncParsableCommandPAAE4mainyyYaFZ","s14ArgumentParser9CleanExitV11helpRequestyAcA15ParsableCommand_pFZ","s14ArgumentParser9CleanExitV11helpRequestyAcA15ParsableCommand_pXpSgFZ","s14ArgumentParser9CleanExitV7messageyACSSFZ","s14ArgumentParser15ParsableCommandP3runyyKF","s14ArgumentParser15ParsableCommandPAAE3runyyKF","s14ArgumentParser17ParsableArgumentsP8validateyyKF","s14ArgumentParser17ParsableArgumentsPAAE8validateyyKF","s14ArgumentParser20AsyncParsableCommandP3runyyYaKF","sSS14ArgumentParserE8argumentSSSgSS_tcfc","sSY14ArgumentParserAA013ExpressibleByA0RzAaB8RawValueSYRpzrlE8argumentxSgSS_tcfc","ss25LosslessStringConvertibleP14ArgumentParserAC013ExpressibleByD0RzrlE8argumentxSgSS_tcfc","sSH","sSJ","sSL1goiySbx_xtFZ","sSL1loiySbx_xtFZ","sSL2geoiySbx_xtFZ","sSL2leoiySbx_xtFZ","sSLsE1goiySbx_xtFZ","sSLsE2geoiySbx_xtFZ","sSLsE2leoiySbx_xtFZ","sSLsE3zzloiySnyxGx_xtFZ","sSLsE3zzlopys16PartialRangeUpToVyxGxFZ","sSLsE3zzzoPys16PartialRangeFromVyxGxFZ","sSLsE3zzzoiySNyxGx_xtFZ","sSLsE3zzzopys19PartialRangeThroughVyxGxFZ","sSQ","sSQ2eeoiySbx_xtFZ","sSQsE2neoiySbx_xtFZ","sSS","sST","sSUsE8isSignedSbvpZ","sSUsE9magnitudexvp","sSUss17FixedWidthIntegerRzrlE3maxxvpZ","sSUss17FixedWidthIntegerRzrlE3minxvpZ","sSUss17FixedWidthIntegerRzrlE7exactlyxSgqd___tcSzRd__lufc","sSUss17FixedWidthIntegerRzrlEyxqd__cSzRd__lufc","sSY","sSY8rawValue03RawB0Qzvp","sSY8rawValuexSg03RawB0Qz_tcfc","sSYsSHRzSH8RawValueSYRpzrlE04hashB0Sivp","sSYsSHRzSH8RawValueSYRpzrlE4hash4intoys6HasherVz_tF","sSZsE8isSignedSbvpZ","sSZss17FixedWidthIntegerRzrlE10isMultiple2ofSbx_tF","sSZss17FixedWidthIntegerRzrlE3maxxvpZ","sSZss17FixedWidthIntegerRzrlE3minxvpZ","sSZss17FixedWidthIntegerRzrlE7exactlyxSgqd___tcSzRd__lufc","sSZss17FixedWidthIntegerRzrlEyxqd__cSzRd__lufc","sSa","sSb","sSd","sSe","sSe4fromxs7Decoder_p_tKcfc","sSf","sSi","sSq","sSu","sSxsE1loiySbx_xtFZ","sSxsE2eeoiySbx_xtFZ","sSz10isMultiple2ofSbx_tF","sSz12_RegexParserE9assertingxqd___tcSzRd__lufc","sSz3ggeoiyyxz_qd__tSzRd__lFZ","sSz3lleoiyyxz_qd__tSzRd__lFZ","sSzsE10isMultiple2ofSbx_tF","sSzsE11descriptionSSvp","sSzsE1aoiyxx_xtFZ","sSzsE1goiySbx_qd__tSzRd__lFZ","sSzsE1goiySbx_xtFZ","sSzsE1loiySbx_qd__tSzRd__lFZ","sSzsE1ooiyxx_xtFZ","sSzsE1xoiyxx_xtFZ","sSzsE20quotientAndRemainder10dividingByx0A0_x9remaindertx_tF","sSzsE2eeoiySbx_qd__tSzRd__lFZ","sSzsE2geoiySbx_qd__tSzRd__lFZ","sSzsE2geoiySbx_xtFZ","sSzsE2ggoiyxx_qd__tSzRd__lFZ","sSzsE2leoiySbx_qd__tSzRd__lFZ","sSzsE2leoiySbx_xtFZ","sSzsE2lloiyxx_qd__tSzRd__lFZ","sSzsE2neoiySbx_qd__tSzRd__lFZ","sSzsE2neoiySbx_xtFZ","sSzsE8advanced2byxSi_tF","sSzsE8distance2toSix_tF","sSzsExycfc","ss12CaseIterableP","ss12CaseIterableP8allCases03AllD0QzvpZ","ss13SignedNumericPsE1sopyxxFZ","ss13SignedNumericPsE6negateyyF","ss17FixedWidthIntegerPsE03bitB0Sivp","ss17FixedWidthIntegerPsE12littleEndianxvp","ss17FixedWidthIntegerPsE12littleEndianxx_tcfc","ss17FixedWidthIntegerPsE18truncatingIfNeededxqd___tcSzRd__lufc","ss17FixedWidthIntegerPsE1topyxxFZ","ss17FixedWidthIntegerPsE2amoiyxx_xtFZ","ss17FixedWidthIntegerPsE2apoiyxx_xtFZ","ss17FixedWidthIntegerPsE2asoiyxx_xtFZ","ss17FixedWidthIntegerPsE2ggoiyxx_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE2lloiyxx_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE3aggoiyxx_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE3aggoiyxx_xtFZ","ss17FixedWidthIntegerPsE3alloiyxx_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE3alloiyxx_xtFZ","ss17FixedWidthIntegerPsE3ameoiyyxz_xtFZ","ss17FixedWidthIntegerPsE3apeoiyyxz_xtFZ","ss17FixedWidthIntegerPsE3aseoiyyxz_xtFZ","ss17FixedWidthIntegerPsE3ggeoiyyxz_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE3lleoiyyxz_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE4aggeoiyyxz_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE4alleoiyyxz_qd__tSzRd__lFZ","ss17FixedWidthIntegerPsE6random2in5usingxSNyxG_qd__ztSGRd__lFZ","ss17FixedWidthIntegerPsE6random2in5usingxSnyxG_qd__ztSGRd__lFZ","ss17FixedWidthIntegerPsE6random2inxSNyxG_tFZ","ss17FixedWidthIntegerPsE6random2inxSnyxG_tFZ","ss17FixedWidthIntegerPsE7exactlyxSgqd___tcSBRd__lufc","ss17FixedWidthIntegerPsE8clampingxqd___tcSzRd__lufc","ss17FixedWidthIntegerPsE9bigEndianxvp","ss17FixedWidthIntegerPsE9bigEndianxx_tcfc","ss17FixedWidthIntegerPsE_5radixxSgqd___SitcSyRd__lufc","ss17FixedWidthIntegerPsEyxSgSScfc","ss17FixedWidthIntegerPsEyxqd__cSBRd__lufc","ss18AdditiveArithmeticP2peoiyyxz_xtFZ","ss18AdditiveArithmeticP2seoiyyxz_xtFZ","ss18AdditiveArithmeticPsE1popyxxFZ","ss18AdditiveArithmeticPsE2peoiyyxz_xtFZ","ss18AdditiveArithmeticPsE2seoiyyxz_xtFZ","ss18AdditiveArithmeticPss27ExpressibleByIntegerLiteralRzrlE4zeroxvpZ","ss23CustomStringConvertibleP","ss23CustomStringConvertibleP11descriptionSSvp","ss23CustomStringConvertibleP12_RegexParserE21halfWidthCornerQuotedSSvp","ss25ExpressibleByArrayLiteralP","ss25ExpressibleByArrayLiteralP05arrayD0x0cD7ElementQzd_tcfc","ss25LosslessStringConvertibleP","ss26ExpressibleByStringLiteralP","ss26ExpressibleByStringLiteralP06stringD0x0cD4TypeQz_tcfc","ss26ExpressibleByStringLiteralPs0cD4TypeQz023ExtendedGraphemeClusterdE0RtzrlE08extendedghD0xAF_tcfc","ss27ExpressibleByIntegerLiteralP07integerD0x0cD4TypeQz_tcfc","ss27ExpressibleByIntegerLiteralPss01_ab7BuiltincD0RzrlE07integerD0xx_tcfc","ss32ExpressibleByStringInterpolationP","ss32ExpressibleByStringInterpolationPss07DefaultcD0V0cD0RtzrlE06stringD0xAD_tcfc","ss33ExpressibleByUnicodeScalarLiteralP","ss33ExpressibleByUnicodeScalarLiteralP07unicodedE0x0cdE4TypeQz_tcfc","ss43ExpressibleByExtendedGraphemeClusterLiteralP","ss43ExpressibleByExtendedGraphemeClusterLiteralP08extendeddeF0x0cdeF4TypeQz_tcfc","ss43ExpressibleByExtendedGraphemeClusterLiteralPs013UnicodeScalarF4TypeQz0cdefI0RtzrlE07unicodehF0xAF_tcfc","ss4Int8V","ss5ErrorP","ss5ErrorP10FoundationE20localizedDescriptionSSvp","ss5Int16V","ss5Int32V","ss5Int64V","ss5NeverO","ss5UInt8V","ss6UInt16V","ss6UInt32V","ss6UInt64V","ss7DecoderP","ss8SendableP"],"vertices":[{"p":["ExpressibleByArgument"],"f":[["protocol",12],[" ",17],["ExpressibleByArgument",7]],"s":[["protocol",12],[" ",17],["ExpressibleByArgument",7]],"d":"A type that can be expressed as a command-line argument."},{"p":["EnumerableFlag"],"f":[["protocol",12],[" ",17],["EnumerableFlag",7],[" : ",17],["CaseIterable",18,258],[", ",17],["Equatable",18,200]],"s":[["protocol",12],[" ",17],["EnumerableFlag",7]],"d":"A type that represents the different possible flags to be used by a\n`@Flag` property.\n\nFor example, the `Size` enumeration declared here can be used as the type of\na `@Flag` property:\n\n    enum Size: String, EnumerableFlag {\n        case small, medium, large, extraLarge\n    }\n\n    struct Example: ParsableCommand {\n        @Flag var sizes: [Size]\n\n        mutating func run() {\n            print(sizes)\n        }\n    }\n\nBy default, each case name is converted to a flag by using the `.long` name\nspecification, so a user can call `example` like this:\n\n    $ example --small --large\n    [.small, .large]\n\nProvide alternative or additional name specifications for each case by\nimplementing the `name(for:)` static method on your `EnumerableFlag` type.\n\n    extension Size {\n        static func name(for value: Self) -> NameSpecification {\n            switch value {\n            case .extraLarge:\n                return [.customShort(\"x\"), .long]\n            default:\n                return .shortAndLong\n            }\n        }\n    }\n\nWith this extension, a user can use short or long versions of the flags:\n\n    $ example -s -l -x --medium\n    [.small, .large, .extraLarge, .medium]"},{"p":["ParsableCommand"],"f":[["protocol",12],[" ",17],["ParsableCommand",7],[" : ",17],["ParsableArguments",18,4]],"s":[["protocol",12],[" ",17],["ParsableCommand",7]],"d":"A type that can be executed as part of a nested tree of commands."},{"p":["AsyncMainProtocol"],"f":[["protocol",12],[" ",17],["AsyncMainProtocol",7]],"s":[["protocol",12],[" ",17],["AsyncMainProtocol",7]],"a":{"s":{"d":"5.6","m":"Use @main directly on your root `AsyncParsableCommand` type."}},"d":"A type that can designate an `AsyncParsableCommand` as the program's\nentry point.\n\nSee the ``AsyncParsableCommand`` documentation for usage information."},{"p":["ParsableArguments"],"f":[["protocol",12],[" ",17],["ParsableArguments",7],[" : ",17],["Decodable",18,225]],"s":[["protocol",12],[" ",17],["ParsableArguments",7]],"d":"A type that can be parsed from a program's command-line arguments.\n\nWhen you implement a `ParsableArguments` type, all properties must be declared with\none of the four property wrappers provided by the `ArgumentParser` library."},{"p":["AsyncParsableCommand"],"f":[["protocol",12],[" ",17],["AsyncParsableCommand",7],[" : ",17],["ParsableCommand",18,2]],"s":[["protocol",12],[" ",17],["AsyncParsableCommand",7]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"macCatalyst":{"i":"13"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"A type that can be executed asynchronously, as part of a nested tree of\ncommands."},{"p":["AsyncMainProtocol","Command"],"f":[["associatedtype",12],[" ",17],["Command",7],[" : ",17],["ParsableCommand",18,2]],"s":[["associatedtype",12],[" ",17],["Command",7],[" : ",17],["ParsableCommand",18]],"a":{"s":{"d":"5.6","m":"Use @main directly on your root `AsyncParsableCommand` type."}}},{"p":["Argument"],"f":[["@propertyWrapper",3],[" ",17],["struct",12],[" ",17],["Argument",7],["<",17],["Value",0],[">",17]],"s":[["struct",12],[" ",17],["Argument",7]],"g":[["Value",0,0]],"d":"A property wrapper that represents a positional command-line argument.\n\nUse the `@Argument` wrapper to define a property of your custom command as\na positional argument. A *positional argument* for a command-line tool is\nspecified without a label and must appear in declaration order. `@Argument`\nproperties with `Optional` type or a default value are optional for the user\nof your command-line tool.\n\nFor example, the following program has two positional arguments. The `name`\nargument is required, while `greeting` is optional because it has a default\nvalue.\n\n    @main\n    struct Greet: ParsableCommand {\n        @Argument var name: String\n        @Argument var greeting: String = \"Hello\"\n\n        mutating func run() {\n            print(\"\\(greeting) \\(name)!\")\n        }\n    }\n\nYou can call this program with just a name or with a name and a\ngreeting. When you supply both arguments, the first argument is always\ntreated as the name, due to the order of the property declarations.\n\n    $ greet Nadia\n    Hello Nadia!\n    $ greet Tamara Hi\n    Hi Tamara!"},{"p":["ArgumentVisibility"],"f":[["struct",12],[" ",17],["ArgumentVisibility",7]],"s":[["struct",12],[" ",17],["ArgumentVisibility",7]],"d":"Visibility level of an argument's help."},{"p":["ArgumentArrayParsingStrategy"],"f":[["struct",12],[" ",17],["ArgumentArrayParsingStrategy",7]],"s":[["struct",12],[" ",17],["ArgumentArrayParsingStrategy",7]],"d":"The strategy to use when parsing multiple values from positional arguments\ninto an array."},{"p":["ArgumentHelp"],"f":[["struct",12],[" ",17],["ArgumentHelp",7]],"s":[["struct",12],[" ",17],["ArgumentHelp",7]],"d":"Help information for a command-line argument."},{"p":["OptionGroup"],"f":[["@propertyWrapper",3],[" ",17],["struct",12],[" ",17],["OptionGroup",7],["<",17],["Value",0],["> ",17],["where",12],[" ",17],["Value",18],[" : ",17],["ParsableArguments",18,4]],"s":[["struct",12],[" ",17],["OptionGroup",7]],"c":[["Value",1,"ParsableArguments",4]],"g":[["Value",0,0]],"d":"A wrapper that transparently includes a parsable type.\n\nUse an option group to include a group of options, flags, or arguments\ndeclared in a parsable type.\n\n    struct GlobalOptions: ParsableArguments {\n        @Flag(name: .shortAndLong)\n        var verbose: Bool\n\n        @Argument var values: [Int]\n    }\n\n    struct Options: ParsableArguments {\n        @Option var name: String\n        @OptionGroup var globals: GlobalOptions\n    }\n\nThe flag and positional arguments declared as part of `GlobalOptions` are\nincluded when parsing `Options`."},{"p":["FlagInversion"],"f":[["struct",12],[" ",17],["FlagInversion",7]],"s":[["struct",12],[" ",17],["FlagInversion",7]],"d":"The options for converting a Boolean flag into a `true`/`false` pair."},{"p":["CompletionKind"],"f":[["struct",12],[" ",17],["CompletionKind",7]],"s":[["struct",12],[" ",17],["CompletionKind",7]],"d":"The type of completion to use for an argument or option."},{"p":["CompletionShell"],"f":[["struct",12],[" ",17],["CompletionShell",7]],"s":[["struct",12],[" ",17],["CompletionShell",7]],"d":"A shell for which the parser can generate a completion script."},{"p":["FlagExclusivity"],"f":[["struct",12],[" ",17],["FlagExclusivity",7]],"s":[["struct",12],[" ",17],["FlagExclusivity",7]],"d":"The options for treating enumeration-based flags as exclusive."},{"p":["ValidationError"],"f":[["struct",12],[" ",17],["ValidationError",7]],"s":[["struct",12],[" ",17],["ValidationError",7]],"d":"An error type that is presented to the user as an error with parsing their\ncommand-line input."},{"p":["NameSpecification"],"f":[["struct",12],[" ",17],["NameSpecification",7]],"s":[["struct",12],[" ",17],["NameSpecification",7]],"d":"A specification for how to represent a property as a command-line argument\nlabel."},{"p":["NameSpecification","Element"],"f":[["struct",12],[" ",17],["Element",7]],"s":[["struct",12],[" ",17],["Element",7]],"d":"An individual property name translation."},{"p":["ArrayParsingStrategy"],"f":[["struct",12],[" ",17],["ArrayParsingStrategy",7]],"s":[["struct",12],[" ",17],["ArrayParsingStrategy",7]],"d":"The strategy to use when parsing multiple values from `@Option` arguments into an\narray."},{"p":["CommandConfiguration"],"f":[["struct",12],[" ",17],["CommandConfiguration",7]],"s":[["struct",12],[" ",17],["CommandConfiguration",7]],"d":"The configuration for a command."},{"p":["SingleValueParsingStrategy"],"f":[["struct",12],[" ",17],["SingleValueParsingStrategy",7]],"s":[["struct",12],[" ",17],["SingleValueParsingStrategy",7]],"d":"The strategy to use when parsing a single value from `@Option` arguments.\n\n- SeeAlso: ``ArrayParsingStrategy``"},{"p":["Flag"],"f":[["@propertyWrapper",3],[" ",17],["struct",12],[" ",17],["Flag",7],["<",17],["Value",0],[">",17]],"s":[["struct",12],[" ",17],["Flag",7]],"g":[["Value",0,0]],"d":"A property wrapper that represents a command-line flag.\n\nUse the `@Flag` wrapper to define a property of your custom type as a\ncommand-line flag. A *flag* is a dash-prefixed label that can be provided on\nthe command line, such as `-d` and `--debug`.\n\nFor example, the following program declares a flag that lets a user indicate\nthat seconds should be included when printing the time.\n\n    @main\n    struct Time: ParsableCommand {\n        @Flag var includeSeconds = false\n\n        mutating func run() {\n            if includeSeconds {\n                print(Date.now.formatted(.dateTime.hour().minute().second()))\n            } else {\n                print(Date.now.formatted(.dateTime.hour().minute()))\n            }\n        }\n    }\n\n`includeSeconds` has a default value of `false`, but becomes `true` if\n`--include-seconds` is provided on the command line.\n\n    $ time\n    11:09 AM\n    $ time --include-seconds\n    11:09:15 AM\n\nA flag can have a value that is a `Bool`, an `Int`, or any `EnumerableFlag`\ntype. When using an `EnumerableFlag` type as a flag, the individual cases\nform the flags that are used on the command line.\n\n    @main\n    struct Math: ParsableCommand {\n        enum Operation: EnumerableFlag {\n            case add\n            case multiply\n        }\n\n        @Flag var operation: Operation\n\n        mutating func run() {\n            print(\"Time to \\(operation)!\")\n        }\n    }\n\nInstead of using the name of the `operation` property as the flag in this\ncase, the two cases of the `Operation` enumeration become valid flags.\nThe `operation` property is neither optional nor given a default value, so\none of the two flags is required.\n\n    $ math --add\n    Time to add!\n    $ math\n    Error: Missing one of: '--add', '--multiply'"},{"p":["Option"],"f":[["@propertyWrapper",3],[" ",17],["struct",12],[" ",17],["Option",7],["<",17],["Value",0],[">",17]],"s":[["struct",12],[" ",17],["Option",7]],"g":[["Value",0,0]],"d":"A property wrapper that represents a command-line option.\n\nUse the `@Option` wrapper to define a property of your custom command as a\ncommand-line option. An *option* is a named value passed to a command-line\ntool, like `--configuration debug`. Options can be specified in any order.\n\nAn option can have a default value specified as part of its\ndeclaration; options with optional `Value` types implicitly have `nil` as\ntheir default value. Options that are neither declared as `Optional` nor\ngiven a default value are required for users of your command-line tool.\n\nFor example, the following program defines three options:\n\n    @main\n    struct Greet: ParsableCommand {\n        @Option var greeting = \"Hello\"\n        @Option var age: Int?\n        @Option var name: String\n\n        mutating func run() {\n            print(\"\\(greeting) \\(name)!\")\n            if let age = age {\n                print(\"Congrats on making it to the ripe old age of \\(age)!\")\n            }\n        }\n    }\n\n`greeting` has a default value of `\"Hello\"`, which can be overridden by\nproviding a different string as an argument, while `age` defaults to `nil`.\n`name` is a required option because it is non-`nil` and has no default\nvalue.\n\n    $ greet --name Alicia\n    Hello Alicia!\n    $ greet --age 28 --name Seungchin --greeting Hi\n    Hi Seungchin!\n    Congrats on making it to the ripe old age of 28!"},{"p":["ExitCode"],"f":[["struct",12],[" ",17],["ExitCode",7]],"s":[["struct",12],[" ",17],["ExitCode",7]],"d":"An error type that only includes an exit code.\n\nIf you're printing custom error messages yourself, you can throw this error\nto specify the exit code without adding any additional output to standard\nout or standard error."},{"p":["CleanExit"],"f":[["struct",12],[" ",17],["CleanExit",7]],"s":[["struct",12],[" ",17],["CleanExit",7]],"d":"An error type that represents a clean (i.e. non-error state) exit of the\nutility.\n\nThrowing a `CleanExit` instance from a `validate` or `run` method, or\npassing it to `exit(with:)`, exits the program with exit code `0`."},{"p":["ExpressibleByArgument","init(argument:)"],"f":[["init",10],["?(",17],["argument",1],[": ",17],["String",18,203],[")",17]],"s":[["init",10],["?(",17],["argument",1],[": ",17],["String",18],[")",17]],"d":"Creates a new instance of this type from a command-line-specified\nargument."},{"p":["Argument","init(wrappedValue:help:completion:transform:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"g":[["Value",0,0]],"d":"Creates a property with a default value provided by standard Swift default value syntax, parsing with the given closure.\n\nThis method is called to initialize an `Argument` with a default value such as:\n```swift\n@Argument(transform: baz)\nvar foo: String = \"bar\"\n```\n\n- Parameters:\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - help: Information about how to use this argument.\n  - transform: A closure that converts a string into this property's type or throws an error."},{"p":["Argument","init(wrappedValue:parsing:help:completion:transform:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArgumentArrayParsingStrategy",18,9],[" = .remaining, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Element",18],[") ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["]",17]],"s":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["parsing",1],[": ",17],["ArgumentArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Element",18],[")",17]],"c":[["Value",2,"[Element]",222]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates a property that reads an array from zero or more arguments,\nparsing each element with the given closure.\n\n- Parameters:\n  - initial: A default value to use for this property.\n  - parsingStrategy: The behavior to use when parsing multiple values\n    from the command-line arguments.\n  - help: Information about how to use this argument.\n  - transform: A closure that converts a string into this property's\n    element type or throws an error."},{"p":["Argument","init(wrappedValue:parsing:help:completion:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArgumentArrayParsingStrategy",18,9],[" = .remaining, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["], ",17],["Element",18],[" : ",17],["ExpressibleByArgument",18,0]],"s":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["parsing",1],[": ",17],["ArgumentArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"c":[["Value",2,"[Element]",222],["Element",1,"ExpressibleByArgument",0]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates a property that reads an array from zero or more arguments.\n\n- Parameters:\n  - initial: A default value to use for this property.\n  - parsingStrategy: The behavior to use when parsing multiple values\n    from the command-line arguments.\n  - help: Information about how to use this argument."},{"p":["Argument","init(from:)"],"f":[["init",10],["(",17],["from",1],[" ",17],["decoder",2],[": ",17],["Decoder",18,329],[") ",17],["throws",12]],"s":[["init",10],["(",17],["from",1],[": ",17],["Decoder",18],[") ",17],["throws",12]],"g":[["Value",0,0]],"o":226},{"p":["Argument","init(help:completion:transform:)"],"f":[["init",10],["(",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"s":[["init",10],["(",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"g":[["Value",0,0]],"d":"Creates a property with no default value, parsing with the given closure.\n\nThis method is called to initialize an `Argument` with no default value such as:\n```swift\n@Argument(transform: baz)\nvar foo: String\n```\n\n- Parameters:\n  - help: Information about how to use this argument.\n  - transform: A closure that converts a string into this property's type or throws an error."},{"p":["Argument","init(help:completion:)"],"f":[["init",10],["<",17],["T",0],[">(",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == ",17],["T",18],["?, ",17],["T",18],[" : ",17],["ExpressibleByArgument",18,0]],"s":[["init",10],["<",17],["T",0],[">(",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"c":[["Value",2,"T?",229],["T",1,"ExpressibleByArgument",0]],"g":[["Value",0,0],["T",0,1]],"d":"Creates an optional property that reads its value from an argument.\n\nThe argument is optional for the caller of the command and defaults to \n`nil`.\n\n- Parameter help: Information about how to use this argument."},{"p":["Argument","init(parsing:help:completion:transform:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArgumentArrayParsingStrategy",18,9],[" = .remaining, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Element",18],[") ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["]",17]],"s":[["init",10],["<",17],["Element",0],[">(",17],["parsing",1],[": ",17],["ArgumentArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Element",18],[")",17]],"c":[["Value",2,"[Element]",222]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates a property with no default value that reads an array from zero or more arguments, parsing each element with the given closure.\n\nThis method is called to initialize an array `Argument` with no default value such as:\n```swift\n@Argument(transform: baz)\nvar foo: [String]\n```\n\n- Parameters:\n  - parsingStrategy: The behavior to use when parsing multiple values from the command-line arguments.\n  - help: Information about how to use this argument.\n  - transform: A closure that converts a string into this property's element type or throws an error."},{"p":["Argument","init(parsing:help:completion:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArgumentArrayParsingStrategy",18,9],[" = .remaining, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["], ",17],["Element",18],[" : ",17],["ExpressibleByArgument",18,0]],"s":[["init",10],["<",17],["Element",0],[">(",17],["parsing",1],[": ",17],["ArgumentArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"c":[["Value",2,"[Element]",222],["Element",1,"ExpressibleByArgument",0]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates a property with no default value that reads an array from zero or more arguments.\n\nThis method is called to initialize an array `Argument` with no default value such as:\n```swift\n@Argument()\nvar foo: [String]\n```\n\n- Parameters:\n  - parsingStrategy: The behavior to use when parsing multiple values from the command-line arguments.\n  - help: Information about how to use this argument."},{"p":["Argument","init(wrappedValue:help:completion:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil)",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"e":[["Value",1,"ExpressibleByArgument",0]],"c":[["Value",1,"ExpressibleByArgument",0]],"g":[["Value",0,0]],"d":"Creates a property with a default value provided by standard Swift default value syntax.\n\nThis method is called to initialize an `Argument` with a default value such as:\n```swift\n@Argument var foo: String = \"bar\"\n```\n\n- Parameters:\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - help: Information about how to use this argument."},{"p":["Argument","init(help:completion:)"],"f":[["init",10],["(",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil)",17]],"s":[["init",10],["(",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"e":[["Value",1,"ExpressibleByArgument",0]],"c":[["Value",1,"ExpressibleByArgument",0]],"g":[["Value",0,0]],"d":"Creates a property with no default value.\n\nThis method is called to initialize an `Argument` without a default value such as:\n```swift\n@Argument var foo: String\n```\n\n- Parameters:\n  - help: Information about how to use this argument."},{"p":["ArgumentHelp","init(stringLiteral:)"],"f":[["init",10],["(",17],["stringLiteral",1],[" ",17],["value",2],[": ",17],["String",18,203],[")",17]],"s":[["init",10],["(",17],["stringLiteral",1],[": ",17],["String",18],[")",17]],"o":307},{"p":["ArgumentHelp","init(_:discussion:valueName:visibility:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["abstract",2],[": ",17],["String",18,203],[" = \"\", ",17],["discussion",1],[": ",17],["String",18,203],[" = \"\", ",17],["valueName",1],[": ",17],["String",18,203],["? = nil, ",17],["visibility",1],[": ",17],["ArgumentVisibility",18,8],[" = .default)",17]],"s":[["init",10],["(",17],["String",18],[", ",17],["discussion",1],[": ",17],["String",18],[", ",17],["valueName",1],[": ",17],["String",18],["?, ",17],["visibility",1],[": ",17],["ArgumentVisibility",18],[")",17]],"d":"Creates a new help instance."},{"p":["ArgumentHelp","init(_:discussion:valueName:shouldDisplay:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["abstract",2],[": ",17],["String",18,203],[" = \"\", ",17],["discussion",1],[": ",17],["String",18,203],[" = \"\", ",17],["valueName",1],[": ",17],["String",18,203],["? = nil, ",17],["shouldDisplay",1],[": ",17],["Bool",18,223],[")",17]],"s":[["init",10],["(",17],["String",18],[", ",17],["discussion",1],[": ",17],["String",18],[", ",17],["valueName",1],[": ",17],["String",18],["?, ",17],["shouldDisplay",1],[": ",17],["Bool",18],[")",17]],"a":{"a":{"d":true,"m":"Use init(_:discussion:valueName:visibility:) instead."}},"d":"Creates a new help instance."},{"p":["OptionGroup","init(visibility:)"],"f":[["init",10],["(",17],["visibility",1],[": ",17],["ArgumentVisibility",18,8],[" = .default)",17]],"s":[["init",10],["(",17],["visibility",1],[": ",17],["ArgumentVisibility",18],[")",17]],"c":[["Value",1,"ParsableArguments",4]],"g":[["Value",0,0]],"d":"Creates a property that represents another parsable type, using the\nspecified visibility."},{"p":["OptionGroup","init(from:)"],"f":[["init",10],["(",17],["from",1],[" ",17],["decoder",2],[": ",17],["Decoder",18,329],[") ",17],["throws",12]],"s":[["init",10],["(",17],["from",1],[": ",17],["Decoder",18],[") ",17],["throws",12]],"c":[["Value",1,"ParsableArguments",4]],"g":[["Value",0,0]],"o":226},{"p":["OptionGroup","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"a":{"a":{"d":true,"r":"init(visibility:)"}},"e":[["Value",1,"ParsableArguments",4]],"c":[["Value",1,"ParsableArguments",4]],"g":[["Value",0,0]],"d":"Creates a property that represents another parsable type."},{"p":["CompletionShell","init(rawValue:)"],"f":[["init",10],["?(",17],["rawValue",1],[": ",17],["String",18,203],[")",17]],"s":[["init",10],["?(",17],["rawValue",1],[": ",17],["String",18],[")",17]],"d":"Creates a new instance from the given string.","o":213},{"p":["ValidationError","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["message",2],[": ",17],["String",18,203],[")",17]],"s":[["init",10],["(",17],["String",18],[")",17]],"d":"Creates a new validation error with the given message."},{"p":["NameSpecification","init(arrayLiteral:)"],"f":[["init",10],["(",17],["arrayLiteral",1],[" ",17],["elements",2],[": ",17],["NameSpecification",18,17],[".",17],["Element",18,18],["...)",17]],"s":[["init",10],["(",17],["arrayLiteral",1],[": ",17],["NameSpecification",18],[".",17],["Element",18],["...)",17]],"o":304},{"p":["NameSpecification","init(_:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["_",1],[" ",17],["sequence",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,204],[", ",17],["S",18],[".",17],["Element",18],[" == ",17],["NameSpecification",18,17],[".",17],["Element",18,18]],"s":[["init",10],["<",17],["S",0],[">(",17],["S",18],[")",17]],"c":[["S",1,"Sequence",204],["S.Element",2,"NameSpecification.Element",18]],"g":[["S",0,0]]},{"p":["ParsableArguments","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"d":"Creates an instance of this parsable type using the definitions\ngiven by each property's wrapper."},{"p":["CommandConfiguration","init(commandName:abstract:discussion:version:shouldDisplay:subcommands:defaultSubcommand:helpNames:)"],"f":[["init",10],["(",17],["commandName",1],[": ",17],["String",18,203],["?, ",17],["abstract",1],[": ",17],["String",18,203],[", ",17],["discussion",1],[": ",17],["String",18,203],[", ",17],["version",1],[": ",17],["String",18,203],[", ",17],["shouldDisplay",1],[": ",17],["Bool",18,223],[", ",17],["subcommands",1],[": [",17],["ParsableCommand",18,2],[".Type], ",17],["defaultSubcommand",1],[": ",17],["ParsableCommand",18,2],[".Type?, ",17],["helpNames",1],[": ",17],["NameSpecification",18,17],["?)",17]],"s":[["init",10],["(",17],["commandName",1],[": ",17],["String",18],["?, ",17],["abstract",1],[": ",17],["String",18],[", ",17],["discussion",1],[": ",17],["String",18],[", ",17],["version",1],[": ",17],["String",18],[", ",17],["shouldDisplay",1],[": ",17],["Bool",18],[", ",17],["subcommands",1],[": [",17],["ParsableCommand",18],[".Type], ",17],["defaultSubcommand",1],[": ",17],["ParsableCommand",18],[".Type?, ",17],["helpNames",1],[": ",17],["NameSpecification",18],["?)",17]],"a":{"a":{"d":true,"m":"Use the memberwise initializer with the usage parameter."}}},{"p":["CommandConfiguration","init(commandName:abstract:usage:discussion:version:shouldDisplay:subcommands:defaultSubcommand:helpNames:)"],"f":[["init",10],["(",17],["commandName",1],[": ",17],["String",18,203],["? = nil, ",17],["abstract",1],[": ",17],["String",18,203],[" = \"\", ",17],["usage",1],[": ",17],["String",18,203],["? = nil, ",17],["discussion",1],[": ",17],["String",18,203],[" = \"\", ",17],["version",1],[": ",17],["String",18,203],[" = \"\", ",17],["shouldDisplay",1],[": ",17],["Bool",18,223],[" = true, ",17],["subcommands",1],[": [",17],["ParsableCommand",18,2],[".Type] = [], ",17],["defaultSubcommand",1],[": ",17],["ParsableCommand",18,2],[".Type? = nil, ",17],["helpNames",1],[": ",17],["NameSpecification",18,17],["? = nil)",17]],"s":[["init",10],["(",17],["commandName",1],[": ",17],["String",18],["?, ",17],["abstract",1],[": ",17],["String",18],[", ",17],["usage",1],[": ",17],["String",18],["?, ",17],["discussion",1],[": ",17],["String",18],[", ",17],["version",1],[": ",17],["String",18],[", ",17],["shouldDisplay",1],[": ",17],["Bool",18],[", ",17],["subcommands",1],[": [",17],["ParsableCommand",18],[".Type], ",17],["defaultSubcommand",1],[": ",17],["ParsableCommand",18],[".Type?, ",17],["helpNames",1],[": ",17],["NameSpecification",18],["?)",17]],"d":"Creates the configuration for a command.\n\n- Parameters:\n  - commandName: The name of the command to use on the command line. If\n    `commandName` is `nil`, the command name is derived by converting\n    the name of the command type to hyphen-separated lowercase words.\n  - abstract: A one-line description of the command.\n  - usage: A custom usage description for the command. When you provide\n    a non-`nil` string, the argument parser uses `usage` instead of\n    automatically generating a usage description. Passing an empty string\n    hides the usage string altogether.\n  - discussion: A longer description of the command.\n  - version: The version number for this command. When you provide a\n    non-empty string, the argument parser prints it if the user provides\n    a `--version` flag.\n  - shouldDisplay: A Boolean value indicating whether the command\n    should be shown in the extended help display.\n  - subcommands: An array of the types that define subcommands for the\n    command.\n  - defaultSubcommand: The default command type to run if no subcommand\n    is given.\n  - helpNames: The flag names to use for requesting help, when combined\n    with a simulated Boolean property named `help`. If `helpNames` is\n    `nil`, the names are inherited from the parent command, if any, or\n    are `-h` and `--help`."},{"p":["Flag","init(exclusivity:help:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["exclusivity",1],[": ",17],["FlagExclusivity",18,15],[" = .exclusive, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == ",17],["Element",18],["?, ",17],["Element",18],[" : ",17],["EnumerableFlag",18,1]],"s":[["init",10],["<",17],["Element",0],[">(",17],["exclusivity",1],[": ",17],["FlagExclusivity",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"c":[["Value",2,"Element?",229],["Element",1,"EnumerableFlag",1]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates a property that gets its value from the presence of a flag,\nwhere the allowed flags are defined by an `EnumerableFlag` type."},{"p":["Flag","init(wrappedValue:help:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": [",17],["Element",18],["], ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["], ",17],["Element",18],[" : ",17],["EnumerableFlag",18,1]],"s":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": [",17],["Element",18],["], ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"c":[["Value",2,"[Element]",222],["Element",1,"EnumerableFlag",1]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates an array property that gets its values from the presence of\nzero or more flags, where the allowed flags are defined by an\n`EnumerableFlag` type.\n\nThis property has an empty array as its default value.\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - help: Information about how to use this flag."},{"p":["Flag","init(from:)"],"f":[["init",10],["(",17],["from",1],[" ",17],["decoder",2],[": ",17],["Decoder",18,329],[") ",17],["throws",12]],"s":[["init",10],["(",17],["from",1],[": ",17],["Decoder",18],[") ",17],["throws",12]],"g":[["Value",0,0]],"o":226},{"p":["Flag","init(help:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["], ",17],["Element",18],[" : ",17],["EnumerableFlag",18,1]],"s":[["init",10],["<",17],["Element",0],[">(",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"c":[["Value",2,"[Element]",222],["Element",1,"EnumerableFlag",1]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates an array property with no default value that gets its values from the presence of zero or more flags, where the allowed flags are defined by an `EnumerableFlag` type.\n\nThis method is called to initialize an array `Flag` with no default value such as:\n```swift\n@Flag\nvar foo: [CustomFlagType]\n```\n\n- Parameters:\n  - help: Information about how to use this flag."},{"p":["Flag","init(exclusivity:help:)"],"f":[["init",10],["(",17],["exclusivity",1],[": ",17],["FlagExclusivity",18,15],[" = .exclusive, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil)",17]],"s":[["init",10],["(",17],["exclusivity",1],[": ",17],["FlagExclusivity",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"e":[["Value",1,"EnumerableFlag",1]],"c":[["Value",1,"EnumerableFlag",1]],"g":[["Value",0,0]],"d":"Creates a property with no default value that gets its value from the presence of a flag.\n\nUse this initializer to customize the name and number of states further than using a `Bool`.\nTo use, define an `EnumerableFlag` enumeration with a case for each state, and use that as the type for your flag.\nIn this case, the user can specify either `--use-production-server` or `--use-development-server` to set the flag's value.\n\n```swift\nenum ServerChoice: EnumerableFlag {\n  case useProductionServer\n  case useDevelopmentServer\n}\n\n@Flag var serverChoice: ServerChoice\n```\n\n- Parameters:\n  - exclusivity: The behavior to use when multiple flags are specified.\n  - help: Information about how to use this flag."},{"p":["Flag","init(wrappedValue:exclusivity:help:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18,15],[" = .exclusive, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil)",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"e":[["Value",1,"EnumerableFlag",1]],"c":[["Value",1,"EnumerableFlag",1]],"g":[["Value",0,0]],"d":"Creates a property with a default value provided by standard Swift default value syntax that gets its value from the presence of a flag.\n\nUse this initializer to customize the name and number of states further than using a `Bool`.\nTo use, define an `EnumerableFlag` enumeration with a case for each state, and use that as the type for your flag.\nIn this case, the user can specify either `--use-production-server` or `--use-development-server` to set the flag's value.\n\n```swift\nenum ServerChoice: EnumerableFlag {\n  case useProductionServer\n  case useDevelopmentServer\n}\n\n@Flag var serverChoice: ServerChoice = .useProductionServer\n```\n\n- Parameters:\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - exclusivity: The behavior to use when multiple flags are specified.\n  - help: Information about how to use this flag."},{"p":["Flag","init(wrappedValue:name:help:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Bool",18,223],[", ",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil)",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Bool",18],[", ",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"e":[["Value",2,"Bool",223]],"c":[["Value",2,"Bool",223]],"g":[["Value",0,0]],"d":"Creates a Boolean property with default value provided by standard Swift default value syntax that reads its value from the presence of a flag.\n\n- Parameters:\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - name: A specification for what names are allowed for this flag.\n  - help: Information about how to use this flag."},{"p":["Flag","init(wrappedValue:name:inversion:exclusivity:help:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Bool",18,223],[", ",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["inversion",1],[": ",17],["FlagInversion",18,12],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18,15],[" = .chooseLast, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil)",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Bool",18],[", ",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["inversion",1],[": ",17],["FlagInversion",18],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"e":[["Value",2,"Bool",223]],"c":[["Value",2,"Bool",223]],"g":[["Value",0,0]],"d":"Creates a Boolean property with default value provided by standard Swift default value syntax that reads its value from the presence of one or more inverted flags.\n\nUse this initializer to create a Boolean flag with an on/off pair.\nWith the following declaration, for example, the user can specify either `--use-https` or `--no-use-https` to set the `useHTTPS` flag to `true` or `false`, respectively.\n\n```swift\n@Flag(inversion: .prefixedNo)\nvar useHTTPS: Bool = true\n````\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - inversion: The method for converting this flag's name into an on/off pair.\n  - exclusivity: The behavior to use when an on/off pair of flags is specified.\n  - help: Information about how to use this flag."},{"p":["Flag","init(name:inversion:exclusivity:help:)"],"f":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["inversion",1],[": ",17],["FlagInversion",18,12],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18,15],[" = .chooseLast, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil)",17]],"s":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["inversion",1],[": ",17],["FlagInversion",18],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"e":[["Value",2,"Bool",223]],"c":[["Value",2,"Bool",223]],"g":[["Value",0,0]],"d":"Creates a Boolean property with no default value that reads its value from the presence of one or more inverted flags.\n\nUse this initializer to create a Boolean flag with an on/off pair.\nWith the following declaration, for example, the user can specify either `--use-https` or `--no-use-https` to set the `useHTTPS` flag to `true` or `false`, respectively.\n\n```swift\n@Flag(inversion: .prefixedNo)\nvar useHTTPS: Bool\n````\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - inversion: The method for converting this flag's name into an on/off pair.\n  - exclusivity: The behavior to use when an on/off pair of flags is specified.\n  - help: Information about how to use this flag."},{"p":["Flag","init(name:inversion:exclusivity:help:)"],"f":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["inversion",1],[": ",17],["FlagInversion",18,12],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18,15],[" = .chooseLast, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil)",17]],"s":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["inversion",1],[": ",17],["FlagInversion",18],[", ",17],["exclusivity",1],[": ",17],["FlagExclusivity",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"e":[["Value",2,"Bool?",229]],"c":[["Value",2,"Bool?",229]],"g":[["Value",0,0]],"d":"Creates a Boolean property that reads its value from the presence of\none or more inverted flags.\n\nUse this initializer to create an optional Boolean flag with an on/off\npair. With the following declaration, for example, the user can specify\neither `--use-https` or `--no-use-https` to set the `useHTTPS` flag to\n`true` or `false`, respectively. If neither is specified, the resulting\nflag value would be `nil`.\n\n    @Flag(inversion: .prefixedNo)\n    var useHTTPS: Bool?\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - inversion: The method for converting this flags name into an on/off\n    pair.\n  - exclusivity: The behavior to use when an on/off pair of flags is\n    specified.\n  - help: Information about how to use this flag."},{"p":["Flag","init(name:help:)"],"f":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil)",17]],"s":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"e":[["Value",2,"Int",228]],"c":[["Value",2,"Int",228]],"g":[["Value",0,0]],"d":"Creates an integer property that gets its value from the number of times\na flag appears.\n\nThis property defaults to a value of zero.\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - help: Information about how to use this flag."},{"p":["Option","init(wrappedValue:name:parsing:help:completion:transform:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": [",17],["Element",18],["], ",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArrayParsingStrategy",18,19],[" = .singleValue, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Element",18],[") ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["]",17]],"s":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": [",17],["Element",18],["], ",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["ArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Element",18],[")",17]],"c":[["Value",2,"[Element]",222]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates an array property that reads its values from zero or more\nlabeled options, parsing with the given closure.\n\nThis property defaults to an empty array if the `initial` parameter\nis not specified.\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - initial: A default value to use for this property. If `initial` is\n    `nil`, this option defaults to an empty array.\n  - parsingStrategy: The behavior to use when parsing multiple values\n    from the command-line arguments.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option.\n  - transform: A closure that converts a string into this property's\n    element type or throws an error."},{"p":["Option","init(wrappedValue:name:parsing:help:completion:transform:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["SingleValueParsingStrategy",18,21],[" = .next, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["SingleValueParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"g":[["Value",0,0]],"d":"Creates a property with a default value provided by standard Swift default value syntax, parsing with the given closure.\n\nThis method is called to initialize an `Option` with a default value such as:\n```swift\n@Option(transform: baz)\nvar foo: String = \"bar\"\n```\n- Parameters:\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - name: A specification for what names are allowed for this flag.\n  - parsingStrategy: The behavior to use when looking for this option's value.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option.\n  - transform: A closure that converts a string into this property's type or throws an error."},{"p":["Option","init(wrappedValue:name:parsing:help:completion:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": [",17],["Element",18],["], ",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArrayParsingStrategy",18,19],[" = .singleValue, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["], ",17],["Element",18],[" : ",17],["ExpressibleByArgument",18,0]],"s":[["init",10],["<",17],["Element",0],[">(",17],["wrappedValue",1],[": [",17],["Element",18],["], ",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["ArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"c":[["Value",2,"[Element]",222],["Element",1,"ExpressibleByArgument",0]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates an array property that reads its values from zero or more\nlabeled options.\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - initial: A default value to use for this property.\n  - parsingStrategy: The behavior to use when parsing multiple values\n    from the command-line arguments.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option."},{"p":["Option","init(from:)"],"f":[["init",10],["(",17],["from",1],[" ",17],["decoder",2],[": ",17],["Decoder",18,329],[") ",17],["throws",12]],"s":[["init",10],["(",17],["from",1],[": ",17],["Decoder",18],[") ",17],["throws",12]],"g":[["Value",0,0]],"o":226},{"p":["Option","init(name:parsing:help:completion:transform:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArrayParsingStrategy",18,19],[" = .singleValue, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Element",18],[") ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["]",17]],"s":[["init",10],["<",17],["Element",0],[">(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["ArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Element",18],[")",17]],"c":[["Value",2,"[Element]",222]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates an array property with no default value that reads its values from zero or more labeled options, parsing each element with the given closure.\n\nThis method is called to initialize an array `Option` with no default value such as:\n```swift\n@Option(transform: baz)\nvar foo: [String]\n```\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - parsingStrategy: The behavior to use when parsing multiple values from the command-line arguments.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option.\n  - transform: A closure that converts a string into this property's element type or throws an error."},{"p":["Option","init(name:parsing:help:completion:transform:)"],"f":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["SingleValueParsingStrategy",18,21],[" = .next, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil, ",17],["transform",1],[": ",17],["@escaping",12],[" (",17],["String",18,203],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"s":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["SingleValueParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["transform",1],[": (",17],["String",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[")",17]],"g":[["Value",0,0]],"d":"Creates a property with no default value, parsing with the given closure.\n\nThis method is called to initialize an `Option` with no default value such as:\n```swift\n@Option(transform: baz)\nvar foo: String\n```\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - parsingStrategy: The behavior to use when looking for this option's value.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option.\n  - transform: A closure that converts a string into this property's type or throws an error."},{"p":["Option","init(name:parsing:help:completion:)"],"f":[["init",10],["<",17],["Element",0],[">(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["ArrayParsingStrategy",18,19],[" = .singleValue, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == [",17],["Element",18],["], ",17],["Element",18],[" : ",17],["ExpressibleByArgument",18,0]],"s":[["init",10],["<",17],["Element",0],[">(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["ArrayParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"c":[["Value",2,"[Element]",222],["Element",1,"ExpressibleByArgument",0]],"g":[["Value",0,0],["Element",0,1]],"d":"Creates an array property with no default value that reads its values from zero or more labeled options.\n\nThis method is called to initialize an array `Option` with no default value such as:\n```swift\n@Option()\nvar foo: [String]\n```\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - parsingStrategy: The behavior to use when parsing multiple values from the command-line arguments.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option."},{"p":["Option","init(name:parsing:help:completion:)"],"f":[["init",10],["<",17],["T",0],[">(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["SingleValueParsingStrategy",18,21],[" = .next, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil) ",17],["where",12],[" ",17],["Value",18],[" == ",17],["T",18],["?, ",17],["T",18],[" : ",17],["ExpressibleByArgument",18,0]],"s":[["init",10],["<",17],["T",0],[">(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["SingleValueParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"c":[["Value",2,"T?",229],["T",1,"ExpressibleByArgument",0]],"g":[["Value",0,0],["T",0,1]],"d":"Creates a property that reads its value from a labeled option.\n\nIf the property has an `Optional` type, or you provide a non-`nil`\nvalue for the `initial` parameter, specifying this option is not\nrequired.\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - parsingStrategy: The behavior to use when looking for this option's\n    value.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option."},{"p":["Option","init(wrappedValue:name:parsing:completion:help:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["SingleValueParsingStrategy",18,21],[" = .next, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["?, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["?)",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["SingleValueParsingStrategy",18],[", ",17],["completion",1],[": ",17],["CompletionKind",18],["?, ",17],["help",1],[": ",17],["ArgumentHelp",18],["?)",17]],"a":{"a":{"d":true,"m":"Swap the order of your 'help' and 'completion' arguments."}},"e":[["Value",1,"ExpressibleByArgument",0]],"c":[["Value",1,"ExpressibleByArgument",0]],"g":[["Value",0,0]],"d":"Creates a property with a default value provided by standard Swift default value syntax."},{"p":["Option","init(wrappedValue:name:parsing:help:completion:)"],"f":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["SingleValueParsingStrategy",18,21],[" = .next, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil)",17]],"s":[["init",10],["(",17],["wrappedValue",1],[": ",17],["Value",18],[", ",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["SingleValueParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"e":[["Value",1,"ExpressibleByArgument",0]],"c":[["Value",1,"ExpressibleByArgument",0]],"g":[["Value",0,0]],"d":"Creates a property with a default value provided by standard Swift default value syntax.\n\nThis method is called to initialize an `Option` with a default value such as:\n```swift\n@Option var foo: String = \"bar\"\n```\n\n- Parameters:\n  - wrappedValue: A default value to use for this property, provided implicitly by the compiler during property wrapper initialization.\n  - name: A specification for what names are allowed for this flag.\n  - parsingStrategy: The behavior to use when looking for this option's value.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option."},{"p":["Option","init(name:parsing:help:completion:)"],"f":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18,17],[" = .long, ",17],["parsing",1],[" ",17],["parsingStrategy",2],[": ",17],["SingleValueParsingStrategy",18,21],[" = .next, ",17],["help",1],[": ",17],["ArgumentHelp",18,10],["? = nil, ",17],["completion",1],[": ",17],["CompletionKind",18,13],["? = nil)",17]],"s":[["init",10],["(",17],["name",1],[": ",17],["NameSpecification",18],[", ",17],["parsing",1],[": ",17],["SingleValueParsingStrategy",18],[", ",17],["help",1],[": ",17],["ArgumentHelp",18],["?, ",17],["completion",1],[": ",17],["CompletionKind",18],["?)",17]],"e":[["Value",1,"ExpressibleByArgument",0]],"c":[["Value",1,"ExpressibleByArgument",0]],"g":[["Value",0,0]],"d":"Creates a property with no default value.\n\nThis method is called to initialize an `Option` without a default value such as:\n```swift\n@Option var foo: String\n```\n\n- Parameters:\n  - name: A specification for what names are allowed for this flag.\n  - parsingStrategy: The behavior to use when looking for this option's value.\n  - help: Information about how to use this option.\n  - completion: Kind of completion provided to the user for this option."},{"p":["ExitCode","init(rawValue:)"],"f":[["init",10],["(",17],["rawValue",1],[": ",17],["Int32",18,322],[")",17]],"s":[["init",10],["(",17],["rawValue",1],[": ",17],["Int32",18],[")",17]],"o":213},{"p":["ExitCode","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["code",2],[": ",17],["Int32",18,322],[")",17]],"s":[["init",10],["(",17],["Int32",18],[")",17]],"d":"Creates a new `ExitCode` with the given code."},{"p":["ExpressibleByArgument","allValueStrings"],"f":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18,203],["] { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18],["]",17]],"d":"An array of all possible strings to that can convert to value of this\ntype.\n\nThe default implementation of this property returns an empty array."},{"p":["ExpressibleByArgument","defaultCompletionKind"],"f":[["static",12],[" ",17],["var",12],[" ",17],["defaultCompletionKind",7],[": ",17],["CompletionKind",18,13],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["defaultCompletionKind",7],[": ",17],["CompletionKind",18]],"d":"The completion kind to use for options or arguments of this type that\ndon't explicitly declare a completion kind.\n\nThe default implementation of this property returns `.default`."},{"p":["ExpressibleByArgument","allValueStrings"],"f":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18,203],["] { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18],["]",17]],"o":74},{"p":["ExpressibleByArgument","defaultCompletionKind"],"f":[["static",12],[" ",17],["var",12],[" ",17],["defaultCompletionKind",7],[": ",17],["CompletionKind",18,13],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["defaultCompletionKind",7],[": ",17],["CompletionKind",18]],"o":75},{"p":["ExpressibleByArgument","allValueStrings"],"f":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18,203],["] { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18],["]",17]],"e":[["Self",1,"CaseIterable",258],["Self",1,"RawRepresentable",211],["Self.RawValue",2,"String",203]],"o":74},{"p":["ExpressibleByArgument","allValueStrings"],"f":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18,203],["] { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["allValueStrings",7],[": [",17],["String",18],["]",17]],"e":[["Self",1,"CaseIterable",258]],"o":74},{"p":["ExpressibleByArgument","defaultCompletionKind"],"f":[["static",12],[" ",17],["var",12],[" ",17],["defaultCompletionKind",7],[": ",17],["CompletionKind",18,13],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["defaultCompletionKind",7],[": ",17],["CompletionKind",18]],"e":[["Self",1,"CaseIterable",258]],"o":75},{"p":["ArgumentVisibility","hidden"],"f":[["static",12],[" ",17],["let",12],[" ",17],["hidden",7],[": ",17],["ArgumentVisibility",18,8]],"s":[["static",12],[" ",17],["let",12],[" ",17],["hidden",7],[": ",17],["ArgumentVisibility",18]],"d":"Only show help for this argument in the extended help screen."},{"p":["ArgumentVisibility","default"],"f":[["static",12],[" ",17],["let",12],[" ",17],["`default`",7],[": ",17],["ArgumentVisibility",18,8]],"s":[["static",12],[" ",17],["let",12],[" ",17],["`default`",7],[": ",17],["ArgumentVisibility",18]],"d":"Show help for this argument whenever appropriate."},{"p":["ArgumentVisibility","private"],"f":[["static",12],[" ",17],["let",12],[" ",17],["`private`",7],[": ",17],["ArgumentVisibility",18,8]],"s":[["static",12],[" ",17],["let",12],[" ",17],["`private`",7],[": ",17],["ArgumentVisibility",18]],"d":"Never show help for this argument."},{"p":["ArgumentArrayParsingStrategy","unconditionalRemaining"],"f":[["static",12],[" ",17],["var",12],[" ",17],["unconditionalRemaining",7],[": ",17],["ArgumentArrayParsingStrategy",18,9],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["unconditionalRemaining",7],[": ",17],["ArgumentArrayParsingStrategy",18]],"d":"Parse all remaining inputs after parsing any known options or flags,\nincluding dash-prefixed inputs and the `--` terminator.\n\nWhen you use the `unconditionalRemaining` parsing strategy, the parser\nstops parsing flags and options as soon as it encounters a positional\nargument or an unrecognized flag. For example, for a parsable type\ndefined as following:\n\n    struct Options: ParsableArguments {\n        @Flag\n        var verbose: Bool = false\n\n        @Argument(parsing: .unconditionalRemaining)\n        var words: [String] = []\n    }\n\nParsing the input `--verbose one two --verbose` includes the second\n`--verbose` flag in `words`, resulting in\n`Options(verbose: true, words: [\"one\", \"two\", \"--verbose\"])`.\n\n- Note: This parsing strategy can be surprising for users, particularly\n  when combined with options and flags. Prefer `remaining` whenever\n  possible, since users can always terminate options and flags with\n  the `--` terminator. With the `remaining` parsing strategy, the input\n  `--verbose -- one two --verbose` would have the same result as the above\n  example: `Options(verbose: true, words: [\"one\", \"two\", \"--verbose\"])`."},{"p":["ArgumentArrayParsingStrategy","remaining"],"f":[["static",12],[" ",17],["var",12],[" ",17],["remaining",7],[": ",17],["ArgumentArrayParsingStrategy",18,9],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["remaining",7],[": ",17],["ArgumentArrayParsingStrategy",18]],"d":"Parse only unprefixed values from the command-line input, ignoring\nany inputs that have a dash prefix. This is the default strategy.\n\nFor example, for a parsable type defined as following:\n\n    struct Options: ParsableArguments {\n        @Flag var verbose: Bool\n        @Argument(parsing: .remaining) var words: [String]\n    }\n\nParsing the input `--verbose one two` or `one two --verbose` would result\nin `Options(verbose: true, words: [\"one\", \"two\"])`. Parsing the input\n`one two --other` would result in an unknown option error for `--other`.\n\nThis is the default strategy for parsing argument arrays."},{"p":["ArgumentHelp","hidden"],"f":[["static",12],[" ",17],["var",12],[" ",17],["hidden",7],[": ",17],["ArgumentHelp",18,10],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["hidden",7],[": ",17],["ArgumentHelp",18]],"d":"A `Help` instance that shows an argument only in the extended help display."},{"p":["ArgumentHelp","private"],"f":[["static",12],[" ",17],["var",12],[" ",17],["`private`",7],[": ",17],["ArgumentHelp",18,10],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["`private`",7],[": ",17],["ArgumentHelp",18]],"d":"A `Help` instance that hides an argument from the extended help display."},{"p":["FlagInversion","prefixedNo"],"f":[["static",12],[" ",17],["var",12],[" ",17],["prefixedNo",7],[": ",17],["FlagInversion",18,12],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["prefixedNo",7],[": ",17],["FlagInversion",18]],"d":"Adds a matching flag with a `no-` prefix to represent `false`.\n\nFor example, the `shouldRender` property in this declaration is set to\n`true` when a user provides `--render` and to `false` when the user\nprovides `--no-render`:\n\n    @Flag(name: .customLong(\"render\"), inversion: .prefixedNo)\n    var shouldRender: Bool"},{"p":["FlagInversion","prefixedEnableDisable"],"f":[["static",12],[" ",17],["var",12],[" ",17],["prefixedEnableDisable",7],[": ",17],["FlagInversion",18,12],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["prefixedEnableDisable",7],[": ",17],["FlagInversion",18]],"d":"Uses matching flags with `enable-` and `disable-` prefixes.\n\nFor example, the `extraOutput` property in this declaration is set to\n`true` when a user provides `--enable-extra-output` and to `false` when\nthe user provides `--disable-extra-output`:\n\n    @Flag(inversion: .prefixedEnableDisable)\n    var extraOutput: Bool"},{"p":["CompletionKind","default"],"f":[["static",12],[" ",17],["var",12],[" ",17],["`default`",7],[": ",17],["CompletionKind",18,13],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["`default`",7],[": ",17],["CompletionKind",18]],"d":"Use the default completion kind for the value's type."},{"p":["CompletionKind","directory"],"f":[["static",12],[" ",17],["var",12],[" ",17],["directory",7],[": ",17],["CompletionKind",18,13],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["directory",7],[": ",17],["CompletionKind",18]],"d":"Complete directory names."},{"p":["CompletionShell","zsh"],"f":[["static",12],[" ",17],["var",12],[" ",17],["zsh",7],[": ",17],["CompletionShell",18,14],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["zsh",7],[": ",17],["CompletionShell",18]],"d":"An instance representing `zsh`."},{"p":["CompletionShell","bash"],"f":[["static",12],[" ",17],["var",12],[" ",17],["bash",7],[": ",17],["CompletionShell",18,14],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["bash",7],[": ",17],["CompletionShell",18]],"d":"An instance representing `bash`."},{"p":["CompletionShell","fish"],"f":[["static",12],[" ",17],["var",12],[" ",17],["fish",7],[": ",17],["CompletionShell",18,14],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["fish",7],[": ",17],["CompletionShell",18]],"d":"An instance representing `fish`."},{"p":["CompletionShell","allCases"],"f":[["static",12],[" ",17],["var",12],[" ",17],["allCases",7],[": [",17],["CompletionShell",18,14],["] { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["allCases",7],[": [",17],["CompletionShell",18],["]",17]],"d":"An array of all supported shells for completion scripts.","o":259},{"p":["FlagExclusivity","chooseLast"],"f":[["static",12],[" ",17],["var",12],[" ",17],["chooseLast",7],[": ",17],["FlagExclusivity",18,15],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["chooseLast",7],[": ",17],["FlagExclusivity",18]],"d":"The last enumeration case that is provided is used."},{"p":["FlagExclusivity","chooseFirst"],"f":[["static",12],[" ",17],["var",12],[" ",17],["chooseFirst",7],[": ",17],["FlagExclusivity",18,15],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["chooseFirst",7],[": ",17],["FlagExclusivity",18]],"d":"The first enumeration case that is provided is used."},{"p":["FlagExclusivity","exclusive"],"f":[["static",12],[" ",17],["var",12],[" ",17],["exclusive",7],[": ",17],["FlagExclusivity",18,15],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["exclusive",7],[": ",17],["FlagExclusivity",18]],"d":"Only one of the enumeration cases may be provided."},{"p":["ParsableCommand","configuration"],"f":[["static",12],[" ",17],["var",12],[" ",17],["configuration",7],[": ",17],["CommandConfiguration",18,20],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["configuration",7],[": ",17],["CommandConfiguration",18]],"d":"Configuration for this command, including subcommands and custom help\ntext."},{"p":["ParsableCommand","configuration"],"f":[["static",12],[" ",17],["var",12],[" ",17],["configuration",7],[": ",17],["CommandConfiguration",18,20],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["configuration",7],[": ",17],["CommandConfiguration",18]],"o":99},{"p":["NameSpecification","shortAndLong"],"f":[["static",12],[" ",17],["var",12],[" ",17],["shortAndLong",7],[": ",17],["NameSpecification",18,17],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["shortAndLong",7],[": ",17],["NameSpecification",18]],"d":"Combine the `.short` and `.long` specifications to allow both long\nand short labels.\n\nFor example, a property named `verbose` would be converted to both the\nlong `--verbose` and short `-v` labels."},{"p":["NameSpecification","long"],"f":[["static",12],[" ",17],["var",12],[" ",17],["long",7],[": ",17],["NameSpecification",18,17],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["long",7],[": ",17],["NameSpecification",18]],"d":"Use the property's name converted to lowercase with words separated by\nhyphens.\n\nFor example, a property named `allowLongNames` would be converted to the\nlabel `--allow-long-names`."},{"p":["NameSpecification","short"],"f":[["static",12],[" ",17],["var",12],[" ",17],["short",7],[": ",17],["NameSpecification",18,17],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["short",7],[": ",17],["NameSpecification",18]],"d":"Use the first character of the property's name as a short option label.\n\nFor example, a property named `verbose` would be converted to the\nlabel `-v`. Short labels can be combined into groups."},{"p":["NameSpecification","Element","long"],"f":[["static",12],[" ",17],["var",12],[" ",17],["long",7],[": ",17],["NameSpecification",18,17],[".",17],["Element",18,18],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["long",7],[": ",17],["NameSpecification",18],[".",17],["Element",18]],"d":"Use the property's name, converted to lowercase with words separated by\nhyphens.\n\nFor example, a property named `allowLongNames` would be converted to the\nlabel `--allow-long-names`."},{"p":["NameSpecification","Element","short"],"f":[["static",12],[" ",17],["var",12],[" ",17],["short",7],[": ",17],["NameSpecification",18,17],[".",17],["Element",18,18],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["short",7],[": ",17],["NameSpecification",18],[".",17],["Element",18]],"d":"Use the first character of the property's name as a short option label.\n\nFor example, a property named `verbose` would be converted to the\nlabel `-v`. Short labels can be combined into groups."},{"p":["ArrayParsingStrategy","singleValue"],"f":[["static",12],[" ",17],["var",12],[" ",17],["singleValue",7],[": ",17],["ArrayParsingStrategy",18,19],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["singleValue",7],[": ",17],["ArrayParsingStrategy",18]],"d":"Parse one value per option, joining multiple into an array.\n\nFor example, for a parsable type with a property defined as\n`@Option(parsing: .singleValue) var read: [String]`,\nthe input `--read foo --read bar` would result in the array\n`[\"foo\", \"bar\"]`. The same would be true for the input\n`--read=foo --read=bar`.\n\n- Note: This follows the default behavior of differentiating between values and options. As\n    such, the value for this option will be the next value (non-option) in the input. For the\n    above example, the input `--read --name Foo Bar` would parse `Foo` into\n    `read` (and `Bar` into `name`)."},{"p":["ArrayParsingStrategy","upToNextOption"],"f":[["static",12],[" ",17],["var",12],[" ",17],["upToNextOption",7],[": ",17],["ArrayParsingStrategy",18,19],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["upToNextOption",7],[": ",17],["ArrayParsingStrategy",18]],"d":"Parse all values up to the next option.\n\nFor example, for a parsable type with a property defined as\n`@Option(parsing: .upToNextOption) var files: [String]`,\nthe input `--files foo bar` would result in the array\n`[\"foo\", \"bar\"]`.\n\nParsing stops as soon as there’s another option in the input such that\n`--files foo bar --verbose` would also set `files` to the array\n`[\"foo\", \"bar\"]`."},{"p":["ArrayParsingStrategy","unconditionalSingleValue"],"f":[["static",12],[" ",17],["var",12],[" ",17],["unconditionalSingleValue",7],[": ",17],["ArrayParsingStrategy",18,19],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["unconditionalSingleValue",7],[": ",17],["ArrayParsingStrategy",18]],"d":"Parse the value immediately after the option while allowing repeating options, joining multiple into an array.\n\nThis is identical to `.singleValue` except that the value will be read\nfrom the input immediately after the option, even if it could be interpreted as an option.\n\nFor example, for a parsable type with a property defined as\n`@Option(parsing: .unconditionalSingleValue) var read: [String]`,\nthe input `--read foo --read bar` would result in the array\n`[\"foo\", \"bar\"]` -- just as it would have been the case for `.singleValue`.\n\n- Note: However, the input `--read --name Foo Bar --read baz` would result in\n`read` being set to the array `[\"--name\", \"baz\"]`. This is usually *not* what users\nwould expect. Use with caution."},{"p":["ArrayParsingStrategy","remaining"],"f":[["static",12],[" ",17],["var",12],[" ",17],["remaining",7],[": ",17],["ArrayParsingStrategy",18,19],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["remaining",7],[": ",17],["ArrayParsingStrategy",18]],"d":"Parse all remaining arguments into an array.\n\n`.remaining` can be used for capturing pass-through flags. For example, for\na parsable type defined as\n`@Option(parsing: .remaining) var passthrough: [String]`:\n\n    $ cmd --passthrough --foo 1 --bar 2 -xvf\n    ------------\n    options.passthrough == [\"--foo\", \"1\", \"--bar\", \"2\", \"-xvf\"]\n\n- Note: This will read all inputs following the option without attempting to do any parsing. This is\nusually *not* what users would expect. Use with caution.\n\nConsider using a trailing `@Argument` instead and letting users explicitly turn off parsing\nthrough the terminator `--`. That is the more common approach. For example:\n```swift\nstruct Options: ParsableArguments {\n    @Option var name: String\n    @Argument var remainder: [String]\n}\n```\nwould parse the input `--name Foo -- Bar --baz` such that the `remainder`\nwould hold the value `[\"Bar\", \"--baz\"]`."},{"p":["SingleValueParsingStrategy","scanningForValue"],"f":[["static",12],[" ",17],["var",12],[" ",17],["scanningForValue",7],[": ",17],["SingleValueParsingStrategy",18,21],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["scanningForValue",7],[": ",17],["SingleValueParsingStrategy",18]],"d":"Parse the next input, as long as that input can't be interpreted as\nan option or flag.\n\n- Note: This will skip other options and _read ahead_ in the input\nto find the next available value. This may be *unexpected* for users.\nUse with caution.\n\nFor example, if `--foo` takes a value, then the input `--foo --bar bar`\nwould be parsed such that the value `bar` is used for `--foo`."},{"p":["SingleValueParsingStrategy","unconditional"],"f":[["static",12],[" ",17],["var",12],[" ",17],["unconditional",7],[": ",17],["SingleValueParsingStrategy",18,21],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["unconditional",7],[": ",17],["SingleValueParsingStrategy",18]],"d":"Parse the next input, even if it could be interpreted as an option or\nflag.\n\nFor inputs such as `--foo --bar baz`, if `.unconditional` is used for `foo`,\nthis would read `--bar` as the value for `foo` and would use `baz` as\nthe next positional argument.\n\nThis allows reading negative numeric values or capturing flags to be\npassed through to another program since the leading hyphen is normally\ninterpreted as the start of another option.\n\n- Note: This is usually *not* what users would expect. Use with caution."},{"p":["SingleValueParsingStrategy","next"],"f":[["static",12],[" ",17],["var",12],[" ",17],["next",7],[": ",17],["SingleValueParsingStrategy",18,21],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["next",7],[": ",17],["SingleValueParsingStrategy",18]],"d":"Parse the input after the option. Expect it to be a value.\n\nFor inputs such as `--foo foo`, this would parse `foo` as the\nvalue. However, the input `--foo --bar foo bar` would\nresult in an error. Even though two values are provided, they don’t\nsucceed each option. Parsing would result in an error such as the following:\n\n    Error: Missing value for '--foo <foo>'\n    Usage: command [--foo <foo>]\n\nThis is the **default behavior** for `@Option`-wrapped properties."},{"p":["ExitCode","validationFailure"],"f":[["static",12],[" ",17],["let",12],[" ",17],["validationFailure",7],[": ",17],["ExitCode",18,24]],"s":[["static",12],[" ",17],["let",12],[" ",17],["validationFailure",7],[": ",17],["ExitCode",18]]},{"p":["ExitCode","failure"],"f":[["static",12],[" ",17],["let",12],[" ",17],["failure",7],[": ",17],["ExitCode",18,24]],"s":[["static",12],[" ",17],["let",12],[" ",17],["failure",7],[": ",17],["ExitCode",18]],"d":"An exit code that indicates that the command failed."},{"p":["ExitCode","success"],"f":[["static",12],[" ",17],["let",12],[" ",17],["success",7],[": ",17],["ExitCode",18,24]],"s":[["static",12],[" ",17],["let",12],[" ",17],["success",7],[": ",17],["ExitCode",18]],"d":"An exit code that indicates successful completion of a command."},{"p":["ExpressibleByArgument","defaultValueDescription"],"f":[["var",12],[" ",17],["defaultValueDescription",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["defaultValueDescription",7],[": ",17],["String",18]],"d":"The description of this instance to show as a default value in a\ncommand-line tool's help screen."},{"p":["ExpressibleByArgument","defaultValueDescription"],"f":[["var",12],[" ",17],["defaultValueDescription",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["defaultValueDescription",7],[": ",17],["String",18]],"o":116},{"p":["Argument","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"o":301},{"p":["Argument","wrappedValue"],"f":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18]],"d":"The value presented by this property wrapper."},{"p":["ArgumentHelp","discussion"],"f":[["var",12],[" ",17],["discussion",7],[": ",17],["String",18,203]],"s":[["var",12],[" ",17],["discussion",7],[": ",17],["String",18]],"d":"An expanded description of the argument, in plain text form."},{"p":["ArgumentHelp","visibility"],"f":[["var",12],[" ",17],["visibility",7],[": ",17],["ArgumentVisibility",18,8]],"s":[["var",12],[" ",17],["visibility",7],[": ",17],["ArgumentVisibility",18]],"d":"A visibility level indicating whether this argument should be shown in\nthe extended help display."},{"p":["ArgumentHelp","shouldDisplay"],"f":[["var",12],[" ",17],["shouldDisplay",7],[": ",17],["Bool",18,223],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["shouldDisplay",7],[": ",17],["Bool",18]],"a":{"a":{"d":true,"m":"Use visibility level instead."}},"d":"A Boolean value indicating whether this argument should be shown in\nthe extended help display."},{"p":["ArgumentHelp","abstract"],"f":[["var",12],[" ",17],["abstract",7],[": ",17],["String",18,203]],"s":[["var",12],[" ",17],["abstract",7],[": ",17],["String",18]],"d":"A short description of the argument."},{"p":["ArgumentHelp","valueName"],"f":[["var",12],[" ",17],["valueName",7],[": ",17],["String",18,203],["?",17]],"s":[["var",12],[" ",17],["valueName",7],[": ",17],["String",18],["?",17]],"d":"An alternative name to use for the argument's value when showing usage\ninformation.\n\n- Note: This property is ignored when generating help for flags, since\n  flags don't include a value."},{"p":["OptionGroup","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"e":[["Value",1,"ParsableArguments",4]],"o":301},{"p":["OptionGroup","wrappedValue"],"f":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18]],"d":"The value presented by this property wrapper."},{"p":["CompletionShell","rawValue"],"f":[["var",12],[" ",17],["rawValue",7],[": ",17],["String",18,203]],"s":[["var",12],[" ",17],["rawValue",7],[": ",17],["String",18]],"o":212},{"p":["ValidationError","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"o":301},{"p":["ValidationError","message"],"f":[["var",12],[" ",17],["message",7],[": ",17],["String",18,203],[" { get }",17]],"s":[["var",12],[" ",17],["message",7],[": ",17],["String",18]],"d":"The error message represented by this instance, this string is presented to\nthe user when a `ValidationError` is thrown from either; `run()`,\n`validate()` or a transform closure."},{"p":["CommandConfiguration","discussion"],"f":[["var",12],[" ",17],["discussion",7],[": ",17],["String",18,203]],"s":[["var",12],[" ",17],["discussion",7],[": ",17],["String",18]],"d":"A longer description of this command, to be shown in the extended help\ndisplay."},{"p":["CommandConfiguration","commandName"],"f":[["var",12],[" ",17],["commandName",7],[": ",17],["String",18,203],["?",17]],"s":[["var",12],[" ",17],["commandName",7],[": ",17],["String",18],["?",17]],"d":"The name of the command to use on the command line.\n\nIf `nil`, the command name is derived by converting the name of\nthe command type to hyphen-separated lowercase words."},{"p":["CommandConfiguration","subcommands"],"f":[["var",12],[" ",17],["subcommands",7],[": [",17],["ParsableCommand",18,2],[".Type]",17]],"s":[["var",12],[" ",17],["subcommands",7],[": [",17],["ParsableCommand",18],[".Type]",17]],"d":"An array of the types that define subcommands for this command."},{"p":["CommandConfiguration","shouldDisplay"],"f":[["var",12],[" ",17],["shouldDisplay",7],[": ",17],["Bool",18,223]],"s":[["var",12],[" ",17],["shouldDisplay",7],[": ",17],["Bool",18]],"d":"A Boolean value indicating whether this command should be shown in\nthe extended help display."},{"p":["CommandConfiguration","defaultSubcommand"],"f":[["var",12],[" ",17],["defaultSubcommand",7],[": ",17],["ParsableCommand",18,2],[".Type?",17]],"s":[["var",12],[" ",17],["defaultSubcommand",7],[": ",17],["ParsableCommand",18],[".Type?",17]],"d":"The default command type to run if no subcommand is given."},{"p":["CommandConfiguration","usage"],"f":[["var",12],[" ",17],["usage",7],[": ",17],["String",18,203],["?",17]],"s":[["var",12],[" ",17],["usage",7],[": ",17],["String",18],["?",17]],"d":"A customized usage string to be shown in the help display and error\nmessages.\n\nIf `usage` is `nil`, the help display and errors show the autogenerated\nusage string. To hide the usage string entirely, set `usage` to the empty\nstring."},{"p":["CommandConfiguration","version"],"f":[["var",12],[" ",17],["version",7],[": ",17],["String",18,203]],"s":[["var",12],[" ",17],["version",7],[": ",17],["String",18]],"d":"Version information for this command."},{"p":["CommandConfiguration","abstract"],"f":[["var",12],[" ",17],["abstract",7],[": ",17],["String",18,203]],"s":[["var",12],[" ",17],["abstract",7],[": ",17],["String",18]],"d":"A one-line description of this command."},{"p":["CommandConfiguration","helpNames"],"f":[["var",12],[" ",17],["helpNames",7],[": ",17],["NameSpecification",18,17],["?",17]],"s":[["var",12],[" ",17],["helpNames",7],[": ",17],["NameSpecification",18],["?",17]],"d":"Flag names to be used for help."},{"p":["Flag","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"o":301},{"p":["Flag","wrappedValue"],"f":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18]],"d":"The value presented by this property wrapper."},{"p":["Option","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"o":301},{"p":["Option","wrappedValue"],"f":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["wrappedValue",7],[": ",17],["Value",18]],"d":"The value presented by this property wrapper."},{"p":["ExitCode","rawValue"],"f":[["var",12],[" ",17],["rawValue",7],[": ",17],["Int32",18,322]],"s":[["var",12],[" ",17],["rawValue",7],[": ",17],["Int32",18]],"d":"The exit code represented by this instance.","o":212},{"p":["ExitCode","isSuccess"],"f":[["var",12],[" ",17],["isSuccess",7],[": ",17],["Bool",18,223],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isSuccess",7],[": ",17],["Bool",18]],"d":"A Boolean value indicating whether this exit code represents the\nsuccessful completion of a command."},{"p":["CleanExit","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,203],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"o":301},{"p":["CompletionKind","shellCommand(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["shellCommand",7],["(",17],["_",1],[" ",17],["command",2],[": ",17],["String",18,203],[") -> ",17],["CompletionKind",18,13]],"s":[["static",12],[" ",17],["func",12],[" ",17],["shellCommand",7],["(",17],["String",18],[") -> ",17],["CompletionKind",18]],"d":"Call the given shell command to generate completions."},{"p":["CompletionKind","file(extensions:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["file",7],["(",17],["extensions",1],[": [",17],["String",18,203],["] = []) -> ",17],["CompletionKind",18,13]],"s":[["static",12],[" ",17],["func",12],[" ",17],["file",7],["(",17],["extensions",1],[": [",17],["String",18],["]) -> ",17],["CompletionKind",18]],"d":"Complete file names."},{"p":["CompletionKind","list(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["list",7],["(",17],["_",1],[" ",17],["words",2],[": [",17],["String",18,203],["]) -> ",17],["CompletionKind",18,13]],"s":[["static",12],[" ",17],["func",12],[" ",17],["list",7],["([",17],["String",18],["]) -> ",17],["CompletionKind",18]],"d":"Use the specified list of completion strings."},{"p":["CompletionKind","custom(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["custom",7],["(",17],["_",1],[" ",17],["completion",2],[": ",17],["@escaping",12],[" ([",17],["String",18,203],["]) -> [",17],["String",18,203],["]) -> ",17],["CompletionKind",18,13]],"s":[["static",12],[" ",17],["func",12],[" ",17],["custom",7],["(([",17],["String",18],["]) -> [",17],["String",18],["]) -> ",17],["CompletionKind",18]],"d":"Generate completions using the given closure."},{"p":["EnumerableFlag","help(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["help",7],["(",17],["for",1],[" ",17],["value",2],[": ",17],["Self",18],[") -> ",17],["ArgumentHelp",18,10],["?",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["help",7],["(",17],["for",1],[": ",17],["Self",18],[") -> ",17],["ArgumentHelp",18],["?",17]],"d":"Returns the help information to show for the given flag.\n\nThe default implementation for this method always returns `nil`, which\ngroups the flags together with the help provided in the `@Flag`\ndeclaration. Implement this method for your custom type to provide\ndifferent help information for each flag."},{"p":["EnumerableFlag","name(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["name",7],["(",17],["for",1],[" ",17],["value",2],[": ",17],["Self",18],[") -> ",17],["NameSpecification",18,17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["name",7],["(",17],["for",1],[": ",17],["Self",18],[") -> ",17],["NameSpecification",18]],"d":"Returns the name specification to use for the given flag.\n\nThe default implementation for this method always returns `.long`.\nImplement this method for your custom `EnumerableFlag` type to provide\ndifferent name specifications for different cases."},{"p":["EnumerableFlag","help(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["help",7],["(",17],["for",1],[" ",17],["value",2],[": ",17],["Self",18],[") -> ",17],["ArgumentHelp",18,10],["?",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["help",7],["(",17],["for",1],[": ",17],["Self",18],[") -> ",17],["ArgumentHelp",18],["?",17]],"o":150},{"p":["EnumerableFlag","name(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["name",7],["(",17],["for",1],[" ",17],["value",2],[": ",17],["Self",18],[") -> ",17],["NameSpecification",18,17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["name",7],["(",17],["for",1],[": ",17],["Self",18],[") -> ",17],["NameSpecification",18]],"o":151},{"p":["CompletionShell","autodetected()"],"f":[["static",12],[" ",17],["func",12],[" ",17],["autodetected",7],["() -> ",17],["CompletionShell",18,14],["?",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["autodetected",7],["() -> ",17],["CompletionShell",18],["?",17]],"d":"Returns an instance representing the current shell, if recognized."},{"p":["ParsableCommand","helpMessage(for:includeHidden:columns:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["for",1],[" ",17],["subcommand",2],[": ",17],["ParsableCommand",18,2],[".Type, ",17],["includeHidden",1],[": ",17],["Bool",18,223],[" = false, ",17],["columns",1],[": ",17],["Int",18,228],["? = nil) -> ",17],["String",18,203]],"s":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["for",1],[": ",17],["ParsableCommand",18],[".Type, ",17],["includeHidden",1],[": ",17],["Bool",18],[", ",17],["columns",1],[": ",17],["Int",18],["?) -> ",17],["String",18]],"d":"Returns the text of the help screen for the given subcommand of this\ncommand.\n\n- Parameters:\n  - subcommand: The subcommand to generate the help screen for.\n    `subcommand` must be declared in the subcommand tree of this\n    command.\n  - includeHidden: Include hidden help information in the generated\n    message.\n  - columns: The column width to use when wrapping long line in the\n    help screen. If `columns` is `nil`, uses the current terminal\n    width, or a default value of `80` if the terminal width is not\n    available.\n- Returns: The full help screen for this type."},{"p":["ParsableCommand","helpMessage(for:columns:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["for",1],[" ",17],["subcommand",2],[": ",17],["ParsableCommand",18,2],[".Type, ",17],["columns",1],[": ",17],["Int",18,228],["? = nil) -> ",17],["String",18,203]],"s":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["for",1],[": ",17],["ParsableCommand",18],[".Type, ",17],["columns",1],[": ",17],["Int",18],["?) -> ",17],["String",18]],"a":{"a":{"d":true,"r":"helpMessage(for:includeHidden:columns:)"}},"d":"Returns the text of the help screen for the given subcommand of this\ncommand.\n\n- Parameters:\n  - subcommand: The subcommand to generate the help screen for.\n    `subcommand` must be declared in the subcommand tree of this\n    command.\n  - columns: The column width to use when wrapping long line in the\n    help screen. If `columns` is `nil`, uses the current terminal\n    width, or a default value of `80` if the terminal width is not\n    available.\n- Returns: The full help screen for this type."},{"p":["ParsableCommand","parseAsRoot(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["parseAsRoot",7],["(",17],["_",1],[" ",17],["arguments",2],[": [",17],["String",18,203],["]? = nil) ",17],["throws",12],[" -> ",17],["ParsableCommand",18,2]],"s":[["static",12],[" ",17],["func",12],[" ",17],["parseAsRoot",7],["([",17],["String",18],["]?) ",17],["throws",12],[" -> ",17],["ParsableCommand",18]],"d":"Parses an instance of this type, or one of its subcommands, from\ncommand-line arguments.\n\n- Parameter arguments: An array of arguments to use for parsing. If\n  `arguments` is `nil`, this uses the program's command-line arguments.\n- Returns: A new instance of this type, one of its subcommands, or a\n  command type internal to the `ArgumentParser` library."},{"p":["ParsableCommand","main()"],"f":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["()",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["()",17]],"d":"Executes this command, or one of its subcommands, with the program's\ncommand-line arguments.\n\nInstead of calling this method directly, you can add `@main` to the root\ncommand for your command-line tool.\n\nThis method parses an instance of this type, one of its subcommands, or\nanother built-in `ParsableCommand` type, from command-line arguments,\nand then calls its `run()` method, exiting with a relevant error message\nif necessary."},{"p":["ParsableCommand","main(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["(",17],["_",1],[" ",17],["arguments",2],[": [",17],["String",18,203],["]?)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["([",17],["String",18],["]?)",17]],"d":"Executes this command, or one of its subcommands, with the given\narguments.\n\nThis method parses an instance of this type, one of its subcommands, or\nanother built-in `ParsableCommand` type, from command-line arguments,\nand then calls its `run()` method, exiting with a relevant error message\nif necessary.\n\n- Parameter arguments: An array of arguments to use for parsing. If\n  `arguments` is `nil`, this uses the program's command-line arguments."},{"p":["AsyncMainProtocol","main()"],"f":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["() ",17],["async",12]],"s":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["() ",17],["async",12]],"a":{"s":{"d":"5.6"},"iOS":{"i":"13"},"macOS":{"i":"10.15"},"macCatalyst":{"i":"13"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Executes the designated command type, or one of its subcommands, with\nthe program's command-line arguments."},{"p":["NameSpecification","customLong(_:withSingleDash:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["customLong",7],["(",17],["_",1],[" ",17],["name",2],[": ",17],["String",18,203],[", ",17],["withSingleDash",1],[": ",17],["Bool",18,223],[" = false) -> ",17],["NameSpecification",18,17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["customLong",7],["(",17],["String",18],[", ",17],["withSingleDash",1],[": ",17],["Bool",18],[") -> ",17],["NameSpecification",18]],"d":"Use the given string instead of the property's name.\n\nTo create a single-dash argument, pass `true` as `withSingleDash`. Note\nthat combining single-dash options and options with short,\nsingle-character names can lead to ambiguities for the user.\n\n- Parameters:\n  - name: The name of the option or flag.\n  - withSingleDash: A Boolean value indicating whether to use a single\n    dash as the prefix. If `false`, the name has a double-dash prefix."},{"p":["NameSpecification","customShort(_:allowingJoined:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["customShort",7],["(",17],["_",1],[" ",17],["char",2],[": ",17],["Character",18,187],[", ",17],["allowingJoined",1],[": ",17],["Bool",18,223],[" = false) -> ",17],["NameSpecification",18,17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["customShort",7],["(",17],["Character",18],[", ",17],["allowingJoined",1],[": ",17],["Bool",18],[") -> ",17],["NameSpecification",18]],"d":"Use the given character as a short option label.\n\nWhen passing `true` as `allowingJoined` in an `@Option` declaration,\nthe user can join a value with the option name. For example, if an\noption is declared as `-D`, allowing joined values, a user could pass\n`-Ddebug` to specify `debug` as the value for that option.\n\n- Parameters:\n  - char: The name of the option or flag.\n  - allowingJoined: A Boolean value indicating whether this short name\n    allows a joined value."},{"p":["NameSpecification","Element","customLong(_:withSingleDash:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["customLong",7],["(",17],["_",1],[" ",17],["name",2],[": ",17],["String",18,203],[", ",17],["withSingleDash",1],[": ",17],["Bool",18,223],[" = false) -> ",17],["NameSpecification",18,17],[".",17],["Element",18,18]],"s":[["static",12],[" ",17],["func",12],[" ",17],["customLong",7],["(",17],["String",18],[", ",17],["withSingleDash",1],[": ",17],["Bool",18],[") -> ",17],["NameSpecification",18],[".",17],["Element",18]],"d":"Use the given string instead of the property's name.\n\nTo create a single-dash argument, pass `true` as `withSingleDash`. Note\nthat combining single-dash options and options with short,\nsingle-character names can lead to ambiguities for the user.\n\n- Parameters:\n  - name: The name of the option or flag.\n  - withSingleDash: A Boolean value indicating whether to use a single\n    dash as the prefix. If `false`, the name has a double-dash prefix."},{"p":["NameSpecification","Element","customShort(_:allowingJoined:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["customShort",7],["(",17],["_",1],[" ",17],["char",2],[": ",17],["Character",18,187],[", ",17],["allowingJoined",1],[": ",17],["Bool",18,223],[" = false) -> ",17],["NameSpecification",18,17],[".",17],["Element",18,18]],"s":[["static",12],[" ",17],["func",12],[" ",17],["customShort",7],["(",17],["Character",18],[", ",17],["allowingJoined",1],[": ",17],["Bool",18],[") -> ",17],["NameSpecification",18],[".",17],["Element",18]],"d":"Use the given character as a short option label.\n\nWhen passing `true` as `allowingJoined` in an `@Option` declaration,\nthe user can join a value with the option name. For example, if an\noption is declared as `-D`, allowing joined values, a user could pass\n`-Ddebug` to specify `debug` as the value for that option.\n\n- Parameters:\n  - char: The name of the option or flag.\n  - allowingJoined: A Boolean value indicating whether this short name\n    allows a joined value."},{"p":["ParsableArguments","fullMessage(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["fullMessage",7],["(",17],["for",1],[" ",17],["error",2],[": ",17],["Error",18,319],[") -> ",17],["String",18,203]],"s":[["static",12],[" ",17],["func",12],[" ",17],["fullMessage",7],["(",17],["for",1],[": ",17],["Error",18],[") -> ",17],["String",18]],"d":"Returns a full message for the given error, including usage information,\nif appropriate.\n\n- Parameter error: An error to generate a message for.\n- Returns: A message that can be displayed to the user."},{"p":["ParsableArguments","helpMessage(includeHidden:columns:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["includeHidden",1],[": ",17],["Bool",18,223],[" = false, ",17],["columns",1],[": ",17],["Int",18,228],["? = nil) -> ",17],["String",18,203]],"s":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["includeHidden",1],[": ",17],["Bool",18],[", ",17],["columns",1],[": ",17],["Int",18],["?) -> ",17],["String",18]],"d":"Returns the text of the help screen for this type.\n\n- Parameters:\n  - includeHidden: Include hidden help information in the generated\n    message.\n  - columns: The column width to use when wrapping long line in the\n    help screen. If `columns` is `nil`, uses the current terminal\n    width, or a default value of `80` if the terminal width is not\n    available.\n- Returns: The full help screen for this type."},{"p":["ParsableArguments","helpMessage(columns:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["columns",1],[": ",17],["Int",18,228],["?) -> ",17],["String",18,203]],"s":[["static",12],[" ",17],["func",12],[" ",17],["helpMessage",7],["(",17],["columns",1],[": ",17],["Int",18],["?) -> ",17],["String",18]],"a":{"a":{"d":true,"m":"Use helpMessage(includeHidden:columns:) instead."}},"d":"Returns the text of the help screen for this type.\n\n- Parameters:\n  - columns: The column width to use when wrapping long line in the\n    help screen. If `columns` is `nil`, uses the current terminal\n    width, or a default value of `80` if the terminal width is not\n    available.\n- Returns: The full help screen for this type."},{"p":["ParsableArguments","parseOrExit(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["parseOrExit",7],["(",17],["_",1],[" ",17],["arguments",2],[": [",17],["String",18,203],["]? = nil) -> ",17],["Self",18]],"s":[["static",12],[" ",17],["func",12],[" ",17],["parseOrExit",7],["([",17],["String",18],["]?) -> ",17],["Self",18]],"d":"Parses a new instance of this type from command-line arguments or exits\nwith a relevant message.\n\n- Parameter arguments: An array of arguments to use for parsing. If\n  `arguments` is `nil`, this uses the program's command-line arguments."},{"p":["ParsableArguments","completionScript(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["completionScript",7],["(",17],["for",1],[" ",17],["shell",2],[": ",17],["CompletionShell",18,14],[") -> ",17],["String",18,203]],"s":[["static",12],[" ",17],["func",12],[" ",17],["completionScript",7],["(",17],["for",1],[": ",17],["CompletionShell",18],[") -> ",17],["String",18]],"d":"Returns a shell completion script for the specified shell.\n\n- Parameter shell: The shell to generate a completion script for.\n- Returns: The completion script for `shell`."},{"p":["ParsableArguments","exit(withError:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["exit",7],["(",17],["withError",1],[" ",17],["error",2],[": ",17],["Error",18,319],["? = nil) -> ",17],["Never",18,324]],"s":[["static",12],[" ",17],["func",12],[" ",17],["exit",7],["(",17],["withError",1],[": ",17],["Error",18],["?) -> ",17],["Never",18]],"d":"Terminates execution with a message and exit code that is appropriate\nfor the given error.\n\nIf the `error` parameter is `nil`, this method prints nothing and exits\nwith code `EXIT_SUCCESS`. If `error` represents a help request or\nanother `CleanExit` error, this method prints help information and\nexits with code `EXIT_SUCCESS`. Otherwise, this method prints a relevant\nerror message and exits with code `EX_USAGE` or `EXIT_FAILURE`.\n\n- Parameter error: The error to use when exiting, if any."},{"p":["ParsableArguments","parse(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["parse",7],["(",17],["_",1],[" ",17],["arguments",2],[": [",17],["String",18,203],["]? = nil) ",17],["throws",12],[" -> ",17],["Self",18]],"s":[["static",12],[" ",17],["func",12],[" ",17],["parse",7],["([",17],["String",18],["]?) ",17],["throws",12],[" -> ",17],["Self",18]],"d":"Parses a new instance of this type from command-line arguments.\n\n- Parameter arguments: An array of arguments to use for parsing. If\n  `arguments` is `nil`, this uses the program's command-line arguments.\n- Returns: A new instance of this type."},{"p":["ParsableArguments","message(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["message",7],["(",17],["for",1],[" ",17],["error",2],[": ",17],["Error",18,319],[") -> ",17],["String",18,203]],"s":[["static",12],[" ",17],["func",12],[" ",17],["message",7],["(",17],["for",1],[": ",17],["Error",18],[") -> ",17],["String",18]],"d":"Returns a brief message for the given error.\n\n- Parameter error: An error to generate a message for.\n- Returns: A message that can be displayed to the user."},{"p":["ParsableArguments","exitCode(for:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["exitCode",7],["(",17],["for",1],[" ",17],["error",2],[": ",17],["Error",18,319],[") -> ",17],["ExitCode",18,24]],"s":[["static",12],[" ",17],["func",12],[" ",17],["exitCode",7],["(",17],["for",1],[": ",17],["Error",18],[") -> ",17],["ExitCode",18]],"d":"Returns the exit code for the given error.\n\nThe returned code is the same exit code that is used if `error` is passed\nto `exit(withError:)`.\n\n- Parameter error: An error to generate an exit code for.\n- Returns: The exit code for `error`."},{"p":["AsyncParsableCommand","main()"],"f":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["() ",17],["async",12]],"s":[["static",12],[" ",17],["func",12],[" ",17],["main",7],["() ",17],["async",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"macCatalyst":{"i":"13"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Executes this command, or one of its subcommands, with the program's\ncommand-line arguments.\n\nInstead of calling this method directly, you can add `@main` to the root\ncommand for your command-line tool."},{"p":["CleanExit","helpRequest(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["helpRequest",7],["(",17],["_",1],[" ",17],["command",2],[": ",17],["ParsableCommand",18,2],[") -> ",17],["CleanExit",18,25]],"s":[["static",12],[" ",17],["func",12],[" ",17],["helpRequest",7],["(",17],["ParsableCommand",18],[") -> ",17],["CleanExit",18]],"d":"Treat this error as a help request and display the full help message.\n\nYou can use this case to simulate the user specifying one of the help\nflags or subcommands.\n\n- Parameter command: A command to offer help for, if different from\n  the root command."},{"p":["CleanExit","helpRequest(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["helpRequest",7],["(",17],["_",1],[" ",17],["type",2],[": ",17],["ParsableCommand",18,2],[".Type? = nil) -> ",17],["CleanExit",18,25]],"s":[["static",12],[" ",17],["func",12],[" ",17],["helpRequest",7],["(",17],["ParsableCommand",18],[".Type?) -> ",17],["CleanExit",18]],"d":"Treat this error as a help request and display the full help message.\n\nYou can use this case to simulate the user specifying one of the help\nflags or subcommands.\n\n- Parameter command: The command type to offer help for, if different\n  from the root command."},{"p":["CleanExit","message(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["message",7],["(",17],["_",1],[" ",17],["text",2],[": ",17],["String",18,203],[") -> ",17],["CleanExit",18,25]],"s":[["static",12],[" ",17],["func",12],[" ",17],["message",7],["(",17],["String",18],[") -> ",17],["CleanExit",18]],"d":"Treat this error as a clean exit with the given message."},{"p":["ParsableCommand","run()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["run",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["run",7],["() ",17],["throws",12]],"d":"The behavior or functionality of this command.\n\nImplement this method in your `ParsableCommand`-conforming type with the\nfunctionality that this command represents.\n\nThis method has a default implementation that prints the help screen for\nthis command."},{"p":["ParsableCommand","run()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["run",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["run",7],["() ",17],["throws",12]],"o":178},{"p":["ParsableArguments","validate()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["validate",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["validate",7],["() ",17],["throws",12]],"d":"Validates the properties of the instance after parsing.\n\nImplement this method to perform validation or other processing after\ncreating a new instance from command-line arguments."},{"p":["ParsableArguments","validate()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["validate",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["validate",7],["() ",17],["throws",12]],"o":180},{"p":["AsyncParsableCommand","run()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["run",7],["() ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["run",7],["() ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"macCatalyst":{"i":"13"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"The behavior or functionality of this command.\n\nImplement this method in your `ParsableCommand`-conforming type with the\nfunctionality that this command represents.\n\nThis method has a default implementation that prints the help screen for\nthis command."},{"p":["String","init(argument:)"],"f":[["init",10],["?(",17],["argument",1],[": ",17],["String",18,203],[")",17]],"s":[["init",10],["?(",17],["argument",1],[": ",17],["String",18],[")",17]],"o":26},{"p":["RawRepresentable","init(argument:)"],"f":[["init",10],["?(",17],["argument",1],[": ",17],["String",18,203],[")",17]],"s":[["init",10],["?(",17],["argument",1],[": ",17],["String",18],[")",17]],"e":[["Self",1,"ExpressibleByArgument",0],["Self.RawValue",1,"ExpressibleByArgument",0]],"c":[["Self",1,"ExpressibleByArgument",0],["Self.RawValue",1,"ExpressibleByArgument",0]]},{"p":["LosslessStringConvertible","init(argument:)"],"f":[["init",10],["?(",17],["argument",1],[": ",17],["String",18,203],[")",17]],"s":[["init",10],["?(",17],["argument",1],[": ",17],["String",18],[")",17]],"e":[["Self",1,"ExpressibleByArgument",0]],"c":[["Self",1,"ExpressibleByArgument",0]]}],"edges":{"conformer":[1,200,[],1,258,[],2,4,[],2,225,[],4,225,[],5,2,[],5,4,[],5,225,[],7,225,[],7,300,[],9,186,[],9,200,[],10,306,[],10,311,[],10,313,[],10,315,[],11,225,[],11,300,[["Value",1,"ParsableArguments",4]],12,186,[],12,200,[],14,186,[],14,200,[],14,211,[],14,258,[],15,186,[],15,200,[],16,300,[],16,319,[],16,330,[],17,303,[],18,186,[],18,200,[],19,186,[],19,200,[],21,186,[],21,200,[],22,225,[],22,300,[],23,225,[],23,300,[],24,186,[],24,200,[],24,211,[],24,319,[],24,330,[],25,300,[],25,319,[],25,330,[],203,0,[],223,0,[],224,0,[],227,0,[],228,0,[],230,0,[],318,0,[],321,0,[],322,0,[],323,0,[],325,0,[],326,0,[],327,0,[],328,0,[]],"feature":[76,203,76,223,76,224,76,227,76,228,76,230,76,318,76,321,76,322,76,323,76,325,76,326,76,327,76,328,77,203,77,223,77,224,77,227,77,228,77,230,77,318,77,321,77,322,77,323,77,325,77,326,77,327,77,328,117,203,117,223,117,224,117,227,117,228,117,230,117,318,117,321,117,322,117,323,117,325,117,326,117,327,117,328,185,228,185,230,185,318,185,321,185,322,185,323,185,325,185,326,185,327,185,328,192,228,192,230,192,318,192,321,192,322,192,323,192,325,192,326,192,327,192,328,193,228,193,230,193,318,193,321,193,322,193,323,193,325,193,326,193,327,193,328,194,228,194,230,194,318,194,321,194,322,194,323,194,325,194,326,194,327,194,328,195,228,195,230,195,318,195,321,195,322,195,323,195,325,195,326,195,327,195,328,196,228,196,230,196,318,196,321,196,322,196,323,196,325,196,326,196,327,196,328,197,228,197,230,197,318,197,321,197,322,197,323,197,325,197,326,197,327,197,328,198,228,198,230,198,318,198,321,198,322,198,323,198,325,198,326,198,327,198,328,199,228,199,230,199,318,199,321,199,322,199,323,199,325,199,326,199,327,199,328,202,9,202,12,202,14,202,15,202,18,202,19,202,21,202,24,205,230,205,325,205,326,205,327,205,328,206,230,206,325,206,326,206,327,206,328,207,230,207,325,207,326,207,327,207,328,208,230,208,325,208,326,208,327,208,328,209,230,209,325,209,326,209,327,209,328,210,230,210,325,210,326,210,327,210,328,214,14,214,24,215,14,215,24,216,228,216,318,216,321,216,322,216,323,217,228,217,318,217,321,217,322,217,323,218,228,218,318,218,321,218,322,218,323,219,228,219,318,219,321,219,322,219,323,220,228,220,318,220,321,220,322,220,323,221,228,221,318,221,321,221,322,221,323,231,228,231,230,231,318,231,321,231,322,231,323,231,325,231,326,231,327,231,328,232,228,232,230,232,318,232,321,232,322,232,323,232,325,232,326,232,327,232,328,234,228,234,230,234,318,234,321,234,322,234,323,234,325,234,326,234,327,234,328,237,230,237,325,237,326,237,327,237,328,238,228,238,230,238,318,238,321,238,322,238,323,238,325,238,326,238,327,238,328,239,228,239,230,239,318,239,321,239,322,239,323,239,325,239,326,239,327,239,328,240,228,240,230,240,318,240,321,240,322,240,323,240,325,240,326,240,327,240,328,241,228,241,230,241,318,241,321,241,322,241,323,241,325,241,326,241,327,241,328,242,228,242,230,242,318,242,321,242,322,242,323,242,325,242,326,242,327,242,328,243,228,243,230,243,318,243,321,243,322,243,323,243,325,243,326,243,327,243,328,244,228,244,230,244,318,244,321,244,322,244,323,244,325,244,326,244,327,244,328,245,228,245,230,245,318,245,321,245,322,245,323,245,325,245,326,245,327,245,328,246,228,246,230,246,318,246,321,246,322,246,323,246,325,246,326,246,327,246,328,247,228,247,230,247,318,247,321,247,322,247,323,247,325,247,326,247,327,247,328,248,228,248,230,248,318,248,321,248,322,248,323,248,325,248,326,248,327,248,328,249,228,249,230,249,318,249,321,249,322,249,323,249,325,249,326,249,327,249,328,250,228,250,230,250,318,250,321,250,322,250,323,250,325,250,326,250,327,250,328,251,228,251,230,251,318,251,321,251,322,251,323,251,325,251,326,251,327,251,328,252,228,252,230,252,318,252,321,252,322,252,323,252,325,252,326,252,327,252,328,253,228,253,230,253,318,253,321,253,322,253,323,253,325,253,326,253,327,253,328,254,228,254,230,254,318,254,321,254,322,254,323,254,325,254,326,254,327,254,328,255,230,255,318,255,321,255,322,255,323,255,325,255,326,255,327,255,328,256,230,256,318,256,321,256,322,256,323,256,325,256,326,256,327,256,328,257,228,257,230,257,318,257,321,257,322,257,323,257,325,257,326,257,327,257,328,260,228,260,318,260,321,260,322,260,323,261,228,261,318,261,321,261,322,261,323,262,228,262,230,262,318,262,321,262,322,262,323,262,325,262,326,262,327,262,328,263,228,263,230,263,318,263,321,263,322,263,323,263,325,263,326,263,327,263,328,264,228,264,230,264,318,264,321,264,322,264,323,264,325,264,326,264,327,264,328,265,228,265,230,265,318,265,321,265,322,265,323,265,325,265,326,265,327,265,328,266,228,266,230,266,318,266,321,266,322,266,323,266,325,266,326,266,327,266,328,267,228,267,230,267,318,267,321,267,322,267,323,267,325,267,326,267,327,267,328,268,228,268,230,268,318,268,321,268,322,268,323,268,325,268,326,268,327,268,328,269,228,269,230,269,318,269,321,269,322,269,323,269,325,269,326,269,327,269,328,270,228,270,230,270,318,270,321,270,322,270,323,270,325,270,326,270,327,270,328,271,228,271,230,271,318,271,321,271,322,271,323,271,325,271,326,271,327,271,328,272,228,272,230,272,318,272,321,272,322,272,323,272,325,272,326,272,327,272,328,273,228,273,230,273,318,273,321,273,322,273,323,273,325,273,326,273,327,273,328,274,228,274,230,274,318,274,321,274,322,274,323,274,325,274,326,274,327,274,328,275,228,275,230,275,318,275,321,275,322,275,323,275,325,275,326,275,327,275,328,276,228,276,230,276,318,276,321,276,322,276,323,276,325,276,326,276,327,276,328,277,228,277,230,277,318,277,321,277,322,277,323,277,325,277,326,277,327,277,328,278,228,278,230,278,318,278,321,278,322,278,323,278,325,278,326,278,327,278,328,279,228,279,230,279,318,279,321,279,322,279,323,279,325,279,326,279,327,279,328,280,228,280,230,280,318,280,321,280,322,280,323,280,325,280,326,280,327,280,328,281,228,281,230,281,318,281,321,281,322,281,323,281,325,281,326,281,327,281,328,282,228,282,230,282,318,282,321,282,322,282,323,282,325,282,326,282,327,282,328,283,228,283,230,283,318,283,321,283,322,283,323,283,325,283,326,283,327,283,328,284,228,284,230,284,318,284,321,284,322,284,323,284,325,284,326,284,327,284,328,285,228,285,230,285,318,285,321,285,322,285,323,285,325,285,326,285,327,285,328,286,228,286,230,286,318,286,321,286,322,286,323,286,325,286,326,286,327,286,328,287,228,287,230,287,318,287,321,287,322,287,323,287,325,287,326,287,327,287,328,288,228,288,230,288,318,288,321,288,322,288,323,288,325,288,326,288,327,288,328,289,228,289,230,289,318,289,321,289,322,289,323,289,325,289,326,289,327,289,328,290,228,290,230,290,318,290,321,290,322,290,323,290,325,290,326,290,327,290,328,291,228,291,230,291,318,291,321,291,322,291,323,291,325,291,326,291,327,291,328,292,228,292,230,292,318,292,321,292,322,292,323,292,325,292,326,292,327,292,328,293,228,293,230,293,318,293,321,293,322,293,323,293,325,293,326,293,327,293,328,296,228,296,230,296,318,296,321,296,322,296,323,296,325,296,326,296,327,296,328,297,228,297,230,297,318,297,321,297,322,297,323,297,325,297,326,297,327,297,328,298,228,298,230,298,318,298,321,298,322,298,323,298,325,298,326,298,327,298,328,299,228,299,230,299,318,299,321,299,322,299,323,299,325,299,326,299,327,299,328,302,7,302,11,302,16,302,22,302,23,302,25,302,228,302,230,302,318,302,321,302,322,302,323,302,325,302,326,302,327,302,328,308,10,310,228,310,230,310,318,310,321,310,322,310,323,310,325,310,326,310,327,310,328,312,10,317,10,320,16,320,24,320,25],"member":[18,17,27,7,28,7,29,7,30,7,31,7,32,7,33,7,34,7,35,7,36,7,37,10,38,10,39,10,40,11,41,11,42,11,43,14,44,16,45,17,46,17,48,20,49,20,50,22,51,22,52,22,53,22,54,22,55,22,56,22,57,22,58,22,59,22,60,22,61,23,62,23,63,23,64,23,65,23,66,23,67,23,68,23,69,23,70,23,71,23,72,24,73,24,81,8,82,8,83,8,84,9,85,9,86,10,87,10,88,12,89,12,90,13,91,13,92,14,93,14,94,14,95,14,96,15,97,15,98,15,101,17,102,17,103,17,104,18,105,18,106,19,107,19,108,19,109,19,110,21,111,21,112,21,113,24,114,24,115,24,118,7,119,7,120,10,121,10,122,10,123,10,124,10,125,11,126,11,127,14,128,16,129,16,130,20,131,20,132,20,133,20,134,20,135,20,136,20,137,20,138,20,139,22,140,22,141,23,142,23,143,24,144,24,145,25,146,13,147,13,148,13,149,13,154,14,155,2,156,2,157,2,158,2,159,2,160,3,161,17,162,17,163,18,164,18,165,4,166,4,167,4,168,4,169,4,170,4,171,4,172,4,173,4,174,5,175,25,176,25,177,25,183,203,184,211,185,305],"requirement":[6,3,26,0,47,4,74,0,75,0,99,2,116,0,150,1,151,1,178,2,180,4,182,5],"defaultImplementation":[76,74,77,75,78,74,79,74,80,75,100,99,117,116,152,150,153,151,179,178,181,180]},"sourcemap":[{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Completions/CompletionsGenerator.swift","symbols":[22,14,14,23,13,127,26,9,43,36,20,92,39,20,93,42,20,94,45,21,154,57,20,95]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/Argument.swift","symbols":[42,14,7,51,9,30,70,13,119,86,13,118,124,9,35,145,9,36,159,14,9,177,20,85,207,20,84,219,9,32,276,9,27,301,9,31,365,9,29,392,9,34,466,9,28,496,9,33]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/ArgumentHelp.swift","symbols":[12,14,10,14,13,123,17,13,120,24,13,124,28,13,121,33,13,122,44,9,39,57,9,38,70,20,86,75,20,87,81,9,37]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/ArgumentVisibility.swift","symbols":[12,14,8,24,20,82,27,20,81,30,20,83]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/CompletionKind.swift","symbols":[12,14,13,36,20,90,41,21,148,46,21,147,51,20,91,56,21,146,61,21,149]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/Errors.swift","symbols":[27,14,16,31,27,129,34,9,44,38,13,128,48,14,24,50,13,143,53,9,73,57,9,72,62,20,115,65,20,114,73,20,113,78,13,144,88,14,25,104,21,176,109,21,177,120,21,175,124,13,145]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/Flag.swift","symbols":[69,14,22,76,9,52,96,13,140,112,13,139,125,14,12,141,20,88,153,20,89,159,14,15,169,20,98,174,20,97,179,20,96,204,9,59,243,9,56,293,9,57,325,9,58,350,9,60,412,9,55,442,9,54,457,9,50,518,9,51,538,9,53]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/NameSpecification.swift","symbols":[13,14,17,15,16,18,30,22,104,44,23,163,52,22,105,67,23,164,73,9,46,77,9,45,88,20,102,100,21,161,108,20,103,121,21,162,130,20,101]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/Option.swift","symbols":[49,14,23,56,9,64,75,13,142,91,13,141,130,9,69,158,9,70,185,9,71,203,14,21,217,20,112,233,20,111,246,20,110,253,14,19,268,20,106,285,20,108,299,20,107,326,20,109,344,9,68,410,9,62,442,9,66,509,9,63,538,9,67,619,9,61,651,9,65]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Properties/OptionGroup.swift","symbols":[31,14,11,44,9,41,65,9,40,73,13,126,89,13,125,109,9,42]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/AsyncParsableCommand.swift","symbols":[14,16,5,22,16,182,32,21,174,53,16,3,54,17,6,62,21,160]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/CommandConfiguration.swift","symbols":[12,14,20,17,13,131,27,13,137,35,13,135,39,13,130,42,13,136,46,13,133,49,13,132,52,13,134,55,13,138,82,9,49,133,9,48]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/EnumerableFlag.swift","symbols":[53,16,1,59,14,151,67,14,150,71,21,153,75,21,152]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/ExpressibleByArgument.swift","symbols":[12,16,0,15,2,26,19,6,116,25,13,74,31,13,75,35,13,117,39,20,76,41,20,77,47,20,79,51,20,80,57,20,78,63,9,183,69,9,184,81,9,185]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/ParsableArguments.swift","symbols":[28,16,4,31,2,47,37,16,180,71,23,181,92,21,171,118,21,172,129,21,165,145,21,167,161,21,166,181,21,173,191,21,169,206,21,170,230,21,168]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-argument-parser@1.1.3/.build/checkouts/swift-argument-parser/Sources/ArgumentParser/Parsable Types/ParsableCommand.swift","symbols":[12,16,2,15,13,99,31,16,178,42,20,100,46,23,179,61,21,157,83,21,156,104,21,155,125,21,159,151,21,158]}]}