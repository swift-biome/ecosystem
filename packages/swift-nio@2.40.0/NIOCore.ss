{"culture":"NIOCore","dependencies":[{"package":"swift-nio","modules":["NIOConcurrencyHelpers"]}],"extensions":[],"partitions":[{"namespace":"_Concurrency","communities":[{"community":"method","startIndex":0,"endIndex":4}]},{"namespace":"Dispatch","communities":[{"community":"init","startIndex":4,"endIndex":5},{"community":"method","startIndex":5,"endIndex":6}]},{"namespace":"NIOCore","communities":[{"community":"protocol","startIndex":6,"endIndex":29},{"community":"associatedtype","startIndex":29,"endIndex":38},{"community":"enum","startIndex":38,"endIndex":58},{"community":"struct","startIndex":58,"endIndex":118},{"community":"class","startIndex":118,"endIndex":131},{"community":"enum.case","startIndex":131,"endIndex":191},{"community":"init","startIndex":191,"endIndex":276},{"community":"subscript","startIndex":276,"endIndex":283},{"community":"type.property","startIndex":283,"endIndex":344},{"community":"property","startIndex":344,"endIndex":478},{"community":"type.method","startIndex":478,"endIndex":502},{"community":"method","startIndex":502,"endIndex":1002},{"community":"type.op","startIndex":1002,"endIndex":1024},{"community":"typealias","startIndex":1024,"endIndex":1088}]},{"namespace":"Swift","communities":[{"community":"init","startIndex":1088,"endIndex":1090},{"community":"method","startIndex":1090,"endIndex":1092}]}],"identifiers":["sSci7NIOCoreAA10ByteBufferV7ElementRtzrlE7collect4upTo4intoySi_ACztYaKF","sSci7NIOCoreAA10ByteBufferV7ElementRtzrlE7collect4upToACSi_tYaKF","sSci7NIOCoreSk7ElementRpzs5UInt8VAB_ABRTzrlE7collect4upTo4intoySi_AA10ByteBufferVztYaKF","sSci7NIOCoreSk7ElementRpzs5UInt8VAB_ABRTzrlE7collect4upTo5usingAA10ByteBufferVSi_AA0hI9AllocatorVtYaKF","s8Dispatch0A4DataV7NIOCoreE6bufferAcD10ByteBufferV_tcfc","s8Dispatch0A5QueueC7NIOCoreE15asyncWithFuture9eventLoop_AD05EventhF0CyxGAD0iH0_p_xyKctlF","s7NIOCore11ChannelCoreP","s7NIOCore13ChannelOptionP","s7NIOCore14ChannelHandlerP","s7NIOCore14ChannelInvokerP","s7NIOCore14EventLoopGroupP","s7NIOCore14FileDescriptorP","s7NIOCore16MulticastChannelP","s7NIOCore20ByteToMessageDecoderP","s7NIOCore20MessageToByteEncoderP","s7NIOCore20NIOClientTLSProviderP","s7NIOCore20SocketOptionProviderP","s7NIOCore21ChannelInboundHandlerP","s7NIOCore21ChannelInboundInvokerP","s7NIOCore22ChannelOutboundHandlerP","s7NIOCore22ChannelOutboundInvokerP","s7NIOCore23RecvByteBufferAllocatorP","s7NIOCore23RemovableChannelHandlerP","s7NIOCore28NIOSynchronousChannelOptionsP","s7NIOCore29NIOClientTCPBootstrapProtocolP","s7NIOCore33NIOSingleStepByteToMessageDecoderP","s7NIOCore34WriteObservingByteToMessageDecoderP","s7NIOCore7ChannelP","s7NIOCore9EventLoopP","s7NIOCore13ChannelOptionP5ValueQa","s7NIOCore20ByteToMessageDecoderP10InboundOutQa","s7NIOCore20MessageToByteEncoderP10OutboundInQa","s7NIOCore20NIOClientTLSProviderP9BootstrapQa","s7NIOCore21ChannelInboundHandlerP0C2InQa","s7NIOCore21ChannelInboundHandlerP0C3OutQa","s7NIOCore22ChannelOutboundHandlerP0C2InQa","s7NIOCore33NIOSingleStepByteToMessageDecoderP10InboundOutQa","s7NIOCore34WriteObservingByteToMessageDecoderP10OutboundInQa","s7NIOCore10EndiannessO","s7NIOCore12ChannelErrorO","s7NIOCore12ChannelEventO","s7NIOCore12NIOBSDSocketO","s7NIOCore13DecodingStateO","s7NIOCore13SocketAddressO","s7NIOCore14ChannelOptionsV5TypesO","s7NIOCore14ChannelOptionsV5TypesO22ConvenienceOptionValueO","s7NIOCore14EventLoopErrorO","s7NIOCore15ChannelPipelineC8PositionO","s7NIOCore16IdleStateHandlerC0bC5EventO","s7NIOCore18SocketAddressErrorO","s7NIOCore20ChannelPipelineErrorO","s7NIOCore25ByteToMessageDecoderErrorO","s7NIOCore25NIOEventLoopGroupProviderO","s7NIOCore38NIOExplicitCongestionNotificationStateO","s7NIOCore6IODataO","s7NIOCore6SystemO","s7NIOCore7IOErrorV18FailureDescriptionO","s7NIOCore9CloseModeO","s7NIOCore10ByteBufferV","s7NIOCore10ByteBufferV14CopyBytesErrorV","s7NIOCore10ByteBufferV17LengthPrefixErrorV","s7NIOCore10FileRegionV","s7NIOCore10TimeAmountV","s7NIOCore11NIODeadlineV","s7NIOCore12NIOBSDSocketO11OptionLevelV","s7NIOCore12NIOBSDSocketO13AddressFamilyV","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV","s7NIOCore12NIOBSDSocketO6OptionV","s7NIOCore13NIOFileHandleC4ModeV","s7NIOCore13NIOFileHandleC5FlagsV","s7NIOCore13NIOPacketInfoV","s7NIOCore13SocketAddressO04IPv4C0V","s7NIOCore13SocketAddressO04IPv6C0V","s7NIOCore13SocketAddressO04UnixbC0V","s7NIOCore14ByteBufferViewV","s7NIOCore14ChannelOptionsV","s7NIOCore14ChannelOptionsV014TCPConvenienceC0V","s7NIOCore14ChannelOptionsV20TCPConvenienceOptionV","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV","s7NIOCore14ChannelOptionsV5TypesO13BacklogOptionV","s7NIOCore14ChannelOptionsV5TypesO14AutoReadOptionV","s7NIOCore14ChannelOptionsV5TypesO15AllocatorOptionV","s7NIOCore14ChannelOptionsV5TypesO15WriteSpinOptionV","s7NIOCore14ChannelOptionsV5TypesO17ReceivePacketInfoV","s7NIOCore14ChannelOptionsV5TypesO19RecvAllocatorOptionV","s7NIOCore14ChannelOptionsV5TypesO20ConnectTimeoutOptionV","s7NIOCore14ChannelOptionsV5TypesO20WriteBufferWaterMarkV","s7NIOCore14ChannelOptionsV5TypesO24MaxMessagesPerReadOptionV","s7NIOCore14ChannelOptionsV5TypesO26WriteBufferWaterMarkOptionV","s7NIOCore14ChannelOptionsV5TypesO28AllowRemoteHalfClosureOptionV","s7NIOCore14ChannelOptionsV5TypesO36DatagramVectorReadMessageCountOptionV","s7NIOCore14ChannelOptionsV5TypesO37ExplicitCongestionNotificationsOptionV","s7NIOCore14ChannelOptionsV7StorageV","s7NIOCore14CircularBufferV","s7NIOCore14CircularBufferV5IndexV","s7NIOCore15ChannelPipelineC21SynchronousOperationsV","s7NIOCore16EventLoopPromiseV","s7NIOCore16NIOInsecureNoTLSV","s7NIOCore16NIONetworkDeviceV","s7NIOCore17AddressedEnvelopeV","s7NIOCore17AddressedEnvelopeV8MetadataV","s7NIOCore17EventLoopIteratorV","s7NIOCore18SocketAddressErrorO25FailedToParseIPByteBufferV","s7NIOCore19ByteBufferAllocatorV","s7NIOCore20MarkedCircularBufferV","s7NIOCore20NIOTooManyBytesErrorV","s7NIOCore21ChannelHandlerContextC12RemovalTokenV","s7NIOCore21NIOClientTCPBootstrapV","s7NIOCore25ByteToMessageDecoderErrorO015PayloadTooLargeF0V","s7NIOCore25ChannelShouldQuiesceEventV","s7NIOCore29NIOMulticastNotSupportedErrorV","s7NIOCore31AdaptiveRecvByteBufferAllocatorV","s7NIOCore31NIOMulticastNotImplementedErrorV","s7NIOCore32FixedSizeRecvByteBufferAllocatorV","s7NIOCore45NIOAttemptedToRemoveHandlerMultipleTimesErrorV","s7NIOCore6NIOAnyV","s7NIOCore7IOErrorV","s7NIOCore9ScheduledV","s7NIOCore12RepeatedTaskC","s7NIOCore13NIOFileHandleC","s7NIOCore15ChannelPipelineC","s7NIOCore15EventLoopFutureC","s7NIOCore16IdleStateHandlerC","s7NIOCore19BackPressureHandlerC","s7NIOCore19NIONetworkInterfaceC","s7NIOCore20AcceptBackoffHandlerC","s7NIOCore20ByteToMessageHandlerC","s7NIOCore20MessageToByteHandlerC","s7NIOCore21ChannelHandlerContextC","s7NIOCore22NIOCloseOnErrorHandlerC","s7NIOCore35NIOSingleStepByteToMessageProcessorC","s7NIOCore10EndiannessO3bigyA2CmF","s7NIOCore10EndiannessO6littleyA2CmF","s7NIOCore12ChannelErrorO010ioOnClosedB0yA2CmF","s7NIOCore12ChannelErrorO11inputClosedyA2CmF","s7NIOCore12ChannelErrorO12outputClosedyA2CmF","s7NIOCore12ChannelErrorO13alreadyClosedyA2CmF","s7NIOCore12ChannelErrorO14connectPendingyA2CmF","s7NIOCore12ChannelErrorO14connectTimeoutyAcA10TimeAmountVcACmF","s7NIOCore12ChannelErrorO18unremovableHandleryA2CmF","s7NIOCore12ChannelErrorO19unknownLocalAddressyA2CmF","s7NIOCore12ChannelErrorO20operationUnsupportedyA2CmF","s7NIOCore12ChannelErrorO20writeHostUnreachableyA2CmF","s7NIOCore12ChannelErrorO20writeMessageTooLargeyA2CmF","s7NIOCore12ChannelErrorO21multicastNotSupportedyAcA19NIONetworkInterfaceCcACmF","s7NIOCore12ChannelErrorO23illegalMulticastAddressyAcA06SocketF0OcACmF","s7NIOCore12ChannelErrorO25badInterfaceAddressFamilyyA2CmF","s7NIOCore12ChannelErrorO30badMulticastGroupAddressFamilyyA2CmF","s7NIOCore12ChannelErrorO30inappropriateOperationForStateyA2CmF","s7NIOCore12ChannelErrorO3eofyA2CmF","s7NIOCore12ChannelEventO11inputClosedyA2CmF","s7NIOCore12ChannelEventO12outputClosedyA2CmF","s7NIOCore13DecodingStateO12needMoreDatayA2CmF","s7NIOCore13DecodingStateO8continueyA2CmF","s7NIOCore13SocketAddressO010unixDomainB0yA2C04UnixbC0VcACmF","s7NIOCore13SocketAddressO2v4yA2C04IPv4C0VcACmF","s7NIOCore13SocketAddressO2v6yA2C04IPv6C0VcACmF","s7NIOCore14ChannelOptionsV5TypesO22ConvenienceOptionValueO3setyAGy__xGxcAImlF","s7NIOCore14ChannelOptionsV5TypesO22ConvenienceOptionValueO6notSetyAGy__xGAImlF","s7NIOCore14EventLoopErrorO14shutdownFailedyA2CmF","s7NIOCore14EventLoopErrorO20unsupportedOperationyA2CmF","s7NIOCore14EventLoopErrorO8shutdownyA2CmF","s7NIOCore14EventLoopErrorO9cancelledyA2CmF","s7NIOCore15ChannelPipelineC8PositionO4lastyA2EmF","s7NIOCore15ChannelPipelineC8PositionO5afteryAeA0B7Handler_pcAEmF","s7NIOCore15ChannelPipelineC8PositionO5firstyA2EmF","s7NIOCore15ChannelPipelineC8PositionO6beforeyAeA0B7Handler_pcAEmF","s7NIOCore16IdleStateHandlerC0bC5EventO3allyA2EmF","s7NIOCore16IdleStateHandlerC0bC5EventO4readyA2EmF","s7NIOCore16IdleStateHandlerC0bC5EventO5writeyA2EmF","s7NIOCore18SocketAddressErrorO010unixDomainB11PathTooLongyA2CmF","s7NIOCore18SocketAddressErrorO11unsupportedyA2CmF","s7NIOCore18SocketAddressErrorO21failedToParseIPStringyACSScACmF","s7NIOCore18SocketAddressErrorO7unknownyACSS_SitcACmF","s7NIOCore20ChannelPipelineErrorO14alreadyRemovedyA2CmF","s7NIOCore20ChannelPipelineErrorO8notFoundyA2CmF","s7NIOCore25ByteToMessageDecoderErrorO014dataReceivedInF5StateyACs0F0_p_AA0B6BufferVtcACmF","s7NIOCore25ByteToMessageDecoderErrorO20leftoverDataWhenDoneyAcA0B6BufferVcACmF","s7NIOCore25NIOEventLoopGroupProviderO6sharedyAcA05EventcD0_pcACmF","s7NIOCore25NIOEventLoopGroupProviderO9createNewyA2CmF","s7NIOCore38NIOExplicitCongestionNotificationStateO19transportNotCapableyA2CmF","s7NIOCore38NIOExplicitCongestionNotificationStateO21congestionExperiencedyA2CmF","s7NIOCore38NIOExplicitCongestionNotificationStateO21transportCapableFlag0yA2CmF","s7NIOCore38NIOExplicitCongestionNotificationStateO21transportCapableFlag1yA2CmF","s7NIOCore6IODataO10byteBufferyAcA04ByteD0VcACmF","s7NIOCore6IODataO10fileRegionyAcA04FileD0VcACmF","s7NIOCore7IOErrorV18FailureDescriptionO6reasonyAESScAEmF","s7NIOCore7IOErrorV18FailureDescriptionO8functionyAEs12StaticStringVcAEmF","s7NIOCore9CloseModeO3allyA2CmF","s7NIOCore9CloseModeO5inputyA2CmF","s7NIOCore9CloseModeO6outputyA2CmF","s7NIOCore10ByteBufferV12dispatchDataAC8Dispatch0fE0V_tcfc","s7NIOCore10ByteBufferV12staticStringACs06StaticE0V_tcfc","s7NIOCore10ByteBufferV5bytesACx_tcSTRzs5UInt8V7ElementRtzlufc","s7NIOCore10ByteBufferV6bufferA2C_tcfc","s7NIOCore10ByteBufferV6stringACSS_tcfc","s7NIOCore10ByteBufferV7integer10endianness2asACx_AA10EndiannessOxmtcs17FixedWidthIntegerRzlufc","s7NIOCore10ByteBufferV9repeating5countACs5UInt8V_Sitcfc","s7NIOCore10ByteBufferV9substringACSs_tcfc","s7NIOCore10ByteBufferVACycfc","s7NIOCore10ByteBufferVyAcA0bC4ViewVcfc","s7NIOCore10FileRegionV10fileHandle11readerIndex03endG0AcA07NIOFileE0C_S2itcfc","s7NIOCore10FileRegionV10fileHandleAcA07NIOFileE0C_tKcfc","s7NIOCore12NIOBSDSocketO11OptionLevelV8rawValueAEs5Int32V_tcfc","s7NIOCore12NIOBSDSocketO13AddressFamilyV8rawValueAEs5Int32V_tcfc","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV8rawValueAEs5Int32V_tcfc","s7NIOCore12NIOBSDSocketO6OptionV8rawValueAEs5Int32V_tcfc","s7NIOCore13NIOFileHandleC10descriptorACs5Int32V_tcfc","s7NIOCore13NIOFileHandleC4ModeV8rawValueAEs5UInt8V_tcfc","s7NIOCore13NIOFileHandleC4path4mode5flagsACSS_AC4ModeVAC5FlagsVtKcfc","s7NIOCore13NIOFileHandleC4pathACSS_tKcfc","s7NIOCore13NIOPacketInfoV18destinationAddress14interfaceIndexAcA06SocketE0O_Sitcfc","s7NIOCore13SocketAddressO010unixDomainB4PathACSS_tKcfc","s7NIOCore13SocketAddressO02ipC04portACSS_SitKcfc","s7NIOCore13SocketAddressO15packedIPAddress4portAcA10ByteBufferV_SitKcfc","s7NIOCore13SocketAddressO_4hostACSo11sockaddr_inV_SStcfc","s7NIOCore13SocketAddressO_4hostACSo12sockaddr_in6V_SStcfc","s7NIOCore13SocketAddressOyACSo11sockaddr_inVcfc","s7NIOCore13SocketAddressOyACSo11sockaddr_unVcfc","s7NIOCore13SocketAddressOyACSo12sockaddr_in6Vcfc","s7NIOCore14ByteBufferViewV12arrayLiteralACs5UInt8Vd_tcfc","s7NIOCore14ByteBufferViewVACycfc","s7NIOCore14ByteBufferViewVyAcA0bC0Vcfc","s7NIOCore14ChannelOptionsV014TCPConvenienceC0V12arrayLiteralAeC0D6OptionVd_tcfc","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV5level4nameAGSi_s5Int32Vtcfc","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV5level4nameAgA12NIOBSDSocketO0F5LevelV_AK0F0Vtcfc","s7NIOCore14ChannelOptionsV5TypesO13BacklogOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO14AutoReadOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO15AllocatorOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO15WriteSpinOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO17ReceivePacketInfoVAGycfc","s7NIOCore14ChannelOptionsV5TypesO19RecvAllocatorOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO20ConnectTimeoutOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO20WriteBufferWaterMarkV3low4highAGSi_Sitcfc","s7NIOCore14ChannelOptionsV5TypesO24MaxMessagesPerReadOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO26WriteBufferWaterMarkOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO28AllowRemoteHalfClosureOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO36DatagramVectorReadMessageCountOptionVAGycfc","s7NIOCore14ChannelOptionsV5TypesO37ExplicitCongestionNotificationsOptionVAGycfc","s7NIOCore14ChannelOptionsV7StorageVAEycfc","s7NIOCore14CircularBufferV12arrayLiteralACyxGxd_tcfc","s7NIOCore14CircularBufferV15initialCapacityACyxGSi_tcfc","s7NIOCore14CircularBufferVACyxGycfc","s7NIOCore15ChannelPipelineC7channelAcA0B0_p_tcfc","s7NIOCore16IdleStateHandlerC11readTimeout05writeF003allF0AcA10TimeAmountVSg_A2Itcfc","s7NIOCore16NIOInsecureNoTLSVACyxGycfc","s7NIOCore16NIONetworkDeviceV4name7address7netmask16broadcastAddress023pointToPointDestinationH018multicastSupported14interfaceIndexACSS_AA06SocketH0OSgA2mLSbSitcfc","s7NIOCore16NIONetworkDeviceVyAcA0B9InterfaceCcfc","s7NIOCore17AddressedEnvelopeV13remoteAddress4data8metadataACyxGAA06SocketE0O_xAC8MetadataVyx_GSgtcfc","s7NIOCore17AddressedEnvelopeV13remoteAddress4dataACyxGAA06SocketE0O_xtcfc","s7NIOCore17AddressedEnvelopeV8MetadataV8ecnState10packetInfoAEyx_GAA033NIOExplicitCongestionNotificationF0O_AA09NIOPacketH0VSgtcfc","s7NIOCore17AddressedEnvelopeV8MetadataV8ecnStateAEyx_GAA033NIOExplicitCongestionNotificationF0O_tcfc","s7NIOCore17EventLoopIteratorVyACSayAA0bC0_pGcfc","s7NIOCore18SocketAddressErrorO25FailedToParseIPByteBufferV7addressAeA04ByteI0V_tcfc","s7NIOCore19BackPressureHandlerCACycfc","s7NIOCore19ByteBufferAllocatorVACycfc","s7NIOCore20AcceptBackoffHandlerC15backoffProviderAcA10TimeAmountVSgAA7IOErrorVc_tcfc","s7NIOCore20ByteToMessageHandlerC_17maximumBufferSizeACyxGx_SiSgtcfc","s7NIOCore20ByteToMessageHandlerCyACyxGxcfc","s7NIOCore20MarkedCircularBufferV15initialCapacityACyxGSi_tcfc","s7NIOCore20MessageToByteHandlerCyACyxGxcfc","s7NIOCore20NIOTooManyBytesErrorVACycfc","s7NIOCore21NIOClientTCPBootstrapV_3tlsACx_q_tcAA0bC8ProtocolRz9BootstrapQy_RszAA0B11TLSProviderR_r0_lufc","s7NIOCore22NIOCloseOnErrorHandlerCACycfc","s7NIOCore25ByteToMessageDecoderErrorO015PayloadTooLargeF0VAEycfc","s7NIOCore25ChannelShouldQuiesceEventVACycfc","s7NIOCore29NIOMulticastNotSupportedErrorV6deviceAcA16NIONetworkDeviceV_tcfc","s7NIOCore31AdaptiveRecvByteBufferAllocatorV7minimum7initial7maximumACSi_S2itcfc","s7NIOCore31AdaptiveRecvByteBufferAllocatorVACycfc","s7NIOCore31NIOMulticastNotImplementedErrorVACycfc","s7NIOCore32FixedSizeRecvByteBufferAllocatorV8capacityACSi_tcfc","s7NIOCore35NIOSingleStepByteToMessageProcessorC_17maximumBufferSizeACyxGx_SiSgtcfc","s7NIOCore6NIOAnyVyACxclufc","s7NIOCore7IOErrorV9errnoCode6reasonACs5Int32V_SStcfc","s7NIOCore7IOErrorV9errnoCode8functionACs5Int32V_s12StaticStringVtcfc","s7NIOCore9ScheduledV7promise16cancellationTaskACyxGAA16EventLoopPromiseVyxG_yyctcfc","s7NIOCore14ByteBufferViewVyACSnySiGcip","s7NIOCore14ByteBufferViewVys5UInt8VSicip","s7NIOCore14CircularBufferV6offsetxSi_tcip","s7NIOCore14CircularBufferVyACyxGSnyAC5IndexVyx_GGcip","s7NIOCore14CircularBufferVyxAC5IndexVyx_Gcip","s7NIOCore20MarkedCircularBufferVyAA0cD0VyxGSnyAE5IndexVyx_GGcip","s7NIOCore20MarkedCircularBufferVyxAA0cD0V5IndexVyx_Gcip","s7NIOCore10ByteBufferV14CopyBytesErrorV016unreadableSourceE0AEvpZ","s7NIOCore10ByteBufferV14CopyBytesErrorV14negativeLengthAEvpZ","s7NIOCore10ByteBufferV17LengthPrefixErrorV07messageD42DoesNotFitExactlyIntoRequiredIntegerFormatAEvpZ","s7NIOCore10ByteBufferV17LengthPrefixErrorV33messageCouldNotBeReadSuccessfullyAEvpZ","s7NIOCore10EndiannessO4hostACvpZ","s7NIOCore10TimeAmountV4zeroACvpZ","s7NIOCore11NIODeadlineV11distantPastACvpZ","s7NIOCore11NIODeadlineV13distantFutureACvpZ","s7NIOCore12NIOBSDSocketO11OptionLevelV2ipAEvpZ","s7NIOCore12NIOBSDSocketO11OptionLevelV3tcpAEvpZ","s7NIOCore12NIOBSDSocketO11OptionLevelV4ipv6AEvpZ","s7NIOCore12NIOBSDSocketO11OptionLevelV6socketAEvpZ","s7NIOCore12NIOBSDSocketO13AddressFamilyV4inetAEvpZ","s7NIOCore12NIOBSDSocketO13AddressFamilyV4unixAEvpZ","s7NIOCore12NIOBSDSocketO13AddressFamilyV5inet6AEvpZ","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV4inetAEvpZ","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV4unixAEvpZ","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV5inet6AEvpZ","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV5localAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV11ipv6_v6onlyAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV11so_rcvtimeoAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV11tcp_nodelayAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV12so_keepaliveAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV12so_reuseaddrAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV12so_timestampAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV15ip_multicast_ifAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV15ipv6_join_groupAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV16ip_multicast_ttlAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV16ipv6_leave_groupAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV17ip_add_membershipAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV17ip_multicast_loopAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV17ipv6_multicast_ifAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV18ip_drop_membershipAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV19ipv6_multicast_hopsAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV19ipv6_multicast_loopAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV8so_errorAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV8tcp_infoAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV9so_lingerAEvpZ","s7NIOCore12NIOBSDSocketO6OptionV9so_rcvbufAEvpZ","s7NIOCore13NIOFileHandleC4ModeV4readAEvpZ","s7NIOCore13NIOFileHandleC4ModeV5writeAEvpZ","s7NIOCore13NIOFileHandleC5FlagsV7defaultAEvpZ","s7NIOCore14ChannelOptionsV12socketOptionyAC5TypesO06SocketE0VAA12NIOBSDSocketO0E0VcvpZ","s7NIOCore14ChannelOptionsV13recvAllocatorAC5TypesO04RecvE6OptionVvpZ","s7NIOCore14ChannelOptionsV14connectTimeoutAC5TypesO07ConnectE6OptionVvpZ","s7NIOCore14ChannelOptionsV17receivePacketInfoAC5TypesO07ReceiveeF0VvpZ","s7NIOCore14ChannelOptionsV18maxMessagesPerReadAC5TypesO03MaxefG6OptionVvpZ","s7NIOCore14ChannelOptionsV20TCPConvenienceOptionV15disableAutoReadAEvpZ","s7NIOCore14ChannelOptionsV20TCPConvenienceOptionV22allowRemoteHalfClosureAEvpZ","s7NIOCore14ChannelOptionsV20TCPConvenienceOptionV23allowLocalEndpointReuseAEvpZ","s7NIOCore14ChannelOptionsV20writeBufferWaterMarkAC5TypesO05WriteefG6OptionVvpZ","s7NIOCore14ChannelOptionsV22allowRemoteHalfClosureAC5TypesO05AllowefG6OptionVvpZ","s7NIOCore14ChannelOptionsV30datagramVectorReadMessageCountAC5TypesO08DatagramefgH6OptionVvpZ","s7NIOCore14ChannelOptionsV30explicitCongestionNotificationAC5TypesO08ExplicitE19NotificationsOptionVvpZ","s7NIOCore14ChannelOptionsV6socketyAC5TypesO12SocketOptionVSi_s5Int32VtcvpZ","s7NIOCore14ChannelOptionsV7backlogAC5TypesO13BacklogOptionVvpZ","s7NIOCore14ChannelOptionsV8autoReadAC5TypesO04AutoE6OptionVvpZ","s7NIOCore14ChannelOptionsV9allocatorAC5TypesO15AllocatorOptionVvpZ","s7NIOCore14ChannelOptionsV9tcpOptionyAC5TypesO06SocketE0VAA12NIOBSDSocketO0E0VcvpZ","s7NIOCore14ChannelOptionsV9writeSpinAC5TypesO05WriteE6OptionVvpZ","s7NIOCore6SystemO9coreCountSivpZ","s7NIOCore10ByteBufferV11descriptionSSvp","s7NIOCore10ByteBufferV11readerIndexSivp","s7NIOCore10ByteBufferV11writerIndexSivp","s7NIOCore10ByteBufferV13readableBytesSivp","s7NIOCore10ByteBufferV13writableBytesSivp","s7NIOCore10ByteBufferV14CopyBytesErrorV16debugDescriptionSSvp","s7NIOCore10ByteBufferV15storageCapacitySivp","s7NIOCore10ByteBufferV16debugDescriptionSSvp","s7NIOCore10ByteBufferV17readableBytesViewAA0bcF0Vvp","s7NIOCore10ByteBufferV8capacitySivp","s7NIOCore10FileRegionV10fileHandleAA07NIOFileE0Cvp","s7NIOCore10FileRegionV11descriptionSSvp","s7NIOCore10FileRegionV11readerIndexSivp","s7NIOCore10FileRegionV13readableBytesSivp","s7NIOCore10FileRegionV8endIndexSivp","s7NIOCore10TimeAmountV11nanosecondss5Int64Vvp","s7NIOCore11NIODeadlineV11descriptionSSvp","s7NIOCore11NIODeadlineV17uptimeNanosecondss6UInt64Vvp","s7NIOCore12NIOBSDSocketO11OptionLevelV8rawValues5Int32Vvp","s7NIOCore12NIOBSDSocketO13AddressFamilyV8rawValues5Int32Vvp","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV8rawValues5Int32Vvp","s7NIOCore12NIOBSDSocketO6OptionV8rawValues5Int32Vvp","s7NIOCore13NIOFileHandleC11descriptionSSvp","s7NIOCore13NIOFileHandleC4ModeV8rawValues5UInt8Vvp","s7NIOCore13NIOFileHandleC6isOpenSbvp","s7NIOCore13NIOPacketInfoV14interfaceIndexSivp","s7NIOCore13NIOPacketInfoV18destinationAddressAA06SocketE0Ovp","s7NIOCore13SocketAddressO02ipC0SSSgvp","s7NIOCore13SocketAddressO04IPv4C0V4hostSSvp","s7NIOCore13SocketAddressO04IPv4C0V7addressSo11sockaddr_inVvp","s7NIOCore13SocketAddressO04IPv6C0V4hostSSvp","s7NIOCore13SocketAddressO04IPv6C0V7addressSo12sockaddr_in6Vvp","s7NIOCore13SocketAddressO04UnixbC0V7addressSo11sockaddr_unVvp","s7NIOCore13SocketAddressO11descriptionSSvp","s7NIOCore13SocketAddressO11isMulticastSbvp","s7NIOCore13SocketAddressO14protocolFamilys5Int32Vvp","s7NIOCore13SocketAddressO4portSiSgvp","s7NIOCore13SocketAddressO8pathnameSSSgvp","s7NIOCore13SocketAddressO8protocolAA12NIOBSDSocketO14ProtocolFamilyVvp","s7NIOCore14ByteBufferViewV10startIndexSivp","s7NIOCore14ByteBufferViewV5countSivp","s7NIOCore14ByteBufferViewV8endIndexSivp","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV10optionNameAA12NIOBSDSocketO0F0Vvp","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV11optionLevelAA12NIOBSDSocketO0fH0Vvp","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV4names5Int32Vvp","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV5levelSivp","s7NIOCore14ChannelOptionsV5TypesO20WriteBufferWaterMarkV3lowSivp","s7NIOCore14ChannelOptionsV5TypesO20WriteBufferWaterMarkV4highSivp","s7NIOCore14ChannelOptionsV5TypesO22ConvenienceOptionValueOAAytRszlE5isSetSbvp","s7NIOCore14CircularBufferV10startIndexAC0E0Vyx_Gvp","s7NIOCore14CircularBufferV11descriptionSSvp","s7NIOCore14CircularBufferV5countSivp","s7NIOCore14CircularBufferV5firstxSgvp","s7NIOCore14CircularBufferV7isEmptySbvp","s7NIOCore14CircularBufferV8capacitySivp","s7NIOCore14CircularBufferV8endIndexAC0E0Vyx_Gvp","s7NIOCore14EventLoopErrorO11descriptionSSvp","s7NIOCore14EventLoopGroupPAAE11descriptionSSvp","s7NIOCore14FileDescriptorP6isOpenSbvp","s7NIOCore15ChannelPipelineC14syncOperationsAC011SynchronousE0Vvp","s7NIOCore15ChannelPipelineC16debugDescriptionSSvp","s7NIOCore15ChannelPipelineC21SynchronousOperationsV9eventLoopAA05EventG0_pvp","s7NIOCore15ChannelPipelineC9eventLoopAA05EventE0_pvp","s7NIOCore15EventLoopFutureC05eventC0AA0bC0_pvp","s7NIOCore16EventLoopPromiseV12futureResultAA0bC6FutureCyxGvp","s7NIOCore16IdleStateHandlerC10allTimeoutAA10TimeAmountVSgvp","s7NIOCore16IdleStateHandlerC11readTimeoutAA10TimeAmountVSgvp","s7NIOCore16IdleStateHandlerC12writeTimeoutAA10TimeAmountVSgvp","s7NIOCore16NIONetworkDeviceV14interfaceIndexSivp","s7NIOCore16NIONetworkDeviceV16broadcastAddressAA06SocketE0OSgvp","s7NIOCore16NIONetworkDeviceV16debugDescriptionSSvp","s7NIOCore16NIONetworkDeviceV18multicastSupportedSbvp","s7NIOCore16NIONetworkDeviceV30pointToPointDestinationAddressAA06SocketH0OSgvp","s7NIOCore16NIONetworkDeviceV4nameSSvp","s7NIOCore16NIONetworkDeviceV7addressAA13SocketAddressOSgvp","s7NIOCore16NIONetworkDeviceV7netmaskAA13SocketAddressOSgvp","s7NIOCore17AddressedEnvelopeV11descriptionSSvp","s7NIOCore17AddressedEnvelopeV13remoteAddressAA06SocketE0Ovp","s7NIOCore17AddressedEnvelopeV4dataxvp","s7NIOCore17AddressedEnvelopeV8MetadataV10packetInfoAA09NIOPacketF0VSgvp","s7NIOCore17AddressedEnvelopeV8MetadataV8ecnStateAA033NIOExplicitCongestionNotificationF0Ovp","s7NIOCore17AddressedEnvelopeV8metadataAC8MetadataVyx_GSgvp","s7NIOCore18SocketAddressErrorO25FailedToParseIPByteBufferV7addressAA04ByteI0Vvp","s7NIOCore19NIONetworkInterfaceC14interfaceIndexSivp","s7NIOCore19NIONetworkInterfaceC16broadcastAddressAA06SocketE0OSgvp","s7NIOCore19NIONetworkInterfaceC16debugDescriptionSSvp","s7NIOCore19NIONetworkInterfaceC18multicastSupportedSbvp","s7NIOCore19NIONetworkInterfaceC30pointToPointDestinationAddressAA06SocketH0OSgvp","s7NIOCore19NIONetworkInterfaceC4nameSSvp","s7NIOCore19NIONetworkInterfaceC7addressAA13SocketAddressOvp","s7NIOCore19NIONetworkInterfaceC7netmaskAA13SocketAddressOSgvp","s7NIOCore20MarkedCircularBufferV10startIndexAA0cD0V0F0Vyx_Gvp","s7NIOCore20MarkedCircularBufferV11descriptionSSvp","s7NIOCore20MarkedCircularBufferV13markedElementxSgvp","s7NIOCore20MarkedCircularBufferV18markedElementIndexAA0cD0V0G0Vyx_GSgvp","s7NIOCore20MarkedCircularBufferV5countSivp","s7NIOCore20MarkedCircularBufferV5firstxSgvp","s7NIOCore20MarkedCircularBufferV7hasMarkSbvp","s7NIOCore20MarkedCircularBufferV7isEmptySbvp","s7NIOCore20MarkedCircularBufferV8endIndexAA0cD0V0F0Vyx_Gvp","s7NIOCore20SocketOptionProviderP9eventLoopAA05EventF0_pvp","s7NIOCore21ChannelHandlerContextC12localAddressAA06SocketF0OSgvp","s7NIOCore21ChannelHandlerContextC13remoteAddressAA06SocketF0OSgvp","s7NIOCore21ChannelHandlerContextC4nameSSvp","s7NIOCore21ChannelHandlerContextC7channelAA0B0_pvp","s7NIOCore21ChannelHandlerContextC7handlerAA0bC0_pvp","s7NIOCore21ChannelHandlerContextC8pipelineAA0B8PipelineCvp","s7NIOCore21ChannelHandlerContextC9eventLoopAA05EventF0_pvp","s7NIOCore21NIOClientTCPBootstrapV19underlyingBootstrapAA0bC8Protocol_pvp","s7NIOCore22ChannelOutboundInvokerP9eventLoopAA05EventF0_pvp","s7NIOCore29NIOMulticastNotSupportedErrorV6deviceAA16NIONetworkDeviceVvp","s7NIOCore31AdaptiveRecvByteBufferAllocatorV7initialSivp","s7NIOCore31AdaptiveRecvByteBufferAllocatorV7maximumSivp","s7NIOCore31AdaptiveRecvByteBufferAllocatorV7minimumSivp","s7NIOCore32FixedSizeRecvByteBufferAllocatorV8capacitySivp","s7NIOCore6IODataO11descriptionSSvp","s7NIOCore6IODataO13readableBytesSivp","s7NIOCore6NIOAnyV11descriptionSSvp","s7NIOCore7ChannelP10isWritableSbvp","s7NIOCore7ChannelP11closeFutureAA09EventLoopD0CyytGvp","s7NIOCore7ChannelP11syncOptionsAA014NIOSynchronousbD0_pSgvp","s7NIOCore7ChannelP12localAddressAA06SocketD0OSgvp","s7NIOCore7ChannelP13remoteAddressAA06SocketD0OSgvp","s7NIOCore7ChannelP6parentAaB_pSgvp","s7NIOCore7ChannelP8isActiveSbvp","s7NIOCore7ChannelP8pipelineAA0B8PipelineCvp","s7NIOCore7ChannelP9allocatorAA19ByteBufferAllocatorVvp","s7NIOCore7ChannelPAAE11syncOptionsAA014NIOSynchronousbD0_pSgvp","s7NIOCore7IOErrorV11descriptionSSvp","s7NIOCore7IOErrorV20localizedDescriptionSSvp","s7NIOCore7IOErrorV6reasonAC18FailureDescriptionOvp","s7NIOCore7IOErrorV9errnoCodes5Int32Vvp","s7NIOCore9EventLoopP02inbC0Sbvp","s7NIOCore9ScheduledV12futureResultAA15EventLoopFutureCyxGvp","s7NIOCore10TimeAmountV11nanosecondsyACs5Int64VFZ","s7NIOCore10TimeAmountV12microsecondsyACs5Int64VFZ","s7NIOCore10TimeAmountV12millisecondsyACs5Int64VFZ","s7NIOCore10TimeAmountV5hoursyACs5Int64VFZ","s7NIOCore10TimeAmountV7minutesyACs5Int64VFZ","s7NIOCore10TimeAmountV7secondsyACs5Int64VFZ","s7NIOCore11NIODeadlineV17uptimeNanosecondsyACs6UInt64VFZ","s7NIOCore11NIODeadlineV3nowACyFZ","s7NIOCore13NIOFileHandleC5FlagsV17allowFileCreation9posixModeAEs6UInt32V_tFZ","s7NIOCore13NIOFileHandleC5FlagsV5posix5flags4modeAEs5Int32V_s6UInt32VtFZ","s7NIOCore13SocketAddressO04makeC13ResolvingHost_4portACSS_SitKFZ","s7NIOCore15EventLoopFutureC13andAllSucceed_2onACyytGSayACyxGG_AA0bC0_ptFZ","s7NIOCore15EventLoopFutureC13andAllSucceed_7promiseySayACyxGG_AA0bC7PromiseVyytGtFZ","s7NIOCore15EventLoopFutureC14andAllComplete_2onACyytGSayACyxGG_AA0bC0_ptFZ","s7NIOCore15EventLoopFutureC14andAllComplete_7promiseySayACyxGG_AA0bC7PromiseVyytGtFZ","s7NIOCore15EventLoopFutureC14whenAllSucceed_2onACySayxGGSayACyxGG_AA0bC0_ptFZ","s7NIOCore15EventLoopFutureC14whenAllSucceed_7promiseySayACyxGG_AA0bC7PromiseVySayxGGtFZ","s7NIOCore15EventLoopFutureC15whenAllComplete_2onACySays6ResultOyxs5Error_pGGGSayACyxGG_AA0bC0_ptFZ","s7NIOCore15EventLoopFutureC15whenAllComplete_7promiseySayACyxGG_AA0bC7PromiseVySays6ResultOyxs5Error_pGGGtFZ","s7NIOCore15EventLoopFutureC6reduce4into_2on_ACyxGx_SayACyqd__GGAA0bC0_pyxz_qd__tctlFZ","s7NIOCore15EventLoopFutureC6reduce__2on_ACyxGx_SayACyqd__GGAA0bC0_pxx_qd__tctlFZ","s7NIOCore20AcceptBackoffHandlerC07defaultC8Provider5errorAA10TimeAmountVSgAA7IOErrorV_tFZ","s7NIOCore6SystemO16enumerateDevicesSayAA16NIONetworkDeviceVGyKFZ","s7NIOCore6SystemO19enumerateInterfacesSayAA19NIONetworkInterfaceCGyKFZ","s7NIOCore10ByteBufferV012setRepeatingB0_5count2atSis5UInt8V_S2itF","s7NIOCore10ByteBufferV014writeImmutableC0ySiACF","s7NIOCore10ByteBufferV014writeRepeatingB0_5countSis5UInt8V_SitF","s7NIOCore10ByteBufferV03setC0_2atSiAC_SitF","s7NIOCore10ByteBufferV05writeC0ySiACzF","s7NIOCore10ByteBufferV10getInteger2at10endianness2asxSgSi_AA10EndiannessOxmts010FixedWidthE0RzlF","s7NIOCore10ByteBufferV10readString6lengthSSSgSi_tF","s7NIOCore10ByteBufferV10setInteger_2at10endianness2asSix_SiAA10EndiannessOxmts010FixedWidthE0RzlF","s7NIOCore10ByteBufferV10writeBytesySiSWF","s7NIOCore10ByteBufferV10writeBytesySixSTRzs5UInt8V7ElementRtzlF","s7NIOCore10ByteBufferV11readInteger10endianness2asxSgAA10EndiannessO_xmts010FixedWidthE0RzlF","s7NIOCore10ByteBufferV11writeStringySiSSF","s7NIOCore10ByteBufferV12setSubstring_2atSiSs_SitF","s7NIOCore10ByteBufferV12writeInteger_10endianness2asSix_AA10EndiannessOxmts010FixedWidthE0RzlF","s7NIOCore10ByteBufferV14writeSubstringySiSsF","s7NIOCore10ByteBufferV15getDispatchData2at6length0E00eF0VSgSi_SitF","s7NIOCore10ByteBufferV15moveReaderIndex2toySi_tF","s7NIOCore10ByteBufferV15moveReaderIndex9forwardByySi_tF","s7NIOCore10ByteBufferV15moveWriterIndex2toySi_tF","s7NIOCore10ByteBufferV15moveWriterIndex9forwardByySi_tF","s7NIOCore10ByteBufferV15reserveCapacity20minimumWritableBytesySi_tF","s7NIOCore10ByteBufferV15reserveCapacityyySiF","s7NIOCore10ByteBufferV15setDispatchData_2atSi0E00eF0V_SitF","s7NIOCore10ByteBufferV15setStaticString_2atSis0eF0V_SitF","s7NIOCore10ByteBufferV16discardReadBytesSbyF","s7NIOCore10ByteBufferV16readDispatchData6length0E00eF0VSgSi_tF","s7NIOCore10ByteBufferV17writeDispatchDataySi0E00eF0VF","s7NIOCore10ByteBufferV17writeStaticStringySis0eF0VF","s7NIOCore10ByteBufferV18readLengthPrefixed10endianness2as0D7Messageq_SgAA10EndiannessO_xmAhCKXEtKs17FixedWidthIntegerRzr0_lF","s7NIOCore10ByteBufferV19withVeryUnsafeBytesyxxSWKXEKlF","s7NIOCore10ByteBufferV19writeLengthPrefixed10endianness2as0D7MessageSiAA10EndiannessO_xmSiACzKXEtKs17FixedWidthIntegerRzlF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_q12_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_q12_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_sAJR6_sAJR7_sAJR8_sAJR9_sAJR10_sAJR11_sAJR12_r13_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_sAJR6_sAJR7_sAJR8_sAJR9_sAJR10_sAJR11_r12_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_sAJR6_sAJR7_sAJR8_sAJR9_sAJR10_r11_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_sAJR6_sAJR7_sAJR8_sAJR9_r10_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_sAJR6_sAJR7_sAJR8_r9_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_q6_q7_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_q6_q7_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_sAJR6_sAJR7_r8_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_q6_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_q6_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_sAJR6_r7_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_q5_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_q5_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_sAJR5_r6_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_q4_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_q4_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_sAJR4_r5_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_q3_tSgAA10EndiannessO_x_q_q0_q1_q2_q3_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_sAJR3_r4_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_q2_tSgAA10EndiannessO_x_q_q0_q1_q2_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_sAJR2_r3_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_q1_tSgAA10EndiannessO_x_q_q0_q1_tmts17FixedWidthIntegerRzsAJR_sAJR0_sAJR1_r2_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_q0_tSgAA10EndiannessO_x_q_q0_tmts17FixedWidthIntegerRzsAJR_sAJR0_r1_lF","s7NIOCore10ByteBufferV20readMultipleIntegers10endianness2asx_q_tSgAA10EndiannessO_x_q_tmts17FixedWidthIntegerRzsAJR_r0_lF","s7NIOCore10ByteBufferV21modifyIfUniquelyOwnedyxSgxACzKXEKlF","s7NIOCore10ByteBufferV21writeMultipleIntegers__10endianness2asSix_q_AA10EndiannessOx_q_tmts17FixedWidthIntegerRzsAIR_r0_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers___10endianness2asSix_q_q0_AA10EndiannessOx_q_q0_tmts17FixedWidthIntegerRzsAIR_sAIR0_r1_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers____10endianness2asSix_q_q0_q1_AA10EndiannessOx_q_q0_q1_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_r2_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers_____10endianness2asSix_q_q0_q1_q2_AA10EndiannessOx_q_q0_q1_q2_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_r3_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers______10endianness2asSix_q_q0_q1_q2_q3_AA10EndiannessOx_q_q0_q1_q2_q3_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_r4_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers_______10endianness2asSix_q_q0_q1_q2_q3_q4_AA10EndiannessOx_q_q0_q1_q2_q3_q4_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_r5_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_r6_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers_________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_q6_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_q6_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_sAIR6_r7_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers__________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_q6_q7_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_q6_q7_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_sAIR6_sAIR7_r8_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers___________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_sAIR6_sAIR7_sAIR8_r9_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers____________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_sAIR6_sAIR7_sAIR8_sAIR9_r10_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers_____________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_sAIR6_sAIR7_sAIR8_sAIR9_sAIR10_r11_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers______________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_sAIR6_sAIR7_sAIR8_sAIR9_sAIR10_sAIR11_r12_lF","s7NIOCore10ByteBufferV21writeMultipleIntegers_______________10endianness2asSix_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_q12_AA10EndiannessOx_q_q0_q1_q2_q3_q4_q5_q6_q7_q8_q9_q10_q11_q12_tmts17FixedWidthIntegerRzsAIR_sAIR0_sAIR1_sAIR2_sAIR3_sAIR4_sAIR5_sAIR6_sAIR7_sAIR8_sAIR9_sAIR10_sAIR11_sAIR12_r13_lF","s7NIOCore10ByteBufferV22getLengthPrefixedSlice2at10endianness2asACSgSi_AA10EndiannessOxmts17FixedWidthIntegerRzlF","s7NIOCore10ByteBufferV23getNullTerminatedString2atSSSgSi_tF","s7NIOCore10ByteBufferV23readLengthPrefixedSlice10endianness2asACSgAA10EndiannessO_xmts17FixedWidthIntegerRzlF","s7NIOCore10ByteBufferV23setNullTerminatedString_2atSiSS_SitF","s7NIOCore10ByteBufferV23withUnsafeReadableBytesyxxSWKXEKlF","s7NIOCore10ByteBufferV24readNullTerminatedStringSSSgyF","s7NIOCore10ByteBufferV25writeNullTerminatedStringySiSSF","s7NIOCore10ByteBufferV26withVeryUnsafeMutableBytesyxxSwKXEKlF","s7NIOCore10ByteBufferV27readWithUnsafeReadableBytesyS2iSWKXEKF","s7NIOCore10ByteBufferV27readWithUnsafeReadableBytesyxSi_xtSWKXEKlF","s7NIOCore10ByteBufferV27writeWithUnsafeMutableBytes015minimumWritableH0_S2i_SiSwKXEtKF","s7NIOCore10ByteBufferV27writeWithUnsafeMutableBytesyS2iSwKXEKF","s7NIOCore10ByteBufferV30withUnsafeMutableReadableBytesyxxSwKXEKlF","s7NIOCore10ByteBufferV30withUnsafeMutableWritableBytesyxxSwKXEKlF","s7NIOCore10ByteBufferV34readWithUnsafeMutableReadableBytesyS2iSwKXEKF","s7NIOCore10ByteBufferV34readWithUnsafeMutableReadableBytesyxSi_xtSwKXEKlF","s7NIOCore10ByteBufferV3set6buffer2atSiAC_SitF","s7NIOCore10ByteBufferV40withVeryUnsafeBytesWithStorageManagementyxxSW_s9UnmanagedVyyXlGtKXEKlF","s7NIOCore10ByteBufferV44withUnsafeReadableBytesWithStorageManagementyxxSW_s9UnmanagedVyyXlGtKXEKlF","s7NIOCore10ByteBufferV4hash4intoys6HasherVz_tF","s7NIOCore10ByteBufferV5clear15minimumCapacityySi_tF","s7NIOCore10ByteBufferV5clear15minimumCapacityys6UInt32V_tF","s7NIOCore10ByteBufferV5clearyyF","s7NIOCore10ByteBufferV5sliceACyF","s7NIOCore10ByteBufferV8getBytes2at6lengthSays5UInt8VGSgSi_SitF","s7NIOCore10ByteBufferV8getSlice2at6lengthACSgSi_SitF","s7NIOCore10ByteBufferV8setBytes_2atSiSW_SitF","s7NIOCore10ByteBufferV8setBytes_2atSix_SitSTRzs5UInt8V7ElementRtzlF","s7NIOCore10ByteBufferV9copyBytes2at2to6lengthS2i_S2itKF","s7NIOCore10ByteBufferV9getString2at6lengthSSSgSi_SitF","s7NIOCore10ByteBufferV9readBytes6lengthSays5UInt8VGSgSi_tF","s7NIOCore10ByteBufferV9readSlice6lengthACSgSi_tF","s7NIOCore10ByteBufferV9setString_2atSiSS_SitF","s7NIOCore10ByteBufferV9viewBytes2at6lengthAA0bC4ViewVSgSi_SitF","s7NIOCore10FileRegionV15moveReaderIndex9forwardByySi_tF","s7NIOCore11ChannelCoreP12channelRead0yyAA6NIOAnyVF","s7NIOCore11ChannelCoreP12errorCaught00D0ys5Error_p_tF","s7NIOCore11ChannelCoreP13localAddress0AA13SocketAddressOyKF","s7NIOCore11ChannelCoreP14remoteAddress0AA13SocketAddressOyKF","s7NIOCore11ChannelCoreP25triggerUserOutboundEvent0_7promiseyyp_AA16EventLoopPromiseVyytGSgtF","s7NIOCore11ChannelCoreP26registerAlreadyConfigured07promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore11ChannelCoreP5bind02to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore11ChannelCoreP5read0yyF","s7NIOCore11ChannelCoreP6close05error4mode7promiseys5Error_p_AA9CloseModeOAA16EventLoopPromiseVyytGSgtF","s7NIOCore11ChannelCoreP6flush0yyF","s7NIOCore11ChannelCoreP6write0_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore11ChannelCoreP8connect02to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore11ChannelCoreP9register07promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore11ChannelCorePAAE10unwrapData_2asqd__AA6NIOAnyV_qd__mtlF","s7NIOCore11ChannelCorePAAE13tryUnwrapData_2asqd__SgAA6NIOAnyV_qd__mtlF","s7NIOCore11ChannelCorePAAE14removeHandlers7channelyAA0B0_p_tF","s7NIOCore11ChannelCorePAAE14removeHandlers8pipelineyAA0B8PipelineC_tF","s7NIOCore12RepeatedTaskC6cancel7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore13NIOFileHandleC23takeDescriptorOwnerships5Int32VyKF","s7NIOCore13NIOFileHandleC24withUnsafeFileDescriptoryxxs5Int32VKXEKlF","s7NIOCore13NIOFileHandleC5closeyyKF","s7NIOCore13NIOFileHandleC9duplicateACyKF","s7NIOCore13SocketAddressO12withSockAddryxxSPySo8sockaddrVG_SitKXEKlF","s7NIOCore13SocketAddressO4hash4intoys6HasherVz_tF","s7NIOCore14ByteBufferViewV15replaceSubrange_4withySnySiG_xtSlRzs5UInt8V7ElementRtzlF","s7NIOCore14ByteBufferViewV15withUnsafeBytesyxxSWKXEKlF","s7NIOCore14ByteBufferViewV32withContiguousStorageIfAvailableyxSgxSRys5UInt8VGKXEKlF","s7NIOCore14ByteBufferViewV4hash4intoys6HasherVz_tF","s7NIOCore14ByteBufferViewV5index5afterS2i_tF","s7NIOCore14ChannelHandlerP12handlerAdded7contextyAA0bC7ContextC_tF","s7NIOCore14ChannelHandlerP14handlerRemoved7contextyAA0bC7ContextC_tF","s7NIOCore14ChannelHandlerPAAE12handlerAdded7contextyAA0bC7ContextC_tF","s7NIOCore14ChannelHandlerPAAE14handlerRemoved7contextyAA0bC7ContextC_tF","s7NIOCore14ChannelOptionsV014TCPConvenienceC0V22consumeDisableAutoReadAC5TypesO22ConvenienceOptionValueOy__ytGyF","s7NIOCore14ChannelOptionsV014TCPConvenienceC0V29consumeAllowRemoteHalfClosureAC5TypesO22ConvenienceOptionValueOy__ytGyF","s7NIOCore14ChannelOptionsV014TCPConvenienceC0V30consumeAllowLocalEndpointReuseAC5TypesO22ConvenienceOptionValueOy__ytGyF","s7NIOCore14ChannelOptionsV7StorageV08applyAllbC02toAA15EventLoopFutureCyytGAA0B0_p_tF","s7NIOCore14ChannelOptionsV7StorageV6append3key5valueyx_5ValueQztAA0B6OptionRzlF","s7NIOCore14CircularBufferV10removeLastxyF","s7NIOCore14CircularBufferV10removeLastyySiF","s7NIOCore14CircularBufferV11removeFirstxyF","s7NIOCore14CircularBufferV11removeFirstyySiF","s7NIOCore14CircularBufferV14removeSubrangeyySnyAC5IndexVyx_GGF","s7NIOCore14CircularBufferV15replaceSubrange_4withySnyAC5IndexVyx_GG_qd__t7ElementQyd__RszSlRd__lF","s7NIOCore14CircularBufferV15reserveCapacityyySiF","s7NIOCore14CircularBufferV5index5afterAC5IndexVyx_GAH_tF","s7NIOCore14CircularBufferV5index6beforeAC5IndexVyx_GAH_tF","s7NIOCore14CircularBufferV5index_8offsetByAC5IndexVyx_GAH_SitF","s7NIOCore14CircularBufferV6appendyyxF","s7NIOCore14CircularBufferV6modifyyqd__AC5IndexVyx_G_qd__xzKXEtKlF","s7NIOCore14CircularBufferV6remove2atxAC5IndexVyx_G_tF","s7NIOCore14CircularBufferV7popLastxSgyF","s7NIOCore14CircularBufferV7prependyyxF","s7NIOCore14CircularBufferV8distance4from2toSiAC5IndexVyx_G_AItF","s7NIOCore14CircularBufferV8popFirstxSgyF","s7NIOCore14CircularBufferV9removeAll15keepingCapacityySb_tF","s7NIOCore14CircularBufferVAASHRzlE4hash4intoys6HasherVz_tF","s7NIOCore14EventLoopGroupP12makeIteratorAA0bcF0VyF","s7NIOCore14EventLoopGroupP18shutdownGracefully5queue_y8Dispatch0H5QueueC_ys5Error_pSgctF","s7NIOCore14EventLoopGroupP3anyAA0bC0_pyF","s7NIOCore14EventLoopGroupP4nextAA0bC0_pyF","s7NIOCore14EventLoopGroupPAAE18shutdownGracefullyyyYaKF","s7NIOCore14EventLoopGroupPAAE18shutdownGracefullyyyys5Error_pSgcF","s7NIOCore14EventLoopGroupPAAE22syncShutdownGracefullyyyKF","s7NIOCore14EventLoopGroupPAAE3anyAA0bC0_pyF","s7NIOCore14FileDescriptorP010withUnsafebC0yqd__qd__s5Int32VKXEKlF","s7NIOCore14FileDescriptorP5closeyyKF","s7NIOCore15ChannelPipelineC04fireB10RegisteredyyF","s7NIOCore15ChannelPipelineC04fireB12ReadCompleteyyF","s7NIOCore15ChannelPipelineC04fireB12UnregisteredyyF","s7NIOCore15ChannelPipelineC04fireB18WritabilityChangedyyF","s7NIOCore15ChannelPipelineC04fireB4ReadyyAA6NIOAnyVF","s7NIOCore15ChannelPipelineC04fireB6ActiveyyF","s7NIOCore15ChannelPipelineC04fireB8InactiveyyF","s7NIOCore15ChannelPipelineC10addHandler_4name8positionAA15EventLoopFutureCyytGAA0bE0_p_SSSgAC8PositionOtF","s7NIOCore15ChannelPipelineC10addHandler_4name8positionyAA0bE0_p_SSSgAC8PositionOtYaKF","s7NIOCore15ChannelPipelineC11addHandlers_8positionAA15EventLoopFutureCyytGAA0B7Handler_pd_AC8PositionOtF","s7NIOCore15ChannelPipelineC11addHandlers_8positionAA15EventLoopFutureCyytGSayAA0B7Handler_pG_AC8PositionOtF","s7NIOCore15ChannelPipelineC11addHandlers_8positionyAA0B7Handler_pd_AC8PositionOtYaKF","s7NIOCore15ChannelPipelineC11addHandlers_8positionySayAA0B7Handler_pG_AC8PositionOtYaKF","s7NIOCore15ChannelPipelineC13removeHandler4name7promiseySS_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC13removeHandler4nameAA15EventLoopFutureCyytGSS_tF","s7NIOCore15ChannelPipelineC13removeHandler4nameySS_tYaKF","s7NIOCore15ChannelPipelineC13removeHandler7context7promiseyAA0bE7ContextC_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC13removeHandler7contextAA15EventLoopFutureCyytGAA0bE7ContextC_tF","s7NIOCore15ChannelPipelineC13removeHandler7contextyAA0bE7ContextC_tYaKF","s7NIOCore15ChannelPipelineC13removeHandler_7promiseyAA09RemovablebE0_p_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC13removeHandleryAA15EventLoopFutureCyytGAA09RemovablebE0_pF","s7NIOCore15ChannelPipelineC13removeHandleryyAA09RemovablebE0_pYaKF","s7NIOCore15ChannelPipelineC13writeAndFlush_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC15fireErrorCaughtyys0E0_pF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV04fireB10RegisteredyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV04fireB12ReadCompleteyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV04fireB12UnregisteredyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV04fireB18WritabilityChangedyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV04fireB4ReadyyAA6NIOAnyVF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV04fireB6ActiveyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV04fireB8InactiveyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV10addHandler_4name8positionyAA0bG0_p_SSSgAC8PositionOtKF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV11addHandlers_8positionyAA0B7Handler_pd_AC8PositionOtKF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV11addHandlers_8positionySayAA0B7Handler_pG_AC8PositionOtKF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV13writeAndFlush_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV15fireErrorCaughtyys0G0_pF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV24triggerUserOutboundEvent_7promiseyyp_AA0I11LoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV29fireUserInboundEventTriggeredyyypF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV4bind2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV4readyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV5close4mode7promiseyAA9CloseModeO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV5flushyyF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV5write_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV7connect2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV7context11handlerTypeAA0B14HandlerContextCxm_tKAA0bI0RzlF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV7context4nameAA0B14HandlerContextCSS_tKF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV7context7handlerAA0B14HandlerContextCAA0bH0_p_tKF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV7handler4typexxm_tKAA0B7HandlerRzlF","s7NIOCore15ChannelPipelineC21SynchronousOperationsV8register7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore15ChannelPipelineC24triggerUserOutboundEvent_7promiseyyp_AA0G11LoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC29fireUserInboundEventTriggeredyyypF","s7NIOCore15ChannelPipelineC4bind2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC4readyyF","s7NIOCore15ChannelPipelineC5close4mode7promiseyAA9CloseModeO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC5flushyyF","s7NIOCore15ChannelPipelineC5write_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC7connect2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore15ChannelPipelineC7context11handlerTypeAA0B14HandlerContextCxm_tYaKAA0bG0RzlF","s7NIOCore15ChannelPipelineC7context11handlerTypeAA15EventLoopFutureCyAA0B14HandlerContextCGxm_tAA0bJ0RzlF","s7NIOCore15ChannelPipelineC7context4nameAA0B14HandlerContextCSS_tYaKF","s7NIOCore15ChannelPipelineC7context4nameAA15EventLoopFutureCyAA0B14HandlerContextCGSS_tF","s7NIOCore15ChannelPipelineC7context7handlerAA0B14HandlerContextCAA0bF0_p_tYaKF","s7NIOCore15ChannelPipelineC7context7handlerAA15EventLoopFutureCyAA0B14HandlerContextCGAA0bI0_p_tF","s7NIOCore15ChannelPipelineC7handler4typeAA15EventLoopFutureCyxGxm_tAA0B7HandlerRzlF","s7NIOCore15ChannelPipelineC8register7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore15EventLoopFutureC011flatMapWithbC0yACyqd__GAEx_AA0bC0_ptclF","s7NIOCore15EventLoopFutureC016flatMapErrorWithbC0yACyxGAEs0G0_p_AA0bC0_ptcF","s7NIOCore15EventLoopFutureC08foldWithbC0_4withACyxGSayACyqd__GG_AFx_qd__AA0bC0_ptctlF","s7NIOCore15EventLoopFutureC11whenFailureyyys5Error_pcF","s7NIOCore15EventLoopFutureC11whenSuccessyyyxcF","s7NIOCore15EventLoopFutureC12flatMapError4file4line_ACyxGs12StaticStringV_SuAGs0G0_pctF","s7NIOCore15EventLoopFutureC12flatMapErroryACyxGAEs0G0_pcF","s7NIOCore15EventLoopFutureC12whenCompleteyyys6ResultOyxs5Error_pGcF","s7NIOCore15EventLoopFutureC13flatMapResult4file4line_ACyqd__Gs12StaticStringV_Sus0G0Oyqd__qd_0_Gxcts5ErrorRd_0_r0_lF","s7NIOCore15EventLoopFutureC13flatMapResultyACyqd__Gs0G0Oyqd__qd_0_Gxcs5ErrorRd_0_r0_lF","s7NIOCore15EventLoopFutureC14cascadeFailure2toyAA0bC7PromiseVyqd__GSg_tlF","s7NIOCore15EventLoopFutureC14cascadeSuccess2toyAA0bC7PromiseVyxGSg_tF","s7NIOCore15EventLoopFutureC15flatMapBlocking4onto_ACyqd__G8Dispatch0I5QueueC_qd__xKctlF","s7NIOCore15EventLoopFutureC15flatMapThrowing4file4line_ACyqd__Gs12StaticStringV_Suqd__xKctlF","s7NIOCore15EventLoopFutureC15flatMapThrowingyACyqd__Gqd__xKclF","s7NIOCore15EventLoopFutureC19whenFailureBlocking4onto_y8Dispatch0I5QueueC_ys5Error_pctF","s7NIOCore15EventLoopFutureC19whenSuccessBlocking4onto_y8Dispatch0I5QueueC_yxctF","s7NIOCore15EventLoopFutureC20flatMapErrorThrowing4file4line_ACyxGs12StaticStringV_Suxs0G0_pKctF","s7NIOCore15EventLoopFutureC20flatMapErrorThrowingyACyxGxs0G0_pKcF","s7NIOCore15EventLoopFutureC20whenCompleteBlocking4onto_y8Dispatch0I5QueueC_ys6ResultOyxs5Error_pGctF","s7NIOCore15EventLoopFutureC3and5value4file4lineACyx_qd__tGqd___s12StaticStringVSutlF","s7NIOCore15EventLoopFutureC3and5valueACyx_qd__tGqd___tlF","s7NIOCore15EventLoopFutureC3and_4file4lineACyx_qd__tGACyqd__G_s12StaticStringVSutlF","s7NIOCore15EventLoopFutureC3andyACyx_qd__tGACyqd__GlF","s7NIOCore15EventLoopFutureC3getxyYaKF","s7NIOCore15EventLoopFutureC3hop2toACyxGAA0bC0_p_tF","s7NIOCore15EventLoopFutureC3map4file4line_ACyqd__Gs12StaticStringV_Suqd__xctlF","s7NIOCore15EventLoopFutureC3mapyACyqd__Gqd__xclF","s7NIOCore15EventLoopFutureC4fold_4withACyxGSayACyqd__GG_AFx_qd__tctlF","s7NIOCore15EventLoopFutureC4wait4file4linexs12StaticStringV_SutKF","s7NIOCore15EventLoopFutureC6alwaysyACyxGys6ResultOyxs5Error_pGcF","s7NIOCore15EventLoopFutureC6unwrap6orElseACyqd__Gqd__yc_tqd__SgRszlF","s7NIOCore15EventLoopFutureC6unwrap7orErrorACyqd__Gs0G0_p_tqd__SgRszlF","s7NIOCore15EventLoopFutureC6unwrap9orReplaceACyqd__Gqd___tqd__SgRszlF","s7NIOCore15EventLoopFutureC7cascade2toyAA0bC7PromiseVyxGSg_tF","s7NIOCore15EventLoopFutureC7flatMap4file4line_ACyqd__Gs12StaticStringV_SuAGxctlF","s7NIOCore15EventLoopFutureC7flatMapyACyqd__GAExclF","s7NIOCore15EventLoopFutureC7recover4file4line_ACyxGs12StaticStringV_Suxs5Error_pctF","s7NIOCore15EventLoopFutureC7recoveryACyxGxs5Error_pcF","s7NIOCore16EventLoopPromiseV12completeWithyyAA0bC6FutureCyxGF","s7NIOCore16EventLoopPromiseV12completeWithyys6ResultOyxs5Error_pGF","s7NIOCore16EventLoopPromiseV16completeWithTaskyScTyyts5NeverOGxyYaYbKcF","s7NIOCore16EventLoopPromiseV4failyys5Error_pF","s7NIOCore16EventLoopPromiseV7succeedyyxF","s7NIOCore16IdleStateHandlerC11channelRead7context4datayAA07ChannelD7ContextC_AA6NIOAnyVtF","s7NIOCore16IdleStateHandlerC12handlerAdded7contextyAA07ChannelD7ContextC_tF","s7NIOCore16IdleStateHandlerC13channelActive7contextyAA07ChannelD7ContextC_tF","s7NIOCore16IdleStateHandlerC14handlerRemoved7contextyAA07ChannelD7ContextC_tF","s7NIOCore16IdleStateHandlerC19channelReadComplete7contextyAA07ChannelD7ContextC_tF","s7NIOCore16IdleStateHandlerC5write7context4data7promiseyAA07ChannelD7ContextC_AA6NIOAnyVAA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelP10leaveGroup_6device7promiseyAA13SocketAddressO_AA16NIONetworkDeviceVSgAA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelP10leaveGroup_7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelP10leaveGroup_9interface7promiseyAA13SocketAddressO_AA19NIONetworkInterfaceCSgAA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelP9joinGroup_6device7promiseyAA13SocketAddressO_AA16NIONetworkDeviceVSgAA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelP9joinGroup_7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelP9joinGroup_9interface7promiseyAA13SocketAddressO_AA19NIONetworkInterfaceCSgAA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelPAAE10leaveGroup_6device7promiseyAA13SocketAddressO_AA16NIONetworkDeviceVSgAA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelPAAE10leaveGroup_6deviceAA15EventLoopFutureCyytGAA13SocketAddressO_AA16NIONetworkDeviceVSgtF","s7NIOCore16MulticastChannelPAAE10leaveGroup_7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelPAAE10leaveGroup_9interfaceAA15EventLoopFutureCyytGAA13SocketAddressO_AA19NIONetworkInterfaceCSgtF","s7NIOCore16MulticastChannelPAAE10leaveGroupyAA15EventLoopFutureCyytGAA13SocketAddressOF","s7NIOCore16MulticastChannelPAAE9joinGroup_6device7promiseyAA13SocketAddressO_AA16NIONetworkDeviceVSgAA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelPAAE9joinGroup_6deviceAA15EventLoopFutureCyytGAA13SocketAddressO_AA16NIONetworkDeviceVSgtF","s7NIOCore16MulticastChannelPAAE9joinGroup_7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore16MulticastChannelPAAE9joinGroup_9interfaceAA15EventLoopFutureCyytGAA13SocketAddressO_AA19NIONetworkInterfaceCSgtF","s7NIOCore16MulticastChannelPAAE9joinGroupyAA15EventLoopFutureCyytGAA13SocketAddressOF","s7NIOCore16NIOInsecureNoTLSV06enableD0yxxF","s7NIOCore16NIONetworkDeviceV4hash4intoys6HasherVz_tF","s7NIOCore17EventLoopIteratorV4nextAA0bC0_pSgyF","s7NIOCore19BackPressureHandlerC14handlerRemoved7contextyAA07ChannelD7ContextC_tF","s7NIOCore19BackPressureHandlerC25channelWritabilityChanged7contextyAA07ChannelD7ContextC_tF","s7NIOCore19BackPressureHandlerC4read7contextyAA07ChannelD7ContextC_tF","s7NIOCore19ByteBufferAllocatorV6buffer12dispatchDataAA0bC0V8Dispatch0hG0V_tF","s7NIOCore19ByteBufferAllocatorV6buffer12staticStringAA0bC0Vs06StaticG0V_tF","s7NIOCore19ByteBufferAllocatorV6buffer5bytesAA0bC0Vx_tSTRzs5UInt8V7ElementRtzlF","s7NIOCore19ByteBufferAllocatorV6buffer6stringAA0bC0VSS_tF","s7NIOCore19ByteBufferAllocatorV6buffer7integer10endianness2asAA0bC0Vx_AA10EndiannessOxmts17FixedWidthIntegerRzlF","s7NIOCore19ByteBufferAllocatorV6buffer8capacityAA0bC0VSi_tF","s7NIOCore19ByteBufferAllocatorV6buffer9repeating5countAA0bC0Vs5UInt8V_SitF","s7NIOCore19ByteBufferAllocatorV6buffer9substringAA0bC0VSs_tF","s7NIOCore19ByteBufferAllocatorV6bufferAdA0bC0VAF_tF","s7NIOCore20AcceptBackoffHandlerC11errorCaught7context0E0yAA07ChannelD7ContextC_s5Error_ptF","s7NIOCore20AcceptBackoffHandlerC14handlerRemoved7contextyAA07ChannelD7ContextC_tF","s7NIOCore20AcceptBackoffHandlerC15channelInactive7contextyAA07ChannelD7ContextC_tF","s7NIOCore20AcceptBackoffHandlerC4read7contextyAA07ChannelD7ContextC_tF","s7NIOCore20ByteToMessageDecoderP10decodeLast7context6buffer7seenEOFAA13DecodingStateOAA21ChannelHandlerContextC_AA0B6BufferVzSbtKF","s7NIOCore20ByteToMessageDecoderP12decoderAdded7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderP14decoderRemoved7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderP18shouldReclaimBytes6bufferSbAA0B6BufferV_tF","s7NIOCore20ByteToMessageDecoderP6decode7context6bufferAA13DecodingStateOAA21ChannelHandlerContextC_AA0B6BufferVztKF","s7NIOCore20ByteToMessageDecoderPAAE10decodeLast7context6buffer7seenEOFAA13DecodingStateOAA21ChannelHandlerContextC_AA0B6BufferVzSbtKF","s7NIOCore20ByteToMessageDecoderPAAE12decoderAdded7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderPAAE14decoderRemoved7contextyAA21ChannelHandlerContextC_tF","s7NIOCore20ByteToMessageDecoderPAAE14wrapInboundOutyAA6NIOAnyV0gH0QzF","s7NIOCore20ByteToMessageDecoderPAAE18shouldReclaimBytes6bufferSbAA0B6BufferV_tF","s7NIOCore20ByteToMessageHandlerC06removeE07context12removalTokenyAA07ChannelE7ContextC_AH07RemovalI0VtF","s7NIOCore20ByteToMessageHandlerC11channelRead7context4datayAA07ChannelE7ContextC_AA6NIOAnyVtF","s7NIOCore20ByteToMessageHandlerC12handlerAdded7contextyAA07ChannelE7ContextC_tF","s7NIOCore20ByteToMessageHandlerC14handlerRemoved7contextyAA07ChannelE7ContextC_tF","s7NIOCore20ByteToMessageHandlerC15channelInactive7contextyAA07ChannelE7ContextC_tF","s7NIOCore20ByteToMessageHandlerC25userInboundEventTriggered7context5eventyAA07ChannelE7ContextC_yptF","s7NIOCore20ByteToMessageHandlerCA2A014WriteObservingbcD7DecoderRzrlE5write7context4data7promiseyAA07ChannelE7ContextC_AA6NIOAnyVAA16EventLoopPromiseVyytGSgtF","s7NIOCore20MarkedCircularBufferV02isB05indexSbAA0cD0V5IndexVyx_G_tF","s7NIOCore20MarkedCircularBufferV11removeFirstxyF","s7NIOCore20MarkedCircularBufferV4markyyF","s7NIOCore20MarkedCircularBufferV5index5afterAA0cD0V5IndexVyx_GAJ_tF","s7NIOCore20MarkedCircularBufferV5index6beforeAA0cD0V5IndexVyx_GAJ_tF","s7NIOCore20MarkedCircularBufferV5index_8offsetByAA0cD0V5IndexVyx_GAJ_SitF","s7NIOCore20MarkedCircularBufferV6appendyyxF","s7NIOCore20MarkedCircularBufferV8distance4from2toSiAA0cD0V5IndexVyx_G_AKtF","s7NIOCore20MarkedCircularBufferV8popFirstxSgyF","s7NIOCore20MessageToByteEncoderP6encode4data3outy10OutboundInQz_AA0D6BufferVztKF","s7NIOCore20MessageToByteHandlerC12handlerAdded7contextyAA07ChannelE7ContextC_tF","s7NIOCore20MessageToByteHandlerC14handlerRemoved7contextyAA07ChannelE7ContextC_tF","s7NIOCore20MessageToByteHandlerC5write7context4data7promiseyAA07ChannelE7ContextC_AA6NIOAnyVAA16EventLoopPromiseVyytGSgtF","s7NIOCore20NIOClientTLSProviderP9enableTLSy9BootstrapQzAFF","s7NIOCore20SocketOptionProviderP09unsafeGetbC05level4nameAA15EventLoopFutureCyqd__GAA12NIOBSDSocketO0C5LevelV_AK0C0VtlF","s7NIOCore20SocketOptionProviderP09unsafeGetbC05level4nameAA15EventLoopFutureCyqd__GSi_s5Int32VtlF","s7NIOCore20SocketOptionProviderP09unsafeSetbC05level4name5valueAA15EventLoopFutureCyytGAA12NIOBSDSocketO0C5LevelV_AL0C0Vqd__tlF","s7NIOCore20SocketOptionProviderP09unsafeSetbC05level4name5valueAA15EventLoopFutureCyytGSi_s5Int32Vqd__tlF","s7NIOCore20SocketOptionProviderPAAE10getTCPInfoAA15EventLoopFutureCySo8tcp_infoVGyF","s7NIOCore20SocketOptionProviderPAAE11getSoLingerAA15EventLoopFutureCySo6lingerVGyF","s7NIOCore20SocketOptionProviderPAAE11setSoLingeryAA15EventLoopFutureCyytGSo6lingerVF","s7NIOCore20SocketOptionProviderPAAE16getIPMulticastIFAA15EventLoopFutureCySo7in_addrVGyF","s7NIOCore20SocketOptionProviderPAAE16setIPMulticastIFyAA15EventLoopFutureCyytGSo7in_addrVF","s7NIOCore20SocketOptionProviderPAAE17getIPMulticastTTLAA15EventLoopFutureCys5UInt8VGyF","s7NIOCore20SocketOptionProviderPAAE17setIPMulticastTTLyAA15EventLoopFutureCyytGs5UInt8VF","s7NIOCore20SocketOptionProviderPAAE18getIPMulticastLoopAA05EventG6FutureCys5UInt8VGyF","s7NIOCore20SocketOptionProviderPAAE18getIPv6MulticastIFAA15EventLoopFutureCys6UInt32VGyF","s7NIOCore20SocketOptionProviderPAAE18setIPMulticastLoopyAA05EventG6FutureCyytGs5UInt8VF","s7NIOCore20SocketOptionProviderPAAE18setIPv6MulticastIFyAA15EventLoopFutureCyytGs6UInt32VF","s7NIOCore20SocketOptionProviderPAAE20getIPv6MulticastHopsAA15EventLoopFutureCys5Int32VGyF","s7NIOCore20SocketOptionProviderPAAE20getIPv6MulticastLoopAA05EventH6FutureCys6UInt32VGyF","s7NIOCore20SocketOptionProviderPAAE20setIPv6MulticastHopsyAA15EventLoopFutureCyytGs5Int32VF","s7NIOCore20SocketOptionProviderPAAE20setIPv6MulticastLoopyAA05EventH6FutureCyytGs6UInt32VF","s7NIOCore21ChannelHandlerContextC04fireB10RegisteredyyF","s7NIOCore21ChannelHandlerContextC04fireB12ReadCompleteyyF","s7NIOCore21ChannelHandlerContextC04fireB12UnregisteredyyF","s7NIOCore21ChannelHandlerContextC04fireB18WritabilityChangedyyF","s7NIOCore21ChannelHandlerContextC04fireB4ReadyyAA6NIOAnyVF","s7NIOCore21ChannelHandlerContextC04fireB6ActiveyyF","s7NIOCore21ChannelHandlerContextC04fireB8InactiveyyF","s7NIOCore21ChannelHandlerContextC13leavePipeline12removalTokenyAC07RemovalH0V_tF","s7NIOCore21ChannelHandlerContextC13writeAndFlush_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore21ChannelHandlerContextC15fireErrorCaughtyys0F0_pF","s7NIOCore21ChannelHandlerContextC24triggerUserOutboundEvent_7promiseyyp_AA0H11LoopPromiseVyytGSgtF","s7NIOCore21ChannelHandlerContextC29fireUserInboundEventTriggeredyyypF","s7NIOCore21ChannelHandlerContextC4bind2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore21ChannelHandlerContextC4readyyF","s7NIOCore21ChannelHandlerContextC5close4mode7promiseyAA9CloseModeO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore21ChannelHandlerContextC5flushyyF","s7NIOCore21ChannelHandlerContextC5write_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore21ChannelHandlerContextC7connect2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore21ChannelHandlerContextC8register7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore21ChannelInboundHandlerP04wrapC3OutyAA6NIOAnyV0cF0QzF","s7NIOCore21ChannelInboundHandlerP06unwrapC2Iny0cF0QzAA6NIOAnyVF","s7NIOCore21ChannelInboundHandlerPAAE04wrapC3OutyAA6NIOAnyV0cF0QzF","s7NIOCore21ChannelInboundHandlerPAAE06unwrapC2Iny0cF0QzAA6NIOAnyVF","s7NIOCore21ChannelInboundInvokerP04fireB10RegisteredyyF","s7NIOCore21ChannelInboundInvokerP04fireB12ReadCompleteyyF","s7NIOCore21ChannelInboundInvokerP04fireB12UnregisteredyyF","s7NIOCore21ChannelInboundInvokerP04fireB18WritabilityChangedyyF","s7NIOCore21ChannelInboundInvokerP04fireB4ReadyyAA6NIOAnyVF","s7NIOCore21ChannelInboundInvokerP04fireB6ActiveyyF","s7NIOCore21ChannelInboundInvokerP04fireB8InactiveyyF","s7NIOCore21ChannelInboundInvokerP08fireUserC14EventTriggeredyyypF","s7NIOCore21ChannelInboundInvokerP15fireErrorCaughtyys0F0_pF","s7NIOCore21NIOClientTCPBootstrapV13channelOption_5valueACx_5ValueQztAA07ChannelE0RzlF","s7NIOCore21NIOClientTCPBootstrapV14connectTimeoutyAcA10TimeAmountVF","s7NIOCore21NIOClientTCPBootstrapV18channelInitializeryAcA15EventLoopFutureCyytGAA7Channel_pcF","s7NIOCore21NIOClientTCPBootstrapV25channelConvenienceOptionsyAcA07ChannelF0V014TCPConvenienceF0VF","s7NIOCore21NIOClientTCPBootstrapV7connect20unixDomainSocketPathAA15EventLoopFutureCyAA7Channel_pGSS_tF","s7NIOCore21NIOClientTCPBootstrapV7connect2toAA15EventLoopFutureCyAA7Channel_pGAA13SocketAddressO_tF","s7NIOCore21NIOClientTCPBootstrapV7connect4host4portAA15EventLoopFutureCyAA7Channel_pGSS_SitF","s7NIOCore21NIOClientTCPBootstrapV9enableTLSACyF","s7NIOCore22ChannelOutboundHandlerP06unwrapC2Iny0cF0QzAA6NIOAnyVF","s7NIOCore22ChannelOutboundHandlerPAAE06unwrapC2Iny0cF0QzAA6NIOAnyVF","s7NIOCore22ChannelOutboundInvokerP011triggerUserC5Event_7promiseyyp_AA0G11LoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP13writeAndFlush_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP4bind2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP4readyyF","s7NIOCore22ChannelOutboundInvokerP5close4mode7promiseyAA9CloseModeO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP5flushyyF","s7NIOCore22ChannelOutboundInvokerP5write_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP7connect2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore22ChannelOutboundInvokerP8register7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore22ChannelOutboundInvokerPAAE011triggerUserC5Event_4file4lineAA0G10LoopFutureCyytGyp_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE011triggerUserC5Event_4file4lineyyp_s12StaticStringVSutYaKF","s7NIOCore22ChannelOutboundInvokerPAAE13writeAndFlush_4file4lineAA15EventLoopFutureCyytGAA6NIOAnyV_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE13writeAndFlush_4file4lineyAA6NIOAnyV_s12StaticStringVSutYaKF","s7NIOCore22ChannelOutboundInvokerPAAE4bind2to4file4lineAA15EventLoopFutureCyytGAA13SocketAddressO_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE4bind2to4file4lineyAA13SocketAddressO_s12StaticStringVSutYaKF","s7NIOCore22ChannelOutboundInvokerPAAE5close4mode4file4lineAA15EventLoopFutureCyytGAA9CloseModeO_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE5close4mode4file4lineyAA9CloseModeO_s12StaticStringVSutYaKF","s7NIOCore22ChannelOutboundInvokerPAAE5write_4file4lineAA15EventLoopFutureCyytGAA6NIOAnyV_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE7connect2to4file4lineAA15EventLoopFutureCyytGAA13SocketAddressO_s12StaticStringVSutF","s7NIOCore22ChannelOutboundInvokerPAAE7connect2to4file4lineyAA13SocketAddressO_s12StaticStringVSutYaKF","s7NIOCore22ChannelOutboundInvokerPAAE8register4file4lineAA15EventLoopFutureCyytGs12StaticStringV_SutF","s7NIOCore22ChannelOutboundInvokerPAAE8register4file4lineys12StaticStringV_SutYaKF","s7NIOCore22NIOCloseOnErrorHandlerC11errorCaught7context0F0yAA07ChannelE7ContextC_s0D0_ptF","s7NIOCore23RecvByteBufferAllocatorP6buffer9allocatorAA0cD0VAA0cdE0V_tF","s7NIOCore23RecvByteBufferAllocatorP6record15actualReadBytesSbSi_tF","s7NIOCore23RemovableChannelHandlerP06removeD07context12removalTokenyAA0cD7ContextC_AH07RemovalH0VtF","s7NIOCore23RemovableChannelHandlerPAAE06removeD07context12removalTokenyAA0cD7ContextC_AH07RemovalH0VtF","s7NIOCore28NIOSynchronousChannelOptionsP9getOptiony5ValueQyd__qd__KAA0cF0Rd__lF","s7NIOCore28NIOSynchronousChannelOptionsP9setOption_5valueyqd___5ValueQyd__tKAA0cF0Rd__lF","s7NIOCore29NIOClientTCPBootstrapProtocolP13channelOption_5valuexqd___5ValueQyd__tAA07ChannelF0Rd__lF","s7NIOCore29NIOClientTCPBootstrapProtocolP14connectTimeoutyxAA10TimeAmountVF","s7NIOCore29NIOClientTCPBootstrapProtocolP16protocolHandlersyxSayAA14ChannelHandler_pGycF","s7NIOCore29NIOClientTCPBootstrapProtocolP18channelInitializeryxAA15EventLoopFutureCyytGAA7Channel_pcF","s7NIOCore29NIOClientTCPBootstrapProtocolP7connect20unixDomainSocketPathAA15EventLoopFutureCyAA7Channel_pGSS_tF","s7NIOCore29NIOClientTCPBootstrapProtocolP7connect2toAA15EventLoopFutureCyAA7Channel_pGAA13SocketAddressO_tF","s7NIOCore29NIOClientTCPBootstrapProtocolP7connect4host4portAA15EventLoopFutureCyAA7Channel_pGSS_SitF","s7NIOCore31AdaptiveRecvByteBufferAllocatorV6buffer9allocatorAA0dE0VAA0deF0V_tF","s7NIOCore31AdaptiveRecvByteBufferAllocatorV6record15actualReadBytesSbSi_tF","s7NIOCore32FixedSizeRecvByteBufferAllocatorV6buffer9allocatorAA0eF0VAA0efG0V_tF","s7NIOCore32FixedSizeRecvByteBufferAllocatorV6record15actualReadBytesSbSi_tF","s7NIOCore33NIOSingleStepByteToMessageDecoderP10decodeLast6buffer7seenEOF10InboundOutQzSgAA0D6BufferVz_SbtKF","s7NIOCore33NIOSingleStepByteToMessageDecoderP6decode6buffer10InboundOutQzSgAA0D6BufferVz_tKF","s7NIOCore33NIOSingleStepByteToMessageDecoderPAAE10decodeLast7context6buffer7seenEOFAA13DecodingStateOAA21ChannelHandlerContextC_AA0D6BufferVzSbtKF","s7NIOCore33NIOSingleStepByteToMessageDecoderPAAE6decode7context6bufferAA13DecodingStateOAA21ChannelHandlerContextC_AA0D6BufferVztKF","s7NIOCore34WriteObservingByteToMessageDecoderP5write4datay10OutboundInQz_tF","s7NIOCore35NIOSingleStepByteToMessageProcessorC16finishProcessing7seenEOF_ySb_y10InboundOutQzKXEtKF","s7NIOCore35NIOSingleStepByteToMessageProcessorC7process6buffer_yAA0D6BufferV_y10InboundOutQzKXEtKF","s7NIOCore6IODataO15moveReaderIndex9forwardByySi_tF","s7NIOCore7ChannelP9getOptionyAA15EventLoopFutureCy5ValueQyd__Gqd__AA0bD0Rd__lF","s7NIOCore7ChannelP9setOption_5valueAA15EventLoopFutureCyytGqd___5ValueQyd__tAA0bD0Rd__lF","s7NIOCore7ChannelPAAE13writeAndFlush_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE13writeAndFlush_7promiseyqd___AA16EventLoopPromiseVyytGSgtlF","s7NIOCore7ChannelPAAE13writeAndFlushyAA15EventLoopFutureCyytGqd__lF","s7NIOCore7ChannelPAAE13writeAndFlushyyqd__YaKlF","s7NIOCore7ChannelPAAE24triggerUserOutboundEvent_7promiseyyp_AA0F11LoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE26registerAlreadyConfigured07promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore7ChannelPAAE4bind2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE4readyyF","s7NIOCore7ChannelPAAE5close4mode7promiseyAA9CloseModeO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE5flushyyF","s7NIOCore7ChannelPAAE5write_7promiseyAA6NIOAnyV_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE5write_7promiseyqd___AA16EventLoopPromiseVyytGSgtlF","s7NIOCore7ChannelPAAE5writeyAA15EventLoopFutureCyytGqd__lF","s7NIOCore7ChannelPAAE7connect2to7promiseyAA13SocketAddressO_AA16EventLoopPromiseVyytGSgtF","s7NIOCore7ChannelPAAE8register7promiseyAA16EventLoopPromiseVyytGSg_tF","s7NIOCore7ChannelPAAE9getOptiony5ValueQyd__qd__YaKAA0bD0Rd__lF","s7NIOCore7ChannelPAAE9setOption_5valueyqd___5ValueQyd__tYaKAA0bD0Rd__lF","s7NIOCore9EventLoopP014preconditionInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopP017preconditionNotInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopP12scheduleTask2in_AA9ScheduledVyqd__GAA10TimeAmountV_qd__yKctlF","s7NIOCore9EventLoopP12scheduleTask8deadline_AA9ScheduledVyqd__GAA11NIODeadlineV_qd__yKctlF","s7NIOCore9EventLoopP23makeSucceededVoidFutureAA0bcG0CyytGyF","s7NIOCore9EventLoopP6submityAA0bC6FutureCyqd__Gqd__yKclF","s7NIOCore9EventLoopP7executeyyyycF","s7NIOCore9EventLoopPAAE011assertNotInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE014preconditionInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE017preconditionNotInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE08assertInbC04file4lineys12StaticStringV_SutF","s7NIOCore9EventLoopPAAE10flatSubmityAA0bC6FutureCyqd__GAGyclF","s7NIOCore9EventLoopPAAE11makePromise2of4file4lineAA0bcE0Vyqd__Gqd__m_s12StaticStringVSutlF","s7NIOCore9EventLoopPAAE12makeIteratorAA0bcE0VyF","s7NIOCore9EventLoopPAAE16flatScheduleTask2in4file4line_AA9ScheduledVyqd__GAA10TimeAmountV_s12StaticStringVSuAA0bC6FutureCyqd__GyKctlF","s7NIOCore9EventLoopPAAE16flatScheduleTask8deadline4file4line_AA9ScheduledVyqd__GAA11NIODeadlineV_s12StaticStringVSuAA0bC6FutureCyqd__GyKctlF","s7NIOCore9EventLoopPAAE16makeFailedFuture_4file4lineAA0bcF0Cyqd__Gs5Error_p_s12StaticStringVSutlF","s7NIOCore9EventLoopPAAE16makeFailedFutureyAA0bcF0Cyqd__Gs5Error_plF","s7NIOCore9EventLoopPAAE19makeCompletedFutureyAA0bcF0Cyqd__Gs6ResultOyqd__s5Error_pGlF","s7NIOCore9EventLoopPAAE19makeSucceededFuture_4file4lineAA0bcF0Cyqd__Gqd___s12StaticStringVSutlF","s7NIOCore9EventLoopPAAE19makeSucceededFutureyAA0bcF0Cyqd__Gqd__lF","s7NIOCore9EventLoopPAAE20scheduleRepeatedTask12initialDelay5delay9notifying_AA0eF0CAA10TimeAmountV_AkA0bC7PromiseVyytGSgyAIKctF","s7NIOCore9EventLoopPAAE23makeSucceededVoidFutureAA0bcG0CyytGyF","s7NIOCore9EventLoopPAAE25scheduleRepeatedAsyncTask12initialDelay5delay9notifying_AA0eG0CAA10TimeAmountV_AkA0bC7PromiseVyytGSgAA0bC6FutureCyytGAIctF","s7NIOCore9EventLoopPAAE3anyAaB_pyF","s7NIOCore9EventLoopPAAE4nextAaB_pyF","s7NIOCore9EventLoopPAAE5closeyyKF","s7NIOCore9EventLoopPAAE6submityAA0bC6FutureCyqd__Gqd__yKclF","s7NIOCore9ScheduledV6cancelyyF","s7NIOCore10ByteBufferV2eeoiySbAC_ACtFZ","s7NIOCore10FileRegionV2eeoiySbAC_ACtFZ","s7NIOCore10TimeAmountV1loiySbAC_ACtFZ","s7NIOCore10TimeAmountV1moiyA2C_xtSzRzlFZ","s7NIOCore10TimeAmountV1moiyACx_ACtSzRzlFZ","s7NIOCore10TimeAmountV1poiyA2C_ACtFZ","s7NIOCore10TimeAmountV1soiyA2C_ACtFZ","s7NIOCore10TimeAmountV2peoiyyACz_ACtFZ","s7NIOCore10TimeAmountV2seoiyyACz_ACtFZ","s7NIOCore11NIODeadlineV1goiySbAC_ACtFZ","s7NIOCore11NIODeadlineV1loiySbAC_ACtFZ","s7NIOCore11NIODeadlineV1poiyA2C_AA10TimeAmountVtFZ","s7NIOCore11NIODeadlineV1soiyA2C_AA10TimeAmountVtFZ","s7NIOCore11NIODeadlineV1soiyAA10TimeAmountVAC_ACtFZ","s7NIOCore13SocketAddressO2eeoiySbAC_ACtFZ","s7NIOCore14ByteBufferViewV2eeoiySbAC_ACtFZ","s7NIOCore14CircularBufferV5IndexV1loiySbAEyx_G_AGtFZ","s7NIOCore14CircularBufferV5IndexV2eeoiySbAEyx_G_AGtFZ","s7NIOCore14CircularBufferVAASQRzlE2eeoiySbACyxG_AEtFZ","s7NIOCore15EventLoopFutureC2eeoiySbACyxG_AEtFZ","s7NIOCore16NIONetworkDeviceV2eeoiySbAC_ACtFZ","s7NIOCore19NIONetworkInterfaceC2eeoiySbAC_ACtFZ","s7NIOCore10TimeAmountV5Valuea","s7NIOCore11NIODeadlineV5Valuea","s7NIOCore11NIOSendablea","s7NIOCore12NIOBSDSocketO11OptionLevelV8RawValuea","s7NIOCore12NIOBSDSocketO13AddressFamilyV8RawValuea","s7NIOCore12NIOBSDSocketO14ProtocolFamilyV8RawValuea","s7NIOCore12NIOBSDSocketO6Handlea","s7NIOCore12NIOBSDSocketO6OptionV8RawValuea","s7NIOCore12SocketOptiona","s7NIOCore13BacklogOptiona","s7NIOCore14AutoReadOptiona","s7NIOCore14ByteBufferViewV11SubSequencea","s7NIOCore14ByteBufferViewV5Indexa","s7NIOCore14ByteBufferViewV7Elementa","s7NIOCore14ChannelOptionsV5TypesO12SocketOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO13BacklogOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO14AutoReadOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO15AllocatorOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO15WriteSpinOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO17ReceivePacketInfoV5Valuea","s7NIOCore14ChannelOptionsV5TypesO19RecvAllocatorOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO20ConnectTimeoutOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO24MaxMessagesPerReadOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO26WriteBufferWaterMarkOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO28AllowRemoteHalfClosureOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO36DatagramVectorReadMessageCountOptionV5Valuea","s7NIOCore14ChannelOptionsV5TypesO37ExplicitCongestionNotificationsOptionV5Valuea","s7NIOCore14CircularBufferV11SubSequencea","s7NIOCore14CircularBufferV7Elementa","s7NIOCore14CircularBufferV7Indicesa","s7NIOCore14CircularBufferV9RangeTypea","s7NIOCore15AllocatorOptiona","s7NIOCore15WriteSpinOptiona","s7NIOCore16IdleStateHandlerC10InboundOuta","s7NIOCore16IdleStateHandlerC10OutboundIna","s7NIOCore16IdleStateHandlerC11OutboundOuta","s7NIOCore16IdleStateHandlerC9InboundIna","s7NIOCore16SocketOptionNamea","s7NIOCore17EventLoopIteratorV7Elementa","s7NIOCore17SocketOptionLevela","s7NIOCore17SocketOptionValuea","s7NIOCore19BackPressureHandlerC10InboundOuta","s7NIOCore19BackPressureHandlerC10OutboundIna","s7NIOCore19BackPressureHandlerC11OutboundOuta","s7NIOCore19BackPressureHandlerC9InboundIna","s7NIOCore19RecvAllocatorOptiona","s7NIOCore20AcceptBackoffHandlerC10OutboundIna","s7NIOCore20AcceptBackoffHandlerC9InboundIna","s7NIOCore20ByteToMessageHandlerC10InboundOuta","s7NIOCore20ByteToMessageHandlerC9InboundIna","s7NIOCore20ByteToMessageHandlerCA2A014WriteObservingbcD7DecoderRzrlE10OutboundIna","s7NIOCore20ChannelDuplexHandlera","s7NIOCore20ConnectTimeoutOptiona","s7NIOCore20MarkedCircularBufferV11SubSequencea","s7NIOCore20MarkedCircularBufferV5Indexa","s7NIOCore20MarkedCircularBufferV9RangeTypea","s7NIOCore20MessageToByteHandlerC10OutboundIna","s7NIOCore20MessageToByteHandlerC11OutboundOuta","s7NIOCore20WriteBufferWaterMarka","s7NIOCore22NIOCloseOnErrorHandlerC9InboundIna","s7NIOCore24MaxMessagesPerReadOptiona","s7NIOCore26WriteBufferWaterMarkOptiona","s7NIOCore28AllowRemoteHalfClosureOptiona","s7NIOCore36DatagramVectorReadMessageCountOptiona","sSS7NIOCoreE6bufferSSAA10ByteBufferV_tcfc","sSa7NIOCores5UInt8VRszlE6bufferSayACGAA10ByteBufferV_tcfc","sSq7NIOCoreAA10ByteBufferVRszlE010setOrWriteC0ySiACzF","sSq7NIOCoreAA10ByteBufferVRszlE019setOrWriteImmutableC0ySiACF","c@S@in_addr","c@S@linger","c@S@sockaddr","c@S@sockaddr_in","c@S@sockaddr_in6","c@S@sockaddr_un","c@S@tcp_info","c@T@mode_t","s7NIOCore22_ChannelInboundHandlerP04userC14EventTriggered7context5eventyAA0bD7ContextC_yptF","s7NIOCore22_ChannelInboundHandlerP11channelRead7context4datayAA0bD7ContextC_AA6NIOAnyVtF","s7NIOCore22_ChannelInboundHandlerP11errorCaught7context0E0yAA0bD7ContextC_s5Error_ptF","s7NIOCore22_ChannelInboundHandlerP13channelActive7contextyAA0bD7ContextC_tF","s7NIOCore22_ChannelInboundHandlerP15channelInactive7contextyAA0bD7ContextC_tF","s7NIOCore22_ChannelInboundHandlerP19channelReadComplete7contextyAA0bD7ContextC_tF","s7NIOCore22_ChannelInboundHandlerP25channelWritabilityChanged7contextyAA0bD7ContextC_tF","s7NIOCore23_ChannelOutboundHandlerP4read7contextyAA0bD7ContextC_tF","s7NIOCore23_ChannelOutboundHandlerP5write7context4data7promiseyAA0bD7ContextC_AA6NIOAnyVAA16EventLoopPromiseVyytGSgtF","s7NIOCore23_EmittingChannelHandlerP11OutboundOutQa","s8Dispatch0A4DataV","s8Dispatch0A5QueueC","sSH","sSH4hash4intoys6HasherVz_tF","sSI","sSK","sSK12_RegexParserE10mapOffsetsySny5IndexQzGSi5lower_Si5uppert_tF","sSK12_RegexParserE14flatmapOffsetsySny5IndexQzGSi5lower_Si5uppertSgF","sSK17_StringProcessingSL7ElementRpzrlE10firstRange2ofSny5IndexQzGSgqd___tSlRd__ABQyd__ACRSlF","sSK9formIndex6beforey0B0Qzz_tF","sSKs11SubSequenceQzRszrlE10removeLast7ElementQzyF","sSKs11SubSequenceQzRszrlE10removeLastyySiF","sSKs11SubSequenceQzRszrlE7popLast7ElementQzSgyF","sSKsE10difference4from2bys20CollectionDifferenceVy7ElementQzGqd___SbAG_AGtXEtSKRd__AFQyd__AGRSlF","sSKsE4last5where7ElementQzSgSbADKXE_tKF","sSKsE4last7ElementQzSgvp","sSKsE6suffixy11SubSequenceQzSiF","sSKsE8dropLasty11SubSequenceQzSiF","sSKsE8reverseds18ReversedCollectionVyxGyF","sSKsE9formIndex6beforey0B0Qzz_tF","sSKsE9lastIndex5where0B0QzSgSb7ElementQzKXE_tKF","sSKsSQ7ElementRpzrlE10difference4froms20CollectionDifferenceVyABGqd___tSKRd__AAQyd__ABRSlF","sSKsSQ7ElementRpzrlE9lastIndex2of0C0QzSgAB_tF","sSKsSS7ElementRtzrlE6joined9separatorS2S_tF","sSL","sSL1goiySbx_xtFZ","sSL1loiySbx_xtFZ","sSLsE1goiySbx_xtFZ","sSLsE2geoiySbx_xtFZ","sSLsE2leoiySbx_xtFZ","sSLsE3zzloiySnyxGx_xtFZ","sSLsE3zzlopys16PartialRangeUpToVyxGxFZ","sSLsE3zzzoPys16PartialRangeFromVyxGxFZ","sSLsE3zzzoiySNyxGx_xtFZ","sSLsE3zzzopys19PartialRangeThroughVyxGxFZ","sSM","sSM39withContiguousMutableStorageIfAvailableyqd__Sgqd__Sry7ElementQzGzKXEKlF","sSMsE39withContiguousMutableStorageIfAvailableyqd__Sgqd__Sry7ElementQzGzKXEKlF","sSMsE6swapAtyy5IndexQz_ACtF","sSMsE9partition2by5IndexQzSb7ElementQzKXE_tKF","sSMsEy11SubSequenceQzSny5IndexQzGcip","sSMsEy11SubSequenceQzqd__cSXRd__5BoundQyd__5IndexRtzluip","sSMsEy11SubSequenceQzys15UnboundedRange_OXEcip","sSMsEys5SliceVyxGSny5IndexQzGcip","sSMsSKRzrlE7reverseyyF","sSMsSKRzrlE9partition2by5IndexSlQzSb7ElementSTQzKXE_tKF","sSMsSkRzSL7ElementSTRpzrlE4sortyyF","sSMsSkRzrlE4sort2byySb7ElementSTQz_ADtKXE_tKF","sSMsSkRzrlE7shuffle5usingyqd__z_tSGRd__lF","sSMsSkRzrlE7shuffleyyF","sSP","sSQ","sSQ2eeoiySbx_xtFZ","sSQsE2neoiySbx_xtFZ","sSR","sSS","sST","sST12_RegexParserE3allyS2b7ElementQzXEF","sST12_RegexParserE3anyyS2b7ElementQzXEF","sST12_RegexParserE4noneyS2b7ElementQzXEF","sST32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlF","sST7ElementQa","sSTs8IteratorSTQzRszrlE04makeA0xyF","sSTsE10allSatisfyyS2b7ElementQzKXEKF","sSTsE10compactMapySayqd__Gqd__Sg7ElementQzKXEKlF","sSTsE10enumerateds18EnumeratedSequenceVyxGyF","sSTsE13elementsEqual_2bySbqd___Sb7ElementQz_ACQyd__tKXEtKSTRd__lF","sSTsE19underestimatedCountSivp","sSTsE25lexicographicallyPrecedes_2bySbqd___Sb7ElementQz_ADtKXEtKSTRd__ACQyd__ADRSlF","sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlF","sSTsE3mapySayqd__Gqd__7ElementQzKXEKlF","sSTsE3max2by7ElementQzSgSbAD_ADtKXE_tKF","sSTsE3min2by7ElementQzSgSbAD_ADtKXE_tKF","sSTsE4drop5whiles17DropWhileSequenceVyxGSb7ElementQzKXE_tKF","sSTsE4lazys12LazySequenceVyxGvp","sSTsE5first5where7ElementQzSgSbADKXE_tKF","sSTsE5split9maxSplits25omittingEmptySubsequences14whereSeparatorSays10ArraySliceVy7ElementQzGGSi_S2bAHKXEtKF","sSTsE6filterySay7ElementQzGSbACKXEKF","sSTsE6prefix5whileSay7ElementQzGSbADKXE_tKF","sSTsE6prefixys14PrefixSequenceVyxGSiF","sSTsE6reduce4into_qd__qd__n_yqd__z_7ElementQztKXEtKlF","sSTsE6reduceyqd__qd___qd__qd___7ElementQztKXEtKlF","sSTsE6sorted2bySay7ElementQzGSbAD_ADtKXE_tKF","sSTsE6starts4with2bySbqd___Sb7ElementQz_ADQyd__tKXEtKSTRd__lF","sSTsE6suffixySay7ElementQzGSiF","sSTsE7flatMapySay7ElementQyd__Gqd__ABQzKXEKSTRd__lF","sSTsE7flatMapySayqd__Gqd__Sg7ElementQzKXEKlF","sSTsE7forEachyyy7ElementQzKXEKF","sSTsE8contains5whereS2b7ElementQzKXE_tKF","sSTsE8dropLastySay7ElementQzGSiF","sSTsE8reversedSay7ElementQzGyF","sSTsE8shuffled5usingSay7ElementQzGqd__z_tSGRd__lF","sSTsE8shuffledSay7ElementQzGyF","sSTsE9dropFirstys04DropB8SequenceVyxGSiF","sSTsSL7ElementRpzrlE25lexicographicallyPrecedesySbqd__STRd__AAQyd__ABRSlF","sSTsSL7ElementRpzrlE3maxABSgyF","sSTsSL7ElementRpzrlE3minABSgyF","sSTsSL7ElementRpzrlE6sortedSayABGyF","sSTsSQ7ElementRpzrlE13elementsEqualySbqd__STRd__AAQyd__ABRSlF","sSTsSQ7ElementRpzrlE5split9separator9maxSplits25omittingEmptySubsequencesSays10ArraySliceVyABGGAB_SiSbtF","sSTsSQ7ElementRpzrlE6starts4withSbqd___tSTRd__AAQyd__ABRSlF","sSTsSQ7ElementRpzrlE8containsySbABF","sSTsST7ElementRpzrlE6joined9separators14JoinedSequenceVyxGqd___tSTRd__AA_AAQZAARtd__lF","sSTsST7ElementRpzrlE6joineds15FlattenSequenceVyxGyF","sSTsSy7ElementRpzrlE6joined9separatorS2S_tF","sSW","sSY","sSY8RawValueQa","sSY8rawValue03RawB0Qzvp","sSY8rawValuexSg03RawB0Qz_tcfc","sSYsSHRzSH8RawValueSYRpzrlE04hashB0Sivp","sSYsSHRzSH8RawValueSYRpzrlE4hash4intoys6HasherVz_tF","sSZ","sSa","sSb","sScT","sSci","sSi","sSk","sSk5index5after5IndexQzAD_tF","sSk5index6before5IndexQzAD_tF","sSksE5index_8offsetBy07limitedC05IndexQzSgAE_SiAEtF","sSky11SubSequenceQzSny5IndexQzGcip","sSl","sSl10startIndex0B0Qzvp","sSl11SubSequenceQa","sSl12_RegexParserE15convertByOffset_2in5IndexQyd__ADQz_qd__tSlRd__lF","sSl12_RegexParserE15convertByOffset_2inSny5IndexQyd__GSnyADQzG_qd__tSlRd__lF","sSl12_RegexParserE5index8atOffset5IndexQzSi_tF","sSl12_RegexParserE5split6around11SubSequenceQz6prefix_A2E6suffixtSny5IndexQzG_tF","sSl12_RegexParserE6offset2ofSi5IndexQz_tF","sSl12_RegexParserE6offset7ofIndexSi0E0Qz_tF","sSl12_RegexParserE7offsets2ofSnySiGSny5IndexQzG_tF","sSl12_RegexParserSQ7ElementRpzrlE13tryDropPrefixy11SubSequenceQzSgqd__SlRd__ABQyd__ACRSlF","sSl12_RegexParserSQ7ElementRpzrlE13tryDropSuffixy11SubSequenceQzSgqd__SlRd__ABQyd__ACRSlF","sSl17_StringProcessing11SubSequenceQzRszSQ7ElementRpzrlE10trimPrefixyyqd__STRd__ADQyd__AERSlF","sSl17_StringProcessing11SubSequenceQzRszrlE10trimPrefix5whileySb7ElementQzKXE_tKF","sSl17_StringProcessingE14trimmingPrefix5while11SubSequenceQzSb7ElementQzKXE_tKF","sSl17_StringProcessingSQ7ElementRpzrlE10firstRange2ofSny5IndexQzGSgqd___tSlRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE14trimmingPrefixy11SubSequenceQzqd__STRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE5split9separator9maxSplits25omittingEmptySubsequencesSay11SubSequenceQzGqd___SiSbtSlRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE6ranges2ofSaySny5IndexQzGGqd___tSlRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE8containsySbqd__SlRd__ABQyd__ACRSlF","sSl5IndexQa","sSl5countSivp","sSl5index5after5IndexQzAD_tF","sSl5index_8offsetBy5IndexQzAD_SitF","sSl7IndicesQa","sSl7isEmptySbvp","sSl8distance4from2toSi5IndexQz_AEtF","sSl8endIndex0B0Qzvp","sSls11SubSequenceQzRszrlE11removeFirst7ElementQzyF","sSls11SubSequenceQzRszrlE11removeFirstyySiF","sSls11SubSequenceQzRszrlE8popFirst7ElementQzSgyF","sSlsE10firstIndex5where0B0QzSgSb7ElementQzKXE_tKF","sSlsE13randomElement0B0QzSgyF","sSlsE13randomElement5using0B0QzSgqd__z_tSGRd__lF","sSlsE19underestimatedCountSivp","sSlsE3mapySayqd__Gqd__7ElementQzKXEKlF","sSlsE4drop5while11SubSequenceQzSb7ElementQzKXE_tKF","sSlsE5countSivp","sSlsE5first7ElementQzSgvp","sSlsE5split9maxSplits25omittingEmptySubsequences14whereSeparatorSay11SubSequenceQzGSi_S2b7ElementQzKXEtKF","sSlsE6prefix4upTo11SubSequenceQz5IndexQz_tF","sSlsE6prefix5while11SubSequenceQzSb7ElementQzKXE_tKF","sSlsE6prefix7through11SubSequenceQz5IndexQz_tF","sSlsE6prefixy11SubSequenceQzSiF","sSlsE6suffix4from11SubSequenceQz5IndexQz_tF","sSlsE7isEmptySbvp","sSlsE9dropFirsty11SubSequenceQzSiF","sSlsE9formIndex5aftery0B0Qzz_tF","sSlsE9formIndex_8offsetBy07limitedD0Sb0B0Qzz_SiAEtF","sSlsE9formIndex_8offsetByy0B0Qzz_SitF","sSlsEy11SubSequenceQzqd__cSXRd__5BoundQyd__5IndexRtzluip","sSlsEy11SubSequenceQzys15UnboundedRange_OXEcip","sSlsSIyxG7IndicesRtzrlE7indicesAAvp","sSlsSQ7ElementRpzrlE10firstIndex2of0C0QzSgAB_tF","sSlsSQ7ElementRpzrlE5index2of5IndexQzSgAB_tF","sSlsSQ7ElementRpzrlE5split9separator9maxSplits25omittingEmptySubsequencesSay11SubSequenceQzGAB_SiSbtF","sSlss16IndexingIteratorVyxG0B0RtzrlE04makeB0ACyF","sSly11SubSequenceQzSny5IndexQzGcip","sSly7ElementQz5IndexQzcip","sSm","sSm11removeFirst7ElementQzyF","sSm11removeFirstyySiF","sSm14removeSubrangeyySny5IndexQzGF","sSm15replaceSubrange_4withySny5IndexQzG_qd__ntSlRd__7ElementQyd__AFRtzlF","sSm15reserveCapacityyySiF","sSm17_StringProcessingE10trimPrefix5whileySb7ElementQzKXE_tKF","sSm17_StringProcessingSQ7ElementRpzrlE10trimPrefixyyqd__STRd__ABQyd__ACRSlF","sSm17_StringProcessingSQ7ElementRpzrlE7replace_4with15maxReplacementsyqd___qd_0_SitSlRd__SlRd_0_ABQyd__ACRSABQyd_0_AGRSr0_lF","sSm17_StringProcessingSQ7ElementRpzrlE9replacing_4with15maxReplacementsxqd___qd_0_SitSlRd__SlRd_0_ABQyd__ACRSABQyd_0_AGRSr0_lF","sSm17_StringProcessingSQ7ElementRpzrlE9replacing_4with8subrange15maxReplacementsxqd___qd_0_Sny5IndexQzGSitSlRd__SlRd_0_ABQyd__ACRSABQyd_0_AKRSr0_lF","sSm6appendyy7ElementQznF","sSm6remove2at7ElementQz5IndexQz_tF","sSm9removeAll15keepingCapacityySb_tF","sSms11SubSequenceQzRszrlE11removeFirst7ElementQzyF","sSms11SubSequenceQzRszrlE11removeFirstyySiF","sSmsE11removeFirst7ElementQzyF","sSmsE11removeFirstyySiF","sSmsE14removeSubrangeyySny5IndexQzGF","sSmsE14removeSubrangeyyqd__SXRd__5BoundQyd__5IndexRtzlF","sSmsE15replaceSubrange_4withySny5IndexQzG_qd__tSlRd__7ElementQyd__AFRtzlF","sSmsE15replaceSubrange_4withyqd_0__qd__ntSlRd__SXRd_0_7ElementQyd__ACRtz5BoundQyd_0_5IndexRtzr0_lF","sSmsE15reserveCapacityyySiF","sSmsE1poiyxqd___xtSTRd__7ElementQyd__ABRtzlFZ","sSmsE1poiyxx_qd__tSTRd__7ElementQyd__ABRtzlFZ","sSmsE1poiyxx_qd__tSmRd__7ElementQyd__ABRtzlFZ","sSmsE2peoiyyxz_qd__tSTRd__7ElementQyd__ABRtzlFZ","sSmsE6append10contentsOfyqd__n_tSTRd__7ElementQyd__ACRtzlF","sSmsE6appendyy7ElementQznF","sSmsE6filteryxSb7ElementQzKXEKF","sSmsE6insert10contentsOf2atyqd__n_5IndexQztSlRd__7ElementQyd__AFRtzlF","sSmsE6insert_2aty7ElementQzn_5IndexQztF","sSmsE6remove2at7ElementQz5IndexQz_tF","sSmsE8applyingyxSgs20CollectionDifferenceVy7ElementQzGF","sSmsE9removeAll15keepingCapacityySb_tF","sSmsE9removeAll5whereySb7ElementQzKXE_tKF","sSmsE9repeating5countx7ElementQz_Sitcfc","sSmsEyxqd__cSTRd__7ElementQyd__AARtzlufc","sSmsSKRz11SubSequenceSlQzRszrlE10removeLast7ElementSTQzyF","sSmsSKRz11SubSequenceSlQzRszrlE10removeLastyySiF","sSmsSKRz11SubSequenceSlQzRszrlE7popLast7ElementSTQzSgyF","sSmsSKRzrlE10removeLast7ElementSTQzyF","sSmsSKRzrlE10removeLastyySiF","sSmsSKRzrlE7popLast7ElementSTQzSgyF","sSmsSMRzrlE9removeAll5whereySb7ElementSTQzKXE_tKF","sSmxycfc","sSn","sSq","sSs","sSt","sSt4next7ElementQzSgyF","sSu","sSw","sSx","sSz","ss10SetAlgebraP","ss10SetAlgebraPs7ElementQz012ArrayLiteralC0RtzrlE05arrayE0xAFd_tcfc","ss10SetAlgebraPsE10isDisjoint4withSbx_tF","ss10SetAlgebraPsE10isSuperset2ofSbx_tF","ss10SetAlgebraPsE11subtractingyxxF","ss10SetAlgebraPsE14isStrictSubset2ofSbx_tF","ss10SetAlgebraPsE16isStrictSuperset2ofSbx_tF","ss10SetAlgebraPsE7isEmptySbvp","ss10SetAlgebraPsE8isSubset2ofSbx_tF","ss10SetAlgebraPsE8subtractyyxF","ss10SetAlgebraPsEyxqd__ncSTRd__7ElementQyd__ACRtzlufc","ss12CUnsignedInta","ss12StaticStringV","ss13CUnsignedChara","ss17FixedWidthIntegerP","ss18AdditiveArithmeticP","ss18AdditiveArithmeticP1poiyxx_xtFZ","ss18AdditiveArithmeticP1soiyxx_xtFZ","ss18AdditiveArithmeticP2peoiyyxz_xtFZ","ss18AdditiveArithmeticP2seoiyyxz_xtFZ","ss18AdditiveArithmeticP4zeroxvpZ","ss18AdditiveArithmeticPsE1popyxxFZ","ss18AdditiveArithmeticPsE2peoiyyxz_xtFZ","ss18AdditiveArithmeticPsE2seoiyyxz_xtFZ","ss23CustomStringConvertibleP","ss23CustomStringConvertibleP11descriptionSSvp","ss23CustomStringConvertibleP12_RegexParserE21halfWidthCornerQuotedSSvp","ss25ExpressibleByArrayLiteralP","ss25ExpressibleByArrayLiteralP05arrayD0x0cD7ElementQzd_tcfc","ss28CustomDebugStringConvertibleP","ss28CustomDebugStringConvertibleP16debugDescriptionSSvp","ss4CInta","ss4Voida","ss5ErrorP","ss5Int32V","ss5Int64V","ss5NeverO","ss5UInt8V","ss6HasherV","ss6ResultO","ss6UInt32V","ss6UInt64V","ss8SendableP","ss9AnyObjecta","ss9OptionSetP","ss9OptionSetP8rawValuex03RawD0Qz_tcfc","ss9OptionSetPs7ElementQzRszrlE6insertySb8inserted_x17memberAfterInserttxF","ss9OptionSetPs7ElementQzRszrlE6removeyxSgxF","ss9OptionSetPs7ElementQzRszrlE6update4withxSgx_tF","ss9OptionSetPs7ElementQzRszrlE8containsySbxF","ss9OptionSetPsE12intersectionyxxF","ss9OptionSetPsE19symmetricDifferenceyxxF","ss9OptionSetPsE5unionyxxF","ss9OptionSetPss17FixedWidthInteger8RawValueRpzrlE16formIntersectionyyxF","ss9OptionSetPss17FixedWidthInteger8RawValueRpzrlE23formSymmetricDifferenceyyxF","ss9OptionSetPss17FixedWidthInteger8RawValueRpzrlE9formUnionyyxF","ss9OptionSetPss17FixedWidthInteger8RawValueRpzrlExycfc","ss9UnmanagedV"],"vertices":[{"p":["AsyncSequence","collect(upTo:into:)"],"f":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[" ",17],["maxBytes",2],[": ",17],["Int",18,1227],[", ",17],["into",1],[" ",17],["accumulationBuffer",2],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[": ",17],["Int",18],[", ",17],["into",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"e":[["Self.Element",2,"ByteBuffer",58]],"c":[["Self.Element",2,"ByteBuffer",58]],"d":"Accumulates an ``Swift/AsyncSequence`` of ``ByteBuffer``s into a single `accumulationBuffer`.\n- Parameters:\n  - accumulationBuffer: buffer to write all the elements of `self` into\n  - maxBytes: The maximum number of bytes this method is allowed to write into `accumulationBuffer`\n- Throws: ``NIOTooManyBytesError`` if the the sequence contains more than `maxBytes`.\nNote that previous elements of `self` might be already write to `accumulationBuffer`."},{"p":["AsyncSequence","collect(upTo:)"],"f":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[" ",17],["maxBytes",2],[": ",17],["Int",18,1227],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[": ",17],["Int",18],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ByteBuffer",18]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"e":[["Self.Element",2,"ByteBuffer",58]],"c":[["Self.Element",2,"ByteBuffer",58]],"d":"Accumulates an ``Swift/AsyncSequence`` of ``ByteBuffer``s into a single ``ByteBuffer``.\n- Parameters:\n  - maxBytes: The maximum number of bytes this method is allowed to accumulate\n- Throws: `NIOTooManyBytesError` if the the sequence contains more than `maxBytes`."},{"p":["AsyncSequence","collect(upTo:into:)"],"f":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[" ",17],["maxBytes",2],[": ",17],["Int",18,1227],[", ",17],["into",1],[" ",17],["accumulationBuffer",2],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[": ",17],["Int",18],[", ",17],["into",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"e":[["Self.Element",1,"RandomAccessCollection",1228],["Self.Element.Element",2,"UInt8",1384]],"c":[["Self.Element",1,"RandomAccessCollection",1228],["Self.Element.Element",2,"UInt8",1384]],"d":"Accumulates an ``Swift/AsyncSequence`` of ``Swift/RandomAccessCollection``s into a single `accumulationBuffer`.\n- Parameters:\n  - accumulationBuffer: buffer to write all the elements of `self` into\n  - maxBytes: The maximum number of bytes this method is allowed to write into `accumulationBuffer`\n- Throws: `NIOTooManyBytesError` if the the sequence contains more than `maxBytes`.\nNote that previous elements of `self` might already be write to `accumulationBuffer`."},{"p":["AsyncSequence","collect(upTo:using:)"],"f":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[" ",17],["maxBytes",2],[": ",17],["Int",18,1227],[", ",17],["using",1],[" ",17],["allocator",2],[": ",17],["ByteBufferAllocator",18,103],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["collect",7],["(",17],["upTo",1],[": ",17],["Int",18],[", ",17],["using",1],[": ",17],["ByteBufferAllocator",18],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ByteBuffer",18]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"e":[["Self.Element",1,"RandomAccessCollection",1228],["Self.Element.Element",2,"UInt8",1384]],"c":[["Self.Element",1,"RandomAccessCollection",1228],["Self.Element.Element",2,"UInt8",1384]],"d":"Accumulates an ``Swift/AsyncSequence`` of ``Swift/RandomAccessCollection``s into a single ``NIO/ByteBuffer``.\n- Parameters:\n  - maxBytes: The maximum number of bytes this method is allowed to accumulate\n  - allocator: Allocator used for allocating the result `ByteBuffer`\n- Throws: `NIOTooManyBytesError` if the the sequence contains more than `maxBytes`."},{"p":["DispatchData","init(buffer:)"],"f":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[")",17]],"s":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[")",17]],"d":"Creates a `DispatchData` from a given `ByteBuffer`. The entire readable portion of the buffer will be read.\n- parameter buffer: The buffer to read."},{"p":["DispatchQueue","asyncWithFuture(eventLoop:_:)"],"f":[["func",12],[" ",17],["asyncWithFuture",7],["<",17],["NewValue",0],[">(",17],["eventLoop",1],[": ",17],["EventLoop",18,28],[", ",17],["_",1],[" ",17],["callbackMayBlock",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["asyncWithFuture",7],["<",17],["NewValue",0],[">(",17],["eventLoop",1],[": ",17],["EventLoop",18],[", () ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"g":[["NewValue",0,0]],"d":"Schedules a work item for immediate execution and immediately returns with an `EventLoopFuture` providing the\nresult. For example:\n\n    let futureResult = DispatchQueue.main.asyncWithFuture(eventLoop: myEventLoop) { () -> String in\n        callbackMayBlock()\n    }\n    try let value = futureResult.wait()\n\n- parameters:\n    - eventLoop: the `EventLoop` on which to processes the IO / task specified by `callbackMayBlock`.\n    - callbackMayBlock: The scheduled callback for the IO / task.\n- returns a new `EventLoopFuture<ReturnType>` with value returned by the `block` parameter."},{"p":["ChannelCore"],"f":[["protocol",12],[" ",17],["ChannelCore",7],[" : AnyObject",17]],"s":[["protocol",12],[" ",17],["ChannelCore",7]],"d":"The core `Channel` methods that are for internal use of the `Channel` implementation only.\n\n- warning: If you are not implementing a custom `Channel` type, you should never call any of these.\n\n- note: All methods must be called from the `EventLoop` thread."},{"p":["ChannelOption"],"f":[["protocol",12],[" ",17],["ChannelOption",7],[" : ",17],["Equatable",18,1161]],"s":[["protocol",12],[" ",17],["ChannelOption",7]],"d":"A configuration option that can be set on a `Channel` to configure different behaviour."},{"p":["ChannelHandler"],"f":[["protocol",12],[" ",17],["ChannelHandler",7],[" : AnyObject",17]],"s":[["protocol",12],[" ",17],["ChannelHandler",7]],"d":"You should _never_ implement this protocol directly. Please implement one of its sub-protocols."},{"p":["ChannelInvoker"],"f":[["protocol",12],[" ",17],["ChannelInvoker",7],[" : ",17],["ChannelInboundInvoker",18,18],[", ",17],["ChannelOutboundInvoker",18,20]],"s":[["protocol",12],[" ",17],["ChannelInvoker",7]],"d":"A protocol that signals that outbound and inbound events are triggered by this invoker."},{"p":["EventLoopGroup"],"f":[["protocol",12],[" ",17],["EventLoopGroup",7],[" : AnyObject",17]],"s":[["protocol",12],[" ",17],["EventLoopGroup",7]],"d":"Provides an endless stream of `EventLoop`s to use."},{"p":["FileDescriptor"],"f":[["protocol",12],[" ",17],["FileDescriptor",7]],"s":[["protocol",12],[" ",17],["FileDescriptor",7]]},{"p":["MulticastChannel"],"f":[["protocol",12],[" ",17],["MulticastChannel",7],[" : ",17],["Channel",18,27]],"s":[["protocol",12],[" ",17],["MulticastChannel",7]],"d":"A `MulticastChannel` is a `Channel` that supports IP multicast operations: that is, a channel that can join multicast\ngroups.\n\n- note: As with `Channel`, all operations on a `MulticastChannel` are thread-safe."},{"p":["ByteToMessageDecoder"],"f":[["protocol",12],[" ",17],["ByteToMessageDecoder",7]],"s":[["protocol",12],[" ",17],["ByteToMessageDecoder",7]],"d":"`ByteToMessageDecoder`s decode bytes in a stream-like fashion from `ByteBuffer` to another message type.\n\n### Purpose\n\nA `ByteToMessageDecoder` provides a simplified API for handling streams of incoming data that can be broken\nup into messages. This API boils down to two methods: `decode`, and `decodeLast`. These two methods, when\nimplemented, will be used by a `ByteToMessageHandler` paired with a `ByteToMessageDecoder` to decode the\nincoming byte stream into a sequence of messages.\n\nThe reason this helper exists is to smooth away some of the boilerplate and edge case handling code that\nis often necessary when implementing parsers in a SwiftNIO `ChannelPipeline`. A `ByteToMessageDecoder`\nnever needs to worry about how inbound bytes will be buffered, as `ByteToMessageHandler` deals with that\nautomatically. A `ByteToMessageDecoder` also never needs to worry about memory exclusivity violations\nthat can occur when re-entrant `ChannelPipeline` operations occur, as `ByteToMessageHandler` will deal with\nthose as well.\n\n### Implementing ByteToMessageDecoder\n\nA type that implements `ByteToMessageDecoder` may implement two methods: decode and decodeLast. Implementations\nmust implement decode: if they do not implement decodeLast, a default implementation will be used that \nsimply calls decode.\n\n`decode` is the main decoding method, and is the one that will be called most often. `decode` is invoked\nwhenever data is received by the wrapping `ByteToMessageHandler`. It is invoked with a `ByteBuffer` containing\nall the received data (including any data previously buffered), as well as a `ChannelHandlerContext` that can be\nused in the `decode` function.\n\n`decode` is called in a loop by the `ByteToMessageHandler`. This loop continues until one of two cases occurs:\n\n1. The input `ByteBuffer` has no more readable bytes (i.e. `.readableBytes == 0`); OR\n2. The `decode` method returns `.needMoreData`.\n\nThe reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are\nrespected. It is entirely possible for `ByteToMessageDecoder` to receive either fewer bytes than a single message,\nor multiple messages in one go. Rather than have the `ByteToMessageDecoder` handle all of the complexity of this,\nthe logic can be boiled down to a single choice: has the `ByteToMessageDecoder` been able to move the state forward\nor not? If it has, rather than containing an internal loop it may simply return `.continue` in order to request that\n`decode` be invoked again immediately. If it has not, it can return `.needMoreData` to ask to be left alone until more\ndata has been returned from the network.\n\nEssentially, if the next parsing step could not be taken because there wasn't enough data available, return `.needMoreData`.\nOtherwise, return `.continue`. This will allow a `ByteToMessageDecoder` implementation to ignore the awkward way data\narrives from the network, and to just treat it as a series of `decode` calls.\n\n`decodeLast` is a cousin of `decode`. It is also called in a loop, but unlike with `decode` this loop will only ever\noccur once: when the `ChannelHandlerContext` belonging to this `ByteToMessageDecoder` is about to become invalidated.\nThis invalidation happens in two situations: when EOF is received from the network, or when the `ByteToMessageDecoder`\nis being removed from the `ChannelPipeline`. The distinction between these two states is captured by the value of\n`seenEOF`.\n\nIn this condition, the `ByteToMessageDecoder` must now produce any final messages it can with the bytes it has\navailable. In protocols where EOF is used as a message delimiter, having `decodeLast` called with `seenEOF == true`\nmay produce further messages. In other cases, `decodeLast` may choose to deliver any buffered bytes as \"leftovers\",\neither in error messages or via `channelRead`. This can occur if, for example, a protocol upgrade is occurring.\n\nAs with `decode`, `decodeLast` is invoked in a loop. This allows the same simplification as `decode` allows: when\na message is completely parsed, the `decodeLast` function can return `.continue` and be re-invoked from the top,\nrather than containing an internal loop.\n\nNote that the value of `seenEOF` may change between calls to `decodeLast` in some rare situations.\n\n### Implementers Notes\n\n/// `ByteToMessageHandler` will turn your `ByteToMessageDecoder` into a `ChannelInboundHandler`. `ByteToMessageHandler`\nalso solves a couple of tricky issues for you. Most importantly, in a `ByteToMessageDecoder` you do _not_ need to\nworry about re-entrancy. Your code owns the passed-in `ByteBuffer` for the duration of the `decode`/`decodeLast` call and\ncan modify it at will.\n\nIf a custom frame decoder is required, then one needs to be careful when implementing\none with `ByteToMessageDecoder`. Ensure there are enough bytes in the buffer for a\ncomplete frame by checking `buffer.readableBytes`. If there are not enough bytes\nfor a complete frame, return without modifying the reader index to allow more bytes to arrive.\n\nTo check for complete frames without modifying the reader index, use methods like `buffer.getInteger`.\nYou  _MUST_ use the reader index when using methods like `buffer.getInteger`.\nFor example calling `buffer.getInteger(at: 0)` is assuming the frame starts at the beginning of the buffer, which\nis not always the case. Use `buffer.getInteger(at: buffer.readerIndex)` instead.\n\nIf you move the reader index forward, either manually or by using one of `buffer.read*` methods, you must ensure\nthat you no longer need to see those bytes again as they will not be returned to you the next time `decode` is\ncalled. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to\nperform your read operations on.\n\nThe `ByteBuffer` passed in as `buffer` is a slice of a larger buffer owned by the `ByteToMessageDecoder`\nimplementation. Some aspects of this buffer are preserved across calls to `decode`, meaning that any changes to\nthose properties you make in your `decode` method will be reflected in the next call to decode. In particular,\nmoving the reader index forward persists across calls. When your method returns, if the reader index has advanced,\nthose bytes are considered \"consumed\" and will not be available in future calls to `decode`.\nPlease note, however, that the numerical value of the `readerIndex` itself is not preserved, and may not be the same\nfrom one call to the next. Please do not rely on this numerical value: if you need\nto recall where a byte is relative to the `readerIndex`, use an offset rather than an absolute value.\n\n### Using ByteToMessageDecoder\n\nTo add a `ByteToMessageDecoder` to the `ChannelPipeline` use\n\n    channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))\n"},{"p":["MessageToByteEncoder"],"f":[["protocol",12],[" ",17],["MessageToByteEncoder",7]],"s":[["protocol",12],[" ",17],["MessageToByteEncoder",7]],"d":"A protocol for straightforward encoders which encode custom messages to `ByteBuffer`s.\nTo add a `MessageToByteEncoder` to a `ChannelPipeline`, use\n`channel.pipeline.addHandler(MessageToByteHandler(myEncoder)`."},{"p":["NIOClientTLSProvider"],"f":[["protocol",12],[" ",17],["NIOClientTLSProvider",7]],"s":[["protocol",12],[" ",17],["NIOClientTLSProvider",7]]},{"p":["SocketOptionProvider"],"f":[["protocol",12],[" ",17],["SocketOptionProvider",7]],"s":[["protocol",12],[" ",17],["SocketOptionProvider",7]],"d":"This protocol defines an object, most commonly a `Channel`, that supports\nsetting and getting socket options (via `setsockopt`/`getsockopt` or similar).\nIt provides a strongly typed API that makes working with larger, less-common\nsocket options easier than the `ChannelOption` API allows.\n\nThe API is divided into two portions. For socket options that NIO has prior\nknowledge about, the API has strongly and safely typed APIs that only allow\nusers to use the exact correct type for the socket option. This will ensure\nthat the API is safe to use, and these are encouraged where possible.\n\nThese safe APIs are built on top of an \"unsafe\" API that is also exposed to\nusers as part of this protocol. The \"unsafe\" API is unsafe in the same way\nthat `UnsafePointer` is: incorrect use of the API allows all kinds of\nmemory-unsafe behaviour. This API is necessary for socket options that NIO\ndoes not have prior knowledge of, but wherever possible users are discouraged\nfrom using it.\n\n### Relationship to SocketOption\n\nAll `Channel` objects that implement this protocol should also support the\n`SocketOption` `ChannelOption` for simple socket options (those with C `int`\nvalues). These are the most common socket option types, and so this `ChannelOption`\nrepresents a convenient shorthand for using this protocol where the type allows,\nas well as avoiding the need to cast to this protocol.\n\n- note: Like the `Channel` protocol, all methods in this protocol are\n    thread-safe."},{"p":["ChannelInboundHandler"],"f":[["protocol",12],[" ",17],["ChannelInboundHandler",7],[" : ",17],["_ChannelInboundHandler",18],[", ",17],["_EmittingChannelHandler",18]],"s":[["protocol",12],[" ",17],["ChannelInboundHandler",7]],"d":"`ChannelHandler` which handles inbound I/O events for a `Channel`.\n\nPlease refer to `_ChannelInboundHandler` and `_EmittingChannelHandler` for more details on the provided methods."},{"p":["ChannelInboundInvoker"],"f":[["protocol",12],[" ",17],["ChannelInboundInvoker",7]],"s":[["protocol",12],[" ",17],["ChannelInboundInvoker",7]],"d":"Fire inbound events related to a `Channel` through the `ChannelPipeline` until its end is reached or it's consumed by a `ChannelHandler`."},{"p":["ChannelOutboundHandler"],"f":[["protocol",12],[" ",17],["ChannelOutboundHandler",7],[" : ",17],["_ChannelOutboundHandler",18],[", ",17],["_EmittingChannelHandler",18]],"s":[["protocol",12],[" ",17],["ChannelOutboundHandler",7]],"d":"`ChannelHandler` which handles outbound I/O events or intercept an outbound I/O operation for a `Channel`.\n\nPlease refer to `_ChannelOutboundHandler` and `_EmittingChannelHandler` for more details on the provided methods."},{"p":["ChannelOutboundInvoker"],"f":[["protocol",12],[" ",17],["ChannelOutboundInvoker",7]],"s":[["protocol",12],[" ",17],["ChannelOutboundInvoker",7]],"d":"Allows users to invoke an \"outbound\" operation related to a `Channel` that will flow through the `ChannelPipeline` until\nit will finally be executed by the the `ChannelCore` implementation."},{"p":["RecvByteBufferAllocator"],"f":[["protocol",12],[" ",17],["RecvByteBufferAllocator",7]],"s":[["protocol",12],[" ",17],["RecvByteBufferAllocator",7]],"d":"Allocates `ByteBuffer`s to be used to read bytes from a `Channel` and records the number of the actual bytes that were used."},{"p":["RemovableChannelHandler"],"f":[["protocol",12],[" ",17],["RemovableChannelHandler",7],[" : ",17],["ChannelHandler",18,8]],"s":[["protocol",12],[" ",17],["RemovableChannelHandler",7]],"d":"A `RemovableChannelHandler` is a `ChannelHandler` that can be dynamically removed from a `ChannelPipeline` whilst\nthe `Channel` is operating normally.\nA `RemovableChannelHandler` is required to remove itself from the `ChannelPipeline` (using\n`ChannelHandlerContext.removeHandler`) as soon as possible.\n\n- note: When a `Channel` gets torn down, every `ChannelHandler` in the `Channel`'s `ChannelPipeline` will be\n        removed from the `ChannelPipeline`. Those removals however happen synchronously and are not going through\n        the methods of this protocol."},{"p":["NIOSynchronousChannelOptions"],"f":[["protocol",12],[" ",17],["NIOSynchronousChannelOptions",7]],"s":[["protocol",12],[" ",17],["NIOSynchronousChannelOptions",7]]},{"p":["NIOClientTCPBootstrapProtocol"],"f":[["protocol",12],[" ",17],["NIOClientTCPBootstrapProtocol",7]],"s":[["protocol",12],[" ",17],["NIOClientTCPBootstrapProtocol",7]],"d":"`NIOClientTCPBootstrapProtocol` is implemented by various underlying transport mechanisms. Typically,\nthis will be the BSD Sockets API implemented by `ClientBootstrap`."},{"p":["NIOSingleStepByteToMessageDecoder"],"f":[["protocol",12],[" ",17],["NIOSingleStepByteToMessageDecoder",7],[" : ",17],["ByteToMessageDecoder",18,13]],"s":[["protocol",12],[" ",17],["NIOSingleStepByteToMessageDecoder",7]],"d":"A simplified version of `ByteToMessageDecoder` that can generate zero or one messages for each invocation of `decode` or `decodeLast`.\nHaving `decode` and `decodeLast` return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access\nto the `ByteBuffer` when returning. This allows for greatly simplified processing.\n\nMany `ByteToMessageDecoder`'s can trivially be translated to `NIOSingleStepByteToMessageDecoder`'s. You should not implement\n`ByteToMessageDecoder`'s `decode` and `decodeLast` methods."},{"p":["WriteObservingByteToMessageDecoder"],"f":[["protocol",12],[" ",17],["WriteObservingByteToMessageDecoder",7],[" : ",17],["ByteToMessageDecoder",18,13]],"s":[["protocol",12],[" ",17],["WriteObservingByteToMessageDecoder",7]],"d":"Some `ByteToMessageDecoder`s need to observe `write`s (which are outbound events). `ByteToMessageDecoder`s which\nimplement the `WriteObservingByteToMessageDecoder` protocol will be notified about every outbound write.\n\n`WriteObservingByteToMessageDecoder` may only observe a `write` and must not try to transform or block it in any\nway. After the `write` method returns the `write` will be forwarded to the next outbound handler."},{"p":["Channel"],"f":[["protocol",12],[" ",17],["Channel",7],[" : AnyObject, ",17],["ChannelOutboundInvoker",18,20]],"s":[["protocol",12],[" ",17],["Channel",7]],"d":"A `Channel` is easiest thought of as a network socket. But it can be anything that is capable of I/O operations such\nas read, write, connect, and bind.\n\n- note: All operations on `Channel` are thread-safe.\n\nIn SwiftNIO, all I/O operations are asynchronous and hence all operations on `Channel` are asynchronous too. This means\nthat all I/O operations will return immediately, usually before the work has been completed. The `EventLoopPromise`s\npassed to or returned by the operations are used to retrieve the result of an operation after it has completed.\n\nA `Channel` owns its `ChannelPipeline` which handles all I/O events and requests associated with the `Channel`."},{"p":["EventLoop"],"f":[["protocol",12],[" ",17],["EventLoop",7],[" : ",17],["EventLoopGroup",18,10]],"s":[["protocol",12],[" ",17],["EventLoop",7]],"d":"An EventLoop processes IO / tasks in an endless loop for `Channel`s until it's closed.\n\nUsually multiple `Channel`s share the same `EventLoop` for processing IO / tasks and so share the same processing `NIOThread`.\nFor a better understanding of how such an `EventLoop` works internally the following pseudo code may be helpful:\n\n```\nwhile eventLoop.isOpen {\n    /// Block until there is something to process for 1...n Channels\n    let readyChannels = blockUntilIoOrTasksAreReady()\n    /// Loop through all the Channels\n    for channel in readyChannels {\n        /// Process IO and / or tasks for the Channel.\n        /// This may include things like:\n        ///    - accept new connection\n        ///    - connect to a remote host\n        ///    - read from socket\n        ///    - write to socket\n        ///    - tasks that were submitted via EventLoop methods\n        /// and others.\n        processIoAndTasks(channel)\n    }\n}\n```\n\nBecause an `EventLoop` may be shared between multiple `Channel`s it's important to _NOT_ block while processing IO / tasks. This also includes long running computations which will have the same\neffect as blocking in this case."},{"p":["ChannelOption","Value"],"f":[["associatedtype",12],[" ",17],["Value",7]],"s":[["associatedtype",12],[" ",17],["Value",7]],"d":"The type of the `ChannelOption`'s value."},{"p":["ByteToMessageDecoder","InboundOut"],"f":[["associatedtype",12],[" ",17],["InboundOut",7]],"s":[["associatedtype",12],[" ",17],["InboundOut",7]],"d":"The type of the messages this `ByteToMessageDecoder` decodes to."},{"p":["MessageToByteEncoder","OutboundIn"],"f":[["associatedtype",12],[" ",17],["OutboundIn",7]],"s":[["associatedtype",12],[" ",17],["OutboundIn",7]]},{"p":["NIOClientTLSProvider","Bootstrap"],"f":[["associatedtype",12],[" ",17],["Bootstrap",7]],"s":[["associatedtype",12],[" ",17],["Bootstrap",7]]},{"p":["ChannelInboundHandler","InboundIn"],"f":[["associatedtype",12],[" ",17],["InboundIn",7]],"s":[["associatedtype",12],[" ",17],["InboundIn",7]],"d":"The type of the inbound data which is wrapped in `NIOAny`."},{"p":["ChannelInboundHandler","InboundOut"],"f":[["associatedtype",12],[" ",17],["InboundOut",7],[" = ",17],["Never",18,1383]],"s":[["associatedtype",12],[" ",17],["InboundOut",7],[" = ",17],["Never",18]],"d":"The type of the inbound data which will be forwarded to the next `ChannelInboundHandler` in the `ChannelPipeline`."},{"p":["ChannelOutboundHandler","OutboundIn"],"f":[["associatedtype",12],[" ",17],["OutboundIn",7]],"s":[["associatedtype",12],[" ",17],["OutboundIn",7]],"d":"The type of the outbound data which is wrapped in `NIOAny`."},{"p":["NIOSingleStepByteToMessageDecoder","InboundOut"],"f":[["associatedtype",12],[" ",17],["InboundOut",7]],"s":[["associatedtype",12],[" ",17],["InboundOut",7]],"d":"The decoded type this `NIOSingleStepByteToMessageDecoder` decodes to. To conform to `ByteToMessageDecoder` it must be called\n`InboundOut` - see https://bugs.swift.org/browse/SR-11868."},{"p":["WriteObservingByteToMessageDecoder","OutboundIn"],"f":[["associatedtype",12],[" ",17],["OutboundIn",7]],"s":[["associatedtype",12],[" ",17],["OutboundIn",7]],"d":"The type of `write`s."},{"p":["Endianness"],"f":[["enum",12],[" ",17],["Endianness",7]],"s":[["enum",12],[" ",17],["Endianness",7]],"d":"Endianness refers to the sequential order in which bytes are arranged into larger numerical values when stored in\nmemory or when transmitted over digital links."},{"p":["ChannelError"],"f":[["enum",12],[" ",17],["ChannelError",7]],"s":[["enum",12],[" ",17],["ChannelError",7]],"d":"An error that can occur on `Channel` operations."},{"p":["ChannelEvent"],"f":[["enum",12],[" ",17],["ChannelEvent",7]],"s":[["enum",12],[" ",17],["ChannelEvent",7]],"d":"An `Channel` related event that is passed through the `ChannelPipeline` to notify the user."},{"p":["NIOBSDSocket"],"f":[["enum",12],[" ",17],["NIOBSDSocket",7]],"s":[["enum",12],[" ",17],["NIOBSDSocket",7]]},{"p":["DecodingState"],"f":[["enum",12],[" ",17],["DecodingState",7]],"s":[["enum",12],[" ",17],["DecodingState",7]],"d":"State of the current decoding process."},{"p":["SocketAddress"],"f":[["enum",12],[" ",17],["SocketAddress",7]],"s":[["enum",12],[" ",17],["SocketAddress",7]],"d":"Represent a socket address to which we may want to connect or bind."},{"p":["ChannelOptions","Types"],"f":[["enum",12],[" ",17],["Types",7]],"s":[["enum",12],[" ",17],["Types",7]]},{"p":["ChannelOptions","Types","ConvenienceOptionValue"],"f":[["enum",12],[" ",17],["ConvenienceOptionValue",7],["<",17],["ValueType",0],[">",17]],"s":[["enum",12],[" ",17],["ConvenienceOptionValue",7]],"g":[["ValueType",0,0]],"d":"Has an option been set?\nOption has a value of generic type ValueType."},{"p":["EventLoopError"],"f":[["enum",12],[" ",17],["EventLoopError",7]],"s":[["enum",12],[" ",17],["EventLoopError",7]],"d":"Different `Error`s that are specific to `EventLoop` operations / implementations."},{"p":["ChannelPipeline","Position"],"f":[["enum",12],[" ",17],["Position",7]],"s":[["enum",12],[" ",17],["Position",7]],"d":"A `Position` within the `ChannelPipeline` used to insert handlers into the `ChannelPipeline`."},{"p":["IdleStateHandler","IdleStateEvent"],"f":[["enum",12],[" ",17],["IdleStateEvent",7]],"s":[["enum",12],[" ",17],["IdleStateEvent",7]],"d":"A user event triggered by IdleStateHandler when a Channel is idle."},{"p":["SocketAddressError"],"f":[["enum",12],[" ",17],["SocketAddressError",7]],"s":[["enum",12],[" ",17],["SocketAddressError",7]],"d":"Special `Error` that may be thrown if we fail to create a `SocketAddress`."},{"p":["ChannelPipelineError"],"f":[["enum",12],[" ",17],["ChannelPipelineError",7]],"s":[["enum",12],[" ",17],["ChannelPipelineError",7]],"d":"`Error` that is used by the `ChannelPipeline` to inform the user of an error."},{"p":["ByteToMessageDecoderError"],"f":[["enum",12],[" ",17],["ByteToMessageDecoderError",7]],"s":[["enum",12],[" ",17],["ByteToMessageDecoderError",7]],"d":"Common errors thrown by `ByteToMessageDecoder`s."},{"p":["NIOEventLoopGroupProvider"],"f":[["enum",12],[" ",17],["NIOEventLoopGroupProvider",7]],"s":[["enum",12],[" ",17],["NIOEventLoopGroupProvider",7]],"d":"This type is intended to be used by libraries which use NIO, and offer their users either the option\nto `.share` an existing event loop group or create (and manage) a new one (`.createNew`) and let it be\nmanaged by given library and its lifecycle."},{"p":["NIOExplicitCongestionNotificationState"],"f":[["enum",12],[" ",17],["NIOExplicitCongestionNotificationState",7]],"s":[["enum",12],[" ",17],["NIOExplicitCongestionNotificationState",7]],"d":"Possible Explicit Congestion Notification States"},{"p":["IOData"],"f":[["enum",12],[" ",17],["IOData",7]],"s":[["enum",12],[" ",17],["IOData",7]],"d":"`IOData` unifies standard SwiftNIO types that are raw bytes of data; currently `ByteBuffer` and `FileRegion`.\n\nMany `ChannelHandler`s receive or emit bytes and in most cases this can be either a `ByteBuffer` or a `FileRegion`\nfrom disk. To still form a well-typed `ChannelPipeline` such handlers should receive and emit value of type `IOData`."},{"p":["System"],"f":[["enum",12],[" ",17],["System",7]],"s":[["enum",12],[" ",17],["System",7]]},{"p":["IOError","FailureDescription"],"f":[["enum",12],[" ",17],["FailureDescription",7]],"s":[["enum",12],[" ",17],["FailureDescription",7]],"a":{"a":{"d":true,"m":"NIO no longer uses FailureDescription."}}},{"p":["CloseMode"],"f":[["enum",12],[" ",17],["CloseMode",7]],"s":[["enum",12],[" ",17],["CloseMode",7]],"d":"Specify what kind of close operation is requested."},{"p":["ByteBuffer"],"f":[["struct",12],[" ",17],["ByteBuffer",7]],"s":[["struct",12],[" ",17],["ByteBuffer",7]],"d":"`ByteBuffer` stores contiguously allocated raw bytes. It is a random and sequential accessible sequence of zero or\nmore bytes (octets).\n\n### Allocation\nUse `allocator.buffer(capacity: desiredCapacity)` to allocate a new `ByteBuffer`.\n\n### Supported types\nA variety of types can be read/written from/to a `ByteBuffer`. Using Swift's `extension` mechanism you can easily\ncreate `ByteBuffer` support for your own data types. Out of the box, `ByteBuffer` supports for example the following\ntypes (non-exhaustive list):\n\n - `String`/`StaticString`\n - Swift's various (unsigned) integer types\n - `Foundation`'s `Data`\n - `[UInt8]` and generally any `Collection` of `UInt8`\n\n### Random Access\nFor every supported type `ByteBuffer` usually contains two methods for random access:\n\n 1. `get<Type>(at: Int, length: Int)` where `<type>` is for example `String`, `Data`, `Bytes` (for `[UInt8]`)\n 2. `set<Type>(at: Int)`\n\nExample:\n\n    var buf = ...\n    buf.setString(\"Hello World\", at: 0)\n    buf.moveWriterIndex(to: 11)\n    let helloWorld = buf.getString(at: 0, length: 11)\n\n    let written = buf.setInteger(17 as Int, at: 11)\n    buf.moveWriterIndex(forwardBy: written)\n    let seventeen: Int? = buf.getInteger(at: 11)\n\nIf needed, `ByteBuffer` will automatically resize its storage to accommodate your `set` request.\n\n### Sequential Access\n`ByteBuffer` provides two properties which are indices into the `ByteBuffer` to support sequential access:\n - `readerIndex`, the index of the next readable byte\n - `writerIndex`, the index of the next byte to write\n\nFor every supported type `ByteBuffer` usually contains two methods for sequential access:\n\n 1. `read<Type>(length: Int)` to read `length` bytes from the current `readerIndex` (and then advance the reader\n    index by `length` bytes)\n 2. `write<Type>(Type)` to write, advancing the `writerIndex` by the appropriate amount\n\nExample:\n\n     var buf = ...\n     buf.writeString(\"Hello World\")\n     buf.writeInteger(17 as Int)\n     let helloWorld = buf.readString(length: 11)\n     let seventeen: Int = buf.readInteger()\n\n### Layout\n    +-------------------+------------------+------------------+\n    | discardable bytes |  readable bytes  |  writable bytes  |\n    |                   |     (CONTENT)    |                  |\n    +-------------------+------------------+------------------+\n    |                   |                  |                  |\n    0      <=      readerIndex   <=   writerIndex    <=    capacity\n\nThe 'discardable bytes' are usually bytes that have already been read, they can however still be accessed using\nthe random access methods. 'Readable bytes' are the bytes currently available to be read using the sequential\naccess interface (`read<Type>`/`write<Type>`). Getting `writableBytes` (bytes beyond the writer index) is undefined\nbehaviour and might yield arbitrary bytes (_not_ `0` initialised).\n\n### Slicing\n`ByteBuffer` supports slicing a `ByteBuffer` without copying the underlying storage.\n\nExample:\n\n    var buf = ...\n    let dataBytes: [UInt8] = [0xca, 0xfe, 0xba, 0xbe]\n    let dataBytesLength = UInt32(dataBytes.count)\n    buf.writeInteger(dataBytesLength) /* the header */\n    buf.writeBytes(dataBytes) /* the data */\n    let bufDataBytesOnly = buf.getSlice(at: 4, length: dataBytes.count)\n    /* `bufDataByteOnly` and `buf` will share their storage */\n\n### Notes\nAll `ByteBuffer` methods that don't contain the word 'unsafe' will only allow you to access the 'readable bytes'.\n"},{"p":["ByteBuffer","CopyBytesError"],"f":[["struct",12],[" ",17],["CopyBytesError",7]],"s":[["struct",12],[" ",17],["CopyBytesError",7]],"d":"Errors thrown when calling `copyBytes`."},{"p":["ByteBuffer","LengthPrefixError"],"f":[["struct",12],[" ",17],["LengthPrefixError",7]],"s":[["struct",12],[" ",17],["LengthPrefixError",7]]},{"p":["FileRegion"],"f":[["struct",12],[" ",17],["FileRegion",7]],"s":[["struct",12],[" ",17],["FileRegion",7]],"d":"A `FileRegion` represent a readable portion usually created to be sent over the network.\n\nUsually a `FileRegion` will allow the underlying transport to use `sendfile` to transfer its content and so allows transferring\nthe file content without copying it into user-space at all. If the actual transport implementation really can make use of sendfile\nor if it will need to copy the content to user-space first and use `write` / `writev` is an implementation detail. That said\n using `FileRegion` is the recommended way to transfer file content if possible.\n\nOne important note, depending your `ChannelPipeline` setup it may not be possible to use a `FileRegion` as a `ChannelHandler` may\nneed access to the bytes (in a `ByteBuffer`) to transform these.\n\n- note: It is important to manually manage the lifetime of the `NIOFileHandle` used to create a `FileRegion`."},{"p":["TimeAmount"],"f":[["struct",12],[" ",17],["TimeAmount",7]],"s":[["struct",12],[" ",17],["TimeAmount",7]],"d":"Represents a time _interval_.\n\n- note: `TimeAmount` should not be used to represent a point in time."},{"p":["NIODeadline"],"f":[["struct",12],[" ",17],["NIODeadline",7]],"s":[["struct",12],[" ",17],["NIODeadline",7]],"d":"Represents a point in time.\n\nStores the time in nanoseconds as returned by `DispatchTime.now().uptimeNanoseconds`\n\n`NIODeadline` allow chaining multiple tasks with the same deadline without needing to\ncompute new timeouts for each step\n\n```\nfunc doSomething(deadline: NIODeadline) -> EventLoopFuture<Void> {\n    return step1(deadline: deadline).flatMap {\n        step2(deadline: deadline)\n    }\n}\ndoSomething(deadline: .now() + .seconds(5))\n```\n\n- note: `NIODeadline` should not be used to represent a time interval"},{"p":["NIOBSDSocket","OptionLevel"],"f":[["struct",12],[" ",17],["OptionLevel",7]],"s":[["struct",12],[" ",17],["OptionLevel",7]],"d":"Defines socket option levels."},{"p":["NIOBSDSocket","AddressFamily"],"f":[["struct",12],[" ",17],["AddressFamily",7]],"s":[["struct",12],[" ",17],["AddressFamily",7]],"d":"Specifies the addressing scheme that the socket can use."},{"p":["NIOBSDSocket","ProtocolFamily"],"f":[["struct",12],[" ",17],["ProtocolFamily",7]],"s":[["struct",12],[" ",17],["ProtocolFamily",7]],"d":"Specifies the type of protocol that the socket can use."},{"p":["NIOBSDSocket","Option"],"f":[["struct",12],[" ",17],["Option",7]],"s":[["struct",12],[" ",17],["Option",7]],"d":"Defines configuration option names."},{"p":["NIOFileHandle","Mode"],"f":[["struct",12],[" ",17],["Mode",7]],"s":[["struct",12],[" ",17],["Mode",7]],"d":"`Mode` represents file access modes."},{"p":["NIOFileHandle","Flags"],"f":[["struct",12],[" ",17],["Flags",7]],"s":[["struct",12],[" ",17],["Flags",7]],"d":"`Flags` allows to specify additional flags to `Mode`, such as permission for file creation."},{"p":["NIOPacketInfo"],"f":[["struct",12],[" ",17],["NIOPacketInfo",7]],"s":[["struct",12],[" ",17],["NIOPacketInfo",7]]},{"p":["SocketAddress","IPv4Address"],"f":[["struct",12],[" ",17],["IPv4Address",7]],"s":[["struct",12],[" ",17],["IPv4Address",7]],"d":"A single IPv4 address for `SocketAddress`."},{"p":["SocketAddress","IPv6Address"],"f":[["struct",12],[" ",17],["IPv6Address",7]],"s":[["struct",12],[" ",17],["IPv6Address",7]],"d":"A single IPv6 address for `SocketAddress`."},{"p":["SocketAddress","UnixSocketAddress"],"f":[["struct",12],[" ",17],["UnixSocketAddress",7]],"s":[["struct",12],[" ",17],["UnixSocketAddress",7]],"d":"A single Unix socket address for `SocketAddress`."},{"p":["ByteBufferView"],"f":[["struct",12],[" ",17],["ByteBufferView",7]],"s":[["struct",12],[" ",17],["ByteBufferView",7]],"d":"A view into a portion of a `ByteBuffer`.\n\nA `ByteBufferView` is useful whenever a `Collection where Element == UInt8` representing a portion of a\n`ByteBuffer` is needed."},{"p":["ChannelOptions"],"f":[["struct",12],[" ",17],["ChannelOptions",7]],"s":[["struct",12],[" ",17],["ChannelOptions",7]],"d":"Provides `ChannelOption`s to be used with a `Channel`, `Bootstrap` or `ServerBootstrap`."},{"p":["ChannelOptions","TCPConvenienceOptions"],"f":[["struct",12],[" ",17],["TCPConvenienceOptions",7]],"s":[["struct",12],[" ",17],["TCPConvenienceOptions",7]],"d":"A set of `TCPConvenienceOption`s"},{"p":["ChannelOptions","TCPConvenienceOption"],"f":[["struct",12],[" ",17],["TCPConvenienceOption",7]],"s":[["struct",12],[" ",17],["TCPConvenienceOption",7]],"d":"A TCP channel option which can be applied to a bootstrap using convenience notation."},{"p":["ChannelOptions","Types","SocketOption"],"f":[["struct",12],[" ",17],["SocketOption",7]],"s":[["struct",12],[" ",17],["SocketOption",7]],"d":"`SocketOption` allows users to specify configuration settings that are directly applied to the underlying socket file descriptor.\n\nValid options are typically found in the various man pages like `man 4 tcp`."},{"p":["ChannelOptions","Types","BacklogOption"],"f":[["struct",12],[" ",17],["BacklogOption",7]],"s":[["struct",12],[" ",17],["BacklogOption",7]],"d":"`BacklogOption` allows users to configure the `backlog` value as specified in `man 2 listen`. This is only useful for `ServerSocketChannel`s."},{"p":["ChannelOptions","Types","AutoReadOption"],"f":[["struct",12],[" ",17],["AutoReadOption",7]],"s":[["struct",12],[" ",17],["AutoReadOption",7]],"d":"`AutoReadOption` allows users to configure if a `Channel` should automatically call `Channel.read` again once all data was read from the transport or\nif the user is responsible to call `Channel.read` manually."},{"p":["ChannelOptions","Types","AllocatorOption"],"f":[["struct",12],[" ",17],["AllocatorOption",7]],"s":[["struct",12],[" ",17],["AllocatorOption",7]],"d":"`AllocatorOption` allows to specify the `ByteBufferAllocator` to use."},{"p":["ChannelOptions","Types","WriteSpinOption"],"f":[["struct",12],[" ",17],["WriteSpinOption",7]],"s":[["struct",12],[" ",17],["WriteSpinOption",7]],"d":"`WriteSpinOption` allows users to configure the number of repetitions of a only partially successful write call before considering the `Channel` not writable.\nSetting this option to `0` means that we only issue one write call and if that call does not write all the bytes,\nwe consider the `Channel` not writable."},{"p":["ChannelOptions","Types","ReceivePacketInfo"],"f":[["struct",12],[" ",17],["ReceivePacketInfo",7]],"s":[["struct",12],[" ",17],["ReceivePacketInfo",7]],"d":"When set to true IP level Packet Info information will be reported through `AddressedEnvelope.Metadata` for UDP packets."},{"p":["ChannelOptions","Types","RecvAllocatorOption"],"f":[["struct",12],[" ",17],["RecvAllocatorOption",7]],"s":[["struct",12],[" ",17],["RecvAllocatorOption",7]],"d":"`RecvAllocatorOption` allows users to specify the `RecvByteBufferAllocator` to use."},{"p":["ChannelOptions","Types","ConnectTimeoutOption"],"f":[["struct",12],[" ",17],["ConnectTimeoutOption",7]],"s":[["struct",12],[" ",17],["ConnectTimeoutOption",7]],"d":"`ConnectTimeoutOption` allows users to configure the `TimeAmount` after which a connect will fail if it was not established in the meantime. May be\n`nil`, in which case the connection attempt will never time out."},{"p":["ChannelOptions","Types","WriteBufferWaterMark"],"f":[["struct",12],[" ",17],["WriteBufferWaterMark",7]],"s":[["struct",12],[" ",17],["WriteBufferWaterMark",7]],"d":"The watermark used to detect when `Channel.isWritable` returns `true` or `false`."},{"p":["ChannelOptions","Types","MaxMessagesPerReadOption"],"f":[["struct",12],[" ",17],["MaxMessagesPerReadOption",7]],"s":[["struct",12],[" ",17],["MaxMessagesPerReadOption",7]],"d":"`MaxMessagesPerReadOption` allows users to configure the maximum number of read calls to the underlying transport are performed before wait again until\nthere is more to read and be notified."},{"p":["ChannelOptions","Types","WriteBufferWaterMarkOption"],"f":[["struct",12],[" ",17],["WriteBufferWaterMarkOption",7]],"s":[["struct",12],[" ",17],["WriteBufferWaterMarkOption",7]],"d":"`WriteBufferWaterMarkOption` allows users to configure when a `Channel` should be marked as writable or not. Once the amount of bytes queued in a\n`Channel`s outbound buffer is larger than `WriteBufferWaterMark.high` the channel will be marked as non-writable and so\n`Channel.isWritable` will return `false`. Once we were able to write some data out of the outbound buffer and the amount of bytes queued\nfalls below `WriteBufferWaterMark.low` the `Channel` will become writable again. Once this happens `Channel.writable` will return\n`true` again. These writability changes are also propagated through the `ChannelPipeline` and so can be intercepted via `ChannelInboundHandler.channelWritabilityChanged`."},{"p":["ChannelOptions","Types","AllowRemoteHalfClosureOption"],"f":[["struct",12],[" ",17],["AllowRemoteHalfClosureOption",7]],"s":[["struct",12],[" ",17],["AllowRemoteHalfClosureOption",7]],"d":"`AllowRemoteHalfClosureOption` allows users to configure whether the `Channel` will close itself when its remote\npeer shuts down its send stream, or whether it will remain open. If set to `false` (the default), the `Channel`\nwill be closed automatically if the remote peer shuts down its send stream. If set to true, the `Channel` will\nnot be closed: instead, a `ChannelEvent.inboundClosed` user event will be sent on the `ChannelPipeline`,\nand no more data will be received."},{"p":["ChannelOptions","Types","DatagramVectorReadMessageCountOption"],"f":[["struct",12],[" ",17],["DatagramVectorReadMessageCountOption",7]],"s":[["struct",12],[" ",17],["DatagramVectorReadMessageCountOption",7]],"d":"`DatagramVectorReadMessageCountOption` allows users to configure the number of messages to attempt to read in a single syscall on a\ndatagram `Channel`.\n\nSome datagram `Channel`s have extremely high datagram throughput. This can occur when the single datagram socket is encapsulating\nmany logical \"connections\" (e.g. with QUIC) or when the datagram socket is simply serving an enormous number of consumers (e.g.\nwith a public-facing DNS server). In this case the overhead of one syscall per datagram is profoundly limiting. Using this\n`ChannelOption` allows the `Channel` to read multiple datagrams at once.\n\nNote that simply increasing this number will not necessarily bring performance gains and may in fact cause data loss. Any increase\nto this should be matched by increasing the size of the buffers allocated by the `Channel` `RecvByteBufferAllocator` (as set by\n`ChannelOption.recvAllocator`) proportionally. For example, to receive 10 messages at a time, set the size of the buffers allocated\nby the `RecvByteBufferAllocator` to at least 10x the size of the maximum datagram size you wish to receive.\n\nNaturally, this option is only valid on datagram channels.\n\nThis option only works on the following platforms:\n\n- Linux\n- FreeBSD\n- Android\n\nOn all other platforms, setting it has no effect.\n\nSet this option to 0 to disable vector reads and to use serial reads instead."},{"p":["ChannelOptions","Types","ExplicitCongestionNotificationsOption"],"f":[["struct",12],[" ",17],["ExplicitCongestionNotificationsOption",7]],"s":[["struct",12],[" ",17],["ExplicitCongestionNotificationsOption",7]],"d":"When set to true IP level ECN information will be reported through `AddressedEnvelope.Metadata`"},{"p":["ChannelOptions","Storage"],"f":[["struct",12],[" ",17],["Storage",7]],"s":[["struct",12],[" ",17],["Storage",7]],"d":"A type-safe storage facility for `ChannelOption`s. You will only ever need this if you implement your own\n`Channel` that needs to store `ChannelOption`s."},{"p":["CircularBuffer"],"f":[["struct",12],[" ",17],["CircularBuffer",7],["<",17],["Element",0],[">",17]],"s":[["struct",12],[" ",17],["CircularBuffer",7]],"g":[["Element",0,0]],"d":"An automatically expanding ring buffer implementation backed by a `ContiguousArray`. Even though this implementation\nwill automatically expand if more elements than `initialCapacity` are stored, it's advantageous to prevent\nexpansions from happening frequently. Expansions will always force an allocation and a copy to happen."},{"p":["CircularBuffer","Index"],"f":[["struct",12],[" ",17],["Index",7]],"s":[["struct",12],[" ",17],["Index",7]],"g":[["Element",0,0]],"d":"An opaque `CircularBuffer` index.\n\nYou may get indices offset from other indices by using `CircularBuffer.index(:offsetBy:)`,\n`CircularBuffer.index(before:)`, or `CircularBuffer.index(after:)`.\n\n- note: Every index is invalidated as soon as you perform a length-changing operating on the `CircularBuffer`\n        but remains valid when you replace one item by another using the subscript."},{"p":["ChannelPipeline","SynchronousOperations"],"f":[["struct",12],[" ",17],["SynchronousOperations",7]],"s":[["struct",12],[" ",17],["SynchronousOperations",7]],"d":"A view of a `ChannelPipeline` which may be used to invoke synchronous operations.\n\nAll functions **must** be called from the pipeline's event loop."},{"p":["EventLoopPromise"],"f":[["struct",12],[" ",17],["EventLoopPromise",7],["<",17],["Value",0],[">",17]],"s":[["struct",12],[" ",17],["EventLoopPromise",7]],"g":[["Value",0,0]],"d":"A promise to provide a result later.\n\nThis is the provider API for `EventLoopFuture<Value>`. If you want to return an\nunfulfilled `EventLoopFuture<Value>` -- presumably because you are interfacing to\nsome asynchronous service that will return a real result later, follow this\npattern:\n\n```\nfunc someAsyncOperation(args) -> EventLoopFuture<ResultType> {\n    let promise = eventLoop.makePromise(of: ResultType.self)\n    someAsyncOperationWithACallback(args) { result -> Void in\n        // when finished...\n        promise.succeed(result)\n        // if error...\n        promise.fail(error)\n    }\n    return promise.futureResult\n}\n```\n\nNote that the future result is returned before the async process has provided a value.\n\nIt's actually not very common to use this directly. Usually, you really want one\nof the following:\n\n* If you have an `EventLoopFuture` and want to do something else after it completes,\n    use `.flatMap()`\n* If you already have a value and need an `EventLoopFuture<>` object to plug into\n    some other API, create an already-resolved object with `eventLoop.makeSucceededFuture(result)`\n    or `eventLoop.newFailedFuture(error:)`.\n\n- note: `EventLoopPromise` has reference semantics."},{"p":["NIOInsecureNoTLS"],"f":[["struct",12],[" ",17],["NIOInsecureNoTLS",7],["<",17],["Bootstrap",0],["> ",17],["where",12],[" ",17],["Bootstrap",18],[" : ",17],["NIOClientTCPBootstrapProtocol",18,24]],"s":[["struct",12],[" ",17],["NIOInsecureNoTLS",7]],"c":[["Bootstrap",1,"NIOClientTCPBootstrapProtocol",24]],"g":[["Bootstrap",0,0]]},{"p":["NIONetworkDevice"],"f":[["struct",12],[" ",17],["NIONetworkDevice",7]],"s":[["struct",12],[" ",17],["NIONetworkDevice",7]],"d":"A representation of a single network device on a system."},{"p":["AddressedEnvelope"],"f":[["struct",12],[" ",17],["AddressedEnvelope",7],["<",17],["DataType",0],[">",17]],"s":[["struct",12],[" ",17],["AddressedEnvelope",7]],"g":[["DataType",0,0]],"d":"A data structure for processing addressed datagrams, such as those used by UDP.\n\nThe AddressedEnvelope is used extensively on `DatagramChannel`s in order to keep track\nof source or destination address metadata: that is, where some data came from or where\nit is going."},{"p":["AddressedEnvelope","Metadata"],"f":[["struct",12],[" ",17],["Metadata",7]],"s":[["struct",12],[" ",17],["Metadata",7]],"g":[["DataType",0,0]],"d":"Any metadata associated with an `AddressedEnvelope`"},{"p":["EventLoopIterator"],"f":[["struct",12],[" ",17],["EventLoopIterator",7]],"s":[["struct",12],[" ",17],["EventLoopIterator",7]],"d":"An iterator over the `EventLoop`s forming an `EventLoopGroup`.\n\nUsually returned by an `EventLoopGroup`'s `makeIterator()` method.\n\n    let group = MultiThreadedEventLoopGroup(numberOfThreads: 1)\n    group.makeIterator().forEach { loop in\n        // Do something with each loop\n    }\n"},{"p":["SocketAddressError","FailedToParseIPByteBuffer"],"f":[["struct",12],[" ",17],["FailedToParseIPByteBuffer",7]],"s":[["struct",12],[" ",17],["FailedToParseIPByteBuffer",7]],"d":"Unable to parse a given IP ByteBuffer"},{"p":["ByteBufferAllocator"],"f":[["struct",12],[" ",17],["ByteBufferAllocator",7]],"s":[["struct",12],[" ",17],["ByteBufferAllocator",7]],"d":"The preferred allocator for `ByteBuffer` values. The allocation strategy is opaque but is currently libc's\n`malloc`, `realloc` and `free`.\n\n- note: `ByteBufferAllocator` is thread-safe."},{"p":["MarkedCircularBuffer"],"f":[["struct",12],[" ",17],["MarkedCircularBuffer",7],["<",17],["Element",0],[">",17]],"s":[["struct",12],[" ",17],["MarkedCircularBuffer",7]],"g":[["Element",0,0]],"d":"A circular buffer that allows one object at a time to be \"marked\" and easily identified and retrieved later.\n\nThis object is used extensively within SwiftNIO to handle flushable buffers. It can be used to store buffered\nwrites and mark how far through the buffer the user has flushed, and therefore how far through the buffer is\nsafe to write."},{"p":["NIOTooManyBytesError"],"f":[["struct",12],[" ",17],["NIOTooManyBytesError",7]],"s":[["struct",12],[" ",17],["NIOTooManyBytesError",7]]},{"p":["ChannelHandlerContext","RemovalToken"],"f":[["struct",12],[" ",17],["RemovalToken",7]],"s":[["struct",12],[" ",17],["RemovalToken",7]],"d":"A `RemovalToken` is handed to a `RemovableChannelHandler` when its `removeHandler` function is invoked. A\n`RemovableChannelHandler` is then required to remove itself from the `ChannelPipeline`. The removal process\nis finalized by handing the `RemovalToken` to the `ChannelHandlerContext.leavePipeline` function."},{"p":["NIOClientTCPBootstrap"],"f":[["struct",12],[" ",17],["NIOClientTCPBootstrap",7]],"s":[["struct",12],[" ",17],["NIOClientTCPBootstrap",7]],"d":"`NIOClientTCPBootstrap` is a bootstrap that allows you to bootstrap client TCP connections using NIO on BSD Sockets,\nNIO Transport Services, or other ways.\n\nUsually, to bootstrap a connection with SwiftNIO, you have to match the right `EventLoopGroup`, the right bootstrap,\nand the right TLS implementation. Typical choices involve:\n - `MultiThreadedEventLoopGroup`, `ClientBootstrap`, and `NIOSSLClientHandler` (from\n   [`swift-nio-ssl`](https://github.com/apple/swift-nio-ssl)) for NIO on BSD sockets.\n - `NIOTSEventLoopGroup`, `NIOTSConnectionBootstrap`, and the Network.framework TLS implementation (all from\n   [`swift-nio-transport-services`](https://github.com/apple/swift-nio-transport-services).\n\nBootstrapping connections that way works but is quite tedious for packages that support multiple ways of\nbootstrapping. The idea behind `NIOClientTCPBootstrap` is to do all configuration in one place (when you initialize\na `NIOClientTCPBootstrap`) and then have a common API that works for all use-cases.\n\nExample:\n\n    // This function combines the right pieces and returns you a \"universal client bootstrap\"\n    // (`NIOClientTCPBootstrap`). This allows you to bootstrap connections (with or without TLS) using either the\n    // NIO on sockets (`NIO`) or NIO on Network.framework (`NIOTransportServices`) stacks.\n    // The remainder of the code should be platform-independent.\n    func makeUniversalBootstrap(serverHostname: String) throws -> (NIOClientTCPBootstrap, EventLoopGroup) {\n        func useNIOOnSockets() throws -> (NIOClientTCPBootstrap, EventLoopGroup) {\n            let group = MultiThreadedEventLoopGroup(numberOfThreads: 1)\n            let sslContext = try NIOSSLContext(configuration: TLSConfiguration.forClient())\n            let bootstrap = try NIOClientTCPBootstrap(ClientBootstrap(group: group),\n                                                      tls: NIOSSLClientTLSProvider(context: sslContext,\n                                                                                   serverHostname: serverHostname))\n            return (bootstrap, group)\n        }\n\n        #if canImport(Network)\n        if #available(macOS 10.14, iOS 12, tvOS 12, watchOS 3, *) {\n            // We run on a new-enough Darwin so we can use Network.framework\n\n            let group = NIOTSEventLoopGroup()\n            let bootstrap = NIOClientTCPBootstrap(NIOTSConnectionBootstrap(group: group),\n                                                  tls: NIOTSClientTLSProvider())\n            return (bootstrap, group)\n        } else {\n            // We're on Darwin but not new enough for Network.framework, so we fall back on NIO on BSD sockets.\n            return try useNIOOnSockets()\n        }\n        #else\n        // We are on a non-Darwin platform, so we'll use BSD sockets.\n        return try useNIOOnSockets()\n        #endif\n    }\n\n    let (bootstrap, group) = try makeUniversalBootstrap(serverHostname: \"example.com\")\n    let connection = try bootstrap\n            .channelInitializer { channel in\n                channel.pipeline.addHandler(PrintEverythingHandler { _ in })\n            }\n            .enableTLS()\n            .connect(host: \"example.com\", port: 443)\n            .wait()"},{"p":["ByteToMessageDecoderError","PayloadTooLargeError"],"f":[["struct",12],[" ",17],["PayloadTooLargeError",7]],"s":[["struct",12],[" ",17],["PayloadTooLargeError",7]],"d":"This error can be thrown by `ByteToMessageDecoder`s if the incoming payload is larger than the max specified."},{"p":["ChannelShouldQuiesceEvent"],"f":[["struct",12],[" ",17],["ChannelShouldQuiesceEvent",7]],"s":[["struct",12],[" ",17],["ChannelShouldQuiesceEvent",7]],"d":"A `Channel` user event that is sent when the `Channel` has been asked to quiesce.\n\nThe action(s) that should be taken after receiving this event are both application and protocol dependent. If the\nprotocol supports a notion of requests and responses, it might make sense to stop accepting new requests but finish\nprocessing the request currently in flight."},{"p":["NIOMulticastNotSupportedError"],"f":[["struct",12],[" ",17],["NIOMulticastNotSupportedError",7]],"s":[["struct",12],[" ",17],["NIOMulticastNotSupportedError",7]],"d":"Multicast is not supported on this interface."},{"p":["AdaptiveRecvByteBufferAllocator"],"f":[["struct",12],[" ",17],["AdaptiveRecvByteBufferAllocator",7]],"s":[["struct",12],[" ",17],["AdaptiveRecvByteBufferAllocator",7]],"d":"`RecvByteBufferAllocator` which will gracefully increment or decrement the buffer size on the feedback that was recorded."},{"p":["NIOMulticastNotImplementedError"],"f":[["struct",12],[" ",17],["NIOMulticastNotImplementedError",7]],"s":[["struct",12],[" ",17],["NIOMulticastNotImplementedError",7]],"d":"Multicast has not been properly implemented on this channel."},{"p":["FixedSizeRecvByteBufferAllocator"],"f":[["struct",12],[" ",17],["FixedSizeRecvByteBufferAllocator",7]],"s":[["struct",12],[" ",17],["FixedSizeRecvByteBufferAllocator",7]],"d":"`RecvByteBufferAllocator` which will always return a `ByteBuffer` with the same fixed size no matter what was recorded."},{"p":["NIOAttemptedToRemoveHandlerMultipleTimesError"],"f":[["struct",12],[" ",17],["NIOAttemptedToRemoveHandlerMultipleTimesError",7]],"s":[["struct",12],[" ",17],["NIOAttemptedToRemoveHandlerMultipleTimesError",7]],"d":"The removal of a `ChannelHandler` using `ChannelPipeline.removeHandler` has been attempted more than once."},{"p":["NIOAny"],"f":[["struct",12],[" ",17],["NIOAny",7]],"s":[["struct",12],[" ",17],["NIOAny",7]],"d":"`NIOAny` is an opaque container for values of *any* type, similar to Swift's builtin `Any` type. Contrary to\n`Any` the overhead of `NIOAny` depends on the the type of the wrapped value. Certain types that are important\nfor the performance of a SwiftNIO application like `ByteBuffer`, `FileRegion` and `AddressEnvelope<ByteBuffer>` can be expected\nto be wrapped almost without overhead. All others will have similar performance as if they were passed as an `Any` as\n`NIOAny` just like `Any` will contain them within an existential container.\n\nThe most important use-cases for `NIOAny` are values travelling through the `ChannelPipeline` whose type can't\nbe calculated at compile time. For example:\n\n - the `channelRead` of any `ChannelInboundHandler`\n - the `write` method of a `ChannelOutboundHandler`\n\nThe abstraction that delivers a `NIOAny` to user code must provide a mechanism to unwrap a `NIOAny` as a\ncertain type known at run-time. Canonical example:\n\n    class SandwichHandler: ChannelInboundHandler {\n        typealias InboundIn = Bacon /* we expected to be delivered `Bacon` ... */\n        typealias InboundOut = Sandwich /* ... and we will make and deliver a `Sandwich` from that */\n\n        func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n             /* we receive the `Bacon` as a `NIOAny` as at compile-time the exact configuration of the channel\n                pipeline can't be computed. The pipeline can't be computed at compile time as it can change\n                dynamically at run-time. Yet, we assert that in any configuration the channel handler before\n                `SandwichHandler` does actually send us a stream of `Bacon`.\n             */\n             let bacon = self.unwrapInboundIn(data) /* `Bacon` or crash */\n             let sandwich = makeSandwich(bacon)\n             context.fireChannelRead(self.wrapInboundOut(sandwich)) /* as promised we deliver a wrapped `Sandwich` */\n        }\n    }"},{"p":["IOError"],"f":[["struct",12],[" ",17],["IOError",7]],"s":[["struct",12],[" ",17],["IOError",7]],"d":"An `Error` for an IO operation."},{"p":["Scheduled"],"f":[["struct",12],[" ",17],["Scheduled",7],["<",17],["T",0],[">",17]],"s":[["struct",12],[" ",17],["Scheduled",7]],"g":[["T",0,0]],"d":"Returned once a task was scheduled on the `EventLoop` for later execution.\n\nA `Scheduled` allows the user to either `cancel()` the execution of the scheduled task (if possible) or obtain a reference to the `EventLoopFuture` that\nwill be notified once the execution is complete."},{"p":["RepeatedTask"],"f":[["final",12],[" ",17],["class",12],[" ",17],["RepeatedTask",7]],"s":[["class",12],[" ",17],["RepeatedTask",7]],"d":"Returned once a task was scheduled to be repeatedly executed on the `EventLoop`.\n\nA `RepeatedTask` allows the user to `cancel()` the repeated scheduling of further tasks."},{"p":["NIOFileHandle"],"f":[["final",12],[" ",17],["class",12],[" ",17],["NIOFileHandle",7]],"s":[["class",12],[" ",17],["NIOFileHandle",7]],"d":"A `NIOFileHandle` is a handle to an open file.\n\nWhen creating a `NIOFileHandle` it takes ownership of the underlying file descriptor. When a `NIOFileHandle` is no longer\nneeded you must `close` it or take back ownership of the file descriptor using `takeDescriptorOwnership`.\n\n- note: One underlying file descriptor should usually be managed by one `NIOFileHandle` only.\n\n- warning: Failing to manage the lifetime of a `NIOFileHandle` correctly will result in undefined behaviour.\n\n- warning: `NIOFileHandle` objects are not thread-safe and are mutable. They also cannot be fully thread-safe as they refer to a global underlying file descriptor."},{"p":["ChannelPipeline"],"f":[["final",12],[" ",17],["class",12],[" ",17],["ChannelPipeline",7]],"s":[["class",12],[" ",17],["ChannelPipeline",7]],"d":"A list of `ChannelHandler`s that handle or intercept inbound events and outbound operations of a\n`Channel`. `ChannelPipeline` implements an advanced form of the Intercepting Filter pattern\nto give a user full control over how an event is handled and how the `ChannelHandler`s in a pipeline\ninteract with each other.\n\n# Creation of a pipeline\n\nEach `Channel` has its own `ChannelPipeline` and it is created automatically when a new `Channel` is created.\n\n# How an event flows in a pipeline\n\nThe following diagram describes how I/O events are typically processed by `ChannelHandler`s in a `ChannelPipeline`.\nAn I/O event is handled by either a `ChannelInboundHandler` or a `ChannelOutboundHandler`\nand is forwarded to the next handler in the `ChannelPipeline` by calling the event propagation methods defined in\n`ChannelHandlerContext`, such as `ChannelHandlerContext.fireChannelRead` and\n`ChannelHandlerContext.write`.\n\n```\n                                                   I/O Request\n                                                   via `Channel` or\n                                                   `ChannelHandlerContext`\n                                                     |\n +---------------------------------------------------+---------------+\n |                           ChannelPipeline         |               |\n |                                TAIL              \\|/              |\n |    +---------------------+            +-----------+----------+    |\n |    | Inbound Handler  N  |            | Outbound Handler  1  |    |\n |    +----------+----------+            +-----------+----------+    |\n |              /|\\                                  |               |\n |               |                                  \\|/              |\n |    +----------+----------+            +-----------+----------+    |\n |    | Inbound Handler N-1 |            | Outbound Handler  2  |    |\n |    +----------+----------+            +-----------+----------+    |\n |              /|\\                                  .               |\n |               .                                   .               |\n | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|\n |        [ method call]                       [method call]         |\n |               .                                   .               |\n |               .                                  \\|/              |\n |    +----------+----------+            +-----------+----------+    |\n |    | Inbound Handler  2  |            | Outbound Handler M-1 |    |\n |    +----------+----------+            +-----------+----------+    |\n |              /|\\                                  |               |\n |               |                                  \\|/              |\n |    +----------+----------+            +-----------+----------+    |\n |    | Inbound Handler  1  |            | Outbound Handler  M  |    |\n |    +----------+----------+            +-----------+----------+    |\n |              /|\\             HEAD                 |               |\n +---------------+-----------------------------------+---------------+\n                 |                                  \\|/\n +---------------+-----------------------------------+---------------+\n |               |                                   |               |\n |       [ Socket.read ]                    [ Socket.write ]         |\n |                                                                   |\n |  SwiftNIO Internal I/O Threads (Transport Implementation)         |\n +-------------------------------------------------------------------+\n```\n\nAn inbound event is handled by the inbound handlers in the head-to-tail direction as shown on the left side of the\ndiagram. An inbound handler usually handles the inbound data generated by the I/O thread on the bottom of the\ndiagram. The inbound data is often read from a remote peer via the actual input operation such as\n`Socket.read`. If an inbound event goes beyond the tail inbound handler, it is discarded\nsilently, or logged if it needs your attention.\n\nAn outbound event is handled by the outbound handlers in the tail-to-head direction as shown on the right side of the\ndiagram. An outbound handler usually generates or transforms the outbound traffic such as write requests.\nIf an outbound event goes beyond the head outbound handler, it is handled by an I/O thread associated with the\n`Channel`. The I/O thread often performs the actual output operation such as `Socket.write`.\n\n\nFor example, let us assume that we created the following pipeline:\n\n```\nChannelPipeline p = ...\nlet future = p.add(name: \"1\", handler: InboundHandlerA()).flatMap {\n  p.add(name: \"2\", handler: InboundHandlerB())\n}.flatMap {\n  p.add(name: \"3\", handler: OutboundHandlerA())\n}.flatMap {\n  p.add(name: \"4\", handler: OutboundHandlerB())\n}.flatMap {\n  p.add(name: \"5\", handler: InboundOutboundHandlerX())\n}\n// Handle the future as well ....\n```\n\nIn the example above, a class whose name starts with `Inbound` is an inbound handler.\nA class whose name starts with `Outbound` is an outbound handler.\n\nIn the given example configuration, the handler evaluation order is 1, 2, 3, 4, 5 when an event goes inbound.\nWhen an event goes outbound, the order is 5, 4, 3, 2, 1.  On top of this principle, `ChannelPipeline` skips\nthe evaluation of certain handlers to shorten the stack depth:\n\n- 3 and 4 don't implement `ChannelInboundHandler`, and therefore the actual evaluation order of an inbound event will be: 1, 2, and 5.\n- 1 and 2 don't implement `ChannelOutboundHandler`, and therefore the actual evaluation order of a outbound event will be: 5, 4, and 3.\n- If 5 implements both `ChannelInboundHandler` and `ChannelOutboundHandler`, the evaluation order of an inbound and a outbound event could be 125 and 543 respectively.\n\nNote:   Handlers may choose not to propagate messages down the pipeline immediately.  For example a handler may need to wait\nfor additional data before sending a protocol event to the next handler in the pipeline.  Due to this you can't assume that later handlers\nin the pipeline will receive the same number of events as were sent, or that events of different types will arrive in the same order.\nFor example - a user event could overtake a data event if a handler is aggregating data events before propagating but immediately\npropagating user events.\n\n# Forwarding an event to the next handler\n\nAs you might noticed in the diagram above, a handler has to invoke the event propagation methods in\n`ChannelHandlerContext` to forward an event to its next handler.\nThose methods include:\n\n- Inbound event propagation methods defined in `ChannelInboundInvoker`\n- Outbound event propagation methods defined in `ChannelOutboundInvoker`.\n\n# Building a pipeline\n\nA user is supposed to have one or more `ChannelHandler`s in a `ChannelPipeline` to receive I/O events (e.g. read) and\nto request I/O operations (e.g. write and close).  For example, a typical server will have the following handlers\nin each channel's pipeline, but your mileage may vary depending on the complexity and characteristics of the\nprotocol and business logic:\n\n- Protocol Decoder - translates binary data (e.g. `ByteBuffer`) into a struct / class\n- Protocol Encoder - translates a struct / class into binary data (e.g. `ByteBuffer`)\n- Business Logic Handler - performs the actual business logic (e.g. database access)\n\n# Thread safety\n\nA `ChannelHandler` can be added or removed at any time because a `ChannelPipeline` is thread safe."},{"p":["EventLoopFuture"],"f":[["final",12],[" ",17],["class",12],[" ",17],["EventLoopFuture",7],["<",17],["Value",0],[">",17]],"s":[["class",12],[" ",17],["EventLoopFuture",7]],"g":[["Value",0,0]],"d":"Holder for a result that will be provided later.\n\nFunctions that promise to do work asynchronously can return an `EventLoopFuture<Value>`.\nThe recipient of such an object can then observe it to be notified when the operation completes.\n\nThe provider of a `EventLoopFuture<Value>` can create and return a placeholder object\nbefore the actual result is available. For example:\n\n```\nfunc getNetworkData(args) -> EventLoopFuture<NetworkResponse> {\n    let promise = eventLoop.makePromise(of: NetworkResponse.self)\n    queue.async {\n        . . . do some work . . .\n        promise.succeed(response)\n        . . . if it fails, instead . . .\n        promise.fail(error)\n    }\n    return promise.futureResult\n}\n```\n\nNote that this function returns immediately; the promise object will be given a value\nlater on. This behaviour is common to Future/Promise implementations in many programming\nlanguages. If you are unfamiliar with this kind of object, the following resources may be\nhelpful:\n\n- [Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)\n- [Scala](http://docs.scala-lang.org/overviews/core/futures.html)\n- [Python](https://docs.google.com/document/d/10WOZgLQaYNpOrag-eTbUm-JUCCfdyfravZ4qSOQPg1M/edit)\n\nIf you receive a `EventLoopFuture<Value>` from another function, you have a number of options:\nThe most common operation is to use `flatMap()` or `map()` to add a function that will be called\nwith the eventual result.  Both methods returns a new `EventLoopFuture<Value>` immediately\nthat will receive the return value from your function, but they behave differently. If you have\na function that can return synchronously, the `map` function will transform the result of type\n`Value` to a the new result of type `NewValue` and return an `EventLoopFuture<NewValue>`.\n\n```\nlet networkData = getNetworkData(args)\n\n// When network data is received, convert it.\nlet processedResult: EventLoopFuture<Processed> = networkData.map { (n: NetworkResponse) -> Processed in\n    ... parse network data ....\n    return processedResult\n}\n```\n\nIf however you need to do more asynchronous processing, you can call `flatMap()`. The return value of the\nfunction passed to `flatMap` must be a new `EventLoopFuture<NewValue>` object: the return value of `flatMap()` is\na new `EventLoopFuture<NewValue>` that will contain the eventual result of both the original operation and\nthe subsequent one.\n\n```\n// When converted network data is available, begin the database operation.\nlet databaseResult: EventLoopFuture<DBResult> = processedResult.flatMap { (p: Processed) -> EventLoopFuture<DBResult> in\n    return someDatabaseOperation(p)\n}\n```\n\nIn essence, future chains created via `flatMap()` provide a form of data-driven asynchronous programming\nthat allows you to dynamically declare data dependencies for your various operations.\n\n`EventLoopFuture` chains created via `flatMap()` are sufficient for most purposes. All of the registered\nfunctions will eventually run in order. If one of those functions throws an error, that error will\nbypass the remaining functions. You can use `flatMapError()` to handle and optionally recover from\nerrors in the middle of a chain.\n\nAt the end of an `EventLoopFuture` chain, you can use `whenSuccess()` or `whenFailure()` to add an\nobserver callback that will be invoked with the result or error at that point. (Note: If you ever\nfind yourself invoking `promise.succeed()` from inside a `whenSuccess()` callback, you probably should\nuse `flatMap()` or `cascade(to:)` instead.)\n\n`EventLoopFuture` objects are typically obtained by:\n* Using `.flatMap()` on an existing future to create a new future for the next step in a series of operations.\n* Initializing an `EventLoopFuture` that already has a value or an error\n\n### Threading and Futures\n\nOne of the major performance advantages of NIO over something like Node.js or Pythons asyncio is that NIO will\nby default run multiple event loops at once, on different threads. As most network protocols do not require\nblocking operation, at least in their low level implementations, this provides enormous speedups on machines\nwith many cores such as most modern servers.\n\nHowever, it can present a challenge at higher levels of abstraction when coordination between those threads\nbecomes necessary. This is usually the case whenever the events on one connection (that is, one `Channel`) depend\non events on another one. As these `Channel`s may be scheduled on different event loops (and so different threads)\ncare needs to be taken to ensure that communication between the two loops is done in a thread-safe manner that\navoids concurrent mutation of shared state from multiple loops at once.\n\nThe main primitives NIO provides for this use are the `EventLoopPromise` and `EventLoopFuture`. As their names\nsuggest, these two objects are aware of event loops, and so can help manage the safety and correctness of your\nprograms. However, understanding the exact semantics of these objects is critical to ensuring the safety of your code.\n\n####  Callbacks\n\nThe most important principle of the `EventLoopPromise` and `EventLoopFuture` is this: all callbacks registered on\nan `EventLoopFuture` will execute on the thread corresponding to the event loop that created the `Future`,\n*regardless* of what thread succeeds or fails the corresponding `EventLoopPromise`.\n\nThis means that if *your code* created the `EventLoopPromise`, you can be extremely confident of what thread the\ncallback will execute on: after all, you held the event loop in hand when you created the `EventLoopPromise`.\nHowever, if your code is handed an `EventLoopFuture` or `EventLoopPromise`, and you want to register callbacks\non those objects, you cannot be confident that those callbacks will execute on the same `EventLoop` that your\ncode does.\n\nThis presents a problem: how do you ensure thread-safety when registering callbacks on an arbitrary\n`EventLoopFuture`? The short answer is that when you are holding an `EventLoopFuture`, you can always obtain a\nnew `EventLoopFuture` whose callbacks will execute on your event loop. You do this by calling\n`EventLoopFuture.hop(to:)`. This function returns a new `EventLoopFuture` whose callbacks are guaranteed\nto fire on the provided event loop. As an added bonus, `hopTo` will check whether the provided `EventLoopFuture`\nwas already scheduled to dispatch on the event loop in question, and avoid doing any work if that was the case.\n\nThis means that for any `EventLoopFuture` that your code did not create itself (via\n`EventLoopPromise.futureResult`), use of `hopTo` is **strongly encouraged** to help guarantee thread-safety. It\nshould only be elided when thread-safety is provably not needed.\n\nThe \"thread affinity\" of `EventLoopFuture`s is critical to writing safe, performant concurrent code without\nboilerplate. It allows you to avoid needing to write or use locks in your own code, instead using the natural\nsynchronization of the `EventLoop` to manage your thread-safety. In general, if any of your `ChannelHandler`s\nor `EventLoopFuture` callbacks need to invoke a lock (either directly or in the form of `DispatchQueue`) this\nshould be considered a code smell worth investigating: the `EventLoop`-based synchronization guarantees of\n`EventLoopFuture` should be sufficient to guarantee thread-safety."},{"p":["IdleStateHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["IdleStateHandler",7]],"s":[["class",12],[" ",17],["IdleStateHandler",7]],"d":"Triggers an IdleStateEvent when a Channel has not performed read, write, or both operation for a while."},{"p":["BackPressureHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["BackPressureHandler",7]],"s":[["class",12],[" ",17],["BackPressureHandler",7]],"d":"ChannelHandler implementation which enforces back-pressure by stopping to read from the remote peer when it cannot write back fast enough.\nIt will start reading again once pending data was written."},{"p":["NIONetworkInterface"],"f":[["final",12],[" ",17],["class",12],[" ",17],["NIONetworkInterface",7]],"s":[["class",12],[" ",17],["NIONetworkInterface",7]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"A representation of a single network interface on a system."},{"p":["AcceptBackoffHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["AcceptBackoffHandler",7]],"s":[["class",12],[" ",17],["AcceptBackoffHandler",7]],"d":"A `ChannelHandler` that implements a backoff for a `ServerChannel` when accept produces an `IOError`.\nThese errors are often recoverable by reducing the rate at which we call accept."},{"p":["ByteToMessageHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["ByteToMessageHandler",7],["<",17],["Decoder",0],["> ",17],["where",12],[" ",17],["Decoder",18],[" : ",17],["ByteToMessageDecoder",18,13]],"s":[["class",12],[" ",17],["ByteToMessageHandler",7]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]],"d":"A handler which turns a given `ByteToMessageDecoder` into a `ChannelInboundHandler` that can then be added to a\n`ChannelPipeline`.\n\nMost importantly, `ByteToMessageHandler` handles the tricky buffer management for you and flattens out all\nre-entrancy on `channelRead` that may happen in the `ChannelPipeline`."},{"p":["MessageToByteHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["MessageToByteHandler",7],["<",17],["Encoder",0],["> ",17],["where",12],[" ",17],["Encoder",18],[" : ",17],["MessageToByteEncoder",18,14]],"s":[["class",12],[" ",17],["MessageToByteHandler",7]],"c":[["Encoder",1,"MessageToByteEncoder",14]],"g":[["Encoder",0,0]],"d":"A handler which turns a given `MessageToByteEncoder` into a `ChannelOutboundHandler` that can then be added to a\n`ChannelPipeline`."},{"p":["ChannelHandlerContext"],"f":[["final",12],[" ",17],["class",12],[" ",17],["ChannelHandlerContext",7]],"s":[["class",12],[" ",17],["ChannelHandlerContext",7]],"d":"Every `ChannelHandler` has -- when added to a `ChannelPipeline` -- a corresponding `ChannelHandlerContext` which is\nthe way `ChannelHandler`s can interact with other `ChannelHandler`s in the pipeline.\n\nMost `ChannelHandler`s need to send events through the `ChannelPipeline` which they do by calling the respective\nmethod on their `ChannelHandlerContext`. In fact all the `ChannelHandler` default implementations just forward\nthe event using the `ChannelHandlerContext`.\n\nMany events are instrumental for a `ChannelHandler`'s life-cycle and it is therefore very important to send them\nat the right point in time. Often, the right behaviour is to react to an event and then forward it to the next\n`ChannelHandler`."},{"p":["NIOCloseOnErrorHandler"],"f":[["final",12],[" ",17],["class",12],[" ",17],["NIOCloseOnErrorHandler",7]],"s":[["class",12],[" ",17],["NIOCloseOnErrorHandler",7]],"d":"A `ChannelInboundHandler` that closes the channel when an error is caught"},{"p":["NIOSingleStepByteToMessageProcessor"],"f":[["final",12],[" ",17],["class",12],[" ",17],["NIOSingleStepByteToMessageProcessor",7],["<",17],["Decoder",0],["> ",17],["where",12],[" ",17],["Decoder",18],[" : ",17],["NIOSingleStepByteToMessageDecoder",18,25]],"s":[["class",12],[" ",17],["NIOSingleStepByteToMessageProcessor",7]],"c":[["Decoder",1,"NIOSingleStepByteToMessageDecoder",25]],"g":[["Decoder",0,0]],"d":"`NIOSingleStepByteToMessageProcessor` uses a `NIOSingleStepByteToMessageDecoder` to produce messages\nfrom a stream of incoming bytes. It works like `ByteToMessageHandler` but may be used outside of the channel pipeline. This allows\nprocessing of wrapped protocols in a general way.\n\nA `NIOSingleStepByteToMessageProcessor` is first initialized with a `NIOSingleStepByteToMessageDecoder`. Then\ncall `process` as each `ByteBuffer` is received from the stream. The closure is called repeatedly with each message produced by\nthe decoder.\n\nWhen your stream ends, call `finishProcessing` to ensure all buffered data is passed to your decoder. This will call `decodeLast`\none or more times with any remaining data.\n\n### Example\n\nBelow is an example of a protocol decoded by `TwoByteStringCodec` that is sent over HTTP. `RawBodyMessageHandler` forwards the headers\nand trailers directly and uses `NIOSingleStepByteToMessageProcessor` to send whole decoded messages.\n\n    class TwoByteStringCodec: NIOSingleStepByteToMessageDecoder {\n        typealias InboundOut = String\n\n        public func decode(buffer: inout ByteBuffer) throws -> InboundOut? {\n            return buffer.readString(length: 2)\n        }\n\n        public func decodeLast(buffer: inout ByteBuffer, seenEOF: Bool) throws -> InboundOut? {\n            return try self.decode(buffer: &buffer)\n        }\n    }\n\n    class RawBodyMessageHandler: ChannelInboundHandler {\n        typealias InboundIn = HTTPServerRequestPart // alias for HTTPPart<HTTPRequestHead, ByteBuffer>\n        // This converts the body from ByteBuffer to String, our message type\n        typealias InboundOut = HTTPPart<HTTPRequestHead, String>\n\n        private var messageProcessor: NIOSingleStepByteToMessageProcessor<TwoByteStringCodec>? = nil\n\n        func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n            let req = self.unwrapInboundIn(data)\n            do {\n                switch req {\n                case .head(let head):\n                    // simply forward on the head\n                    context.fireChannelRead(self.wrapInboundOut(.head(head)))\n                case .body(let body):\n                    if self.messageProcessor == nil {\n                        self.messageProcessor = NIOSingleStepByteToMessageProcessor(TwoByteStringCodec())\n                    }\n                    try self.messageProcessor!.process(buffer: body) { message in\n                        self.channelReadMessage(context: context, message: message)\n                    }\n                case .end(let trailers):\n                    // Forward on any remaining messages and the trailers\n                    try self.messageProcessor?.finishProcessing(seenEOF: false) { message in\n                        self.channelReadMessage(context: context, message: message)\n                    }\n                    context.fireChannelRead(self.wrapInboundOut(.end(trailers)))\n                }\n            } catch {\n                context.fireErrorCaught(error)\n            }\n        }\n\n        // Forward on the body messages as whole messages\n        func channelReadMessage(context: ChannelHandlerContext, message: String) {\n            context.fireChannelRead(self.wrapInboundOut(.body(message)))\n        }\n    }\n\n    private class DecodedBodyHTTPHandler: ChannelInboundHandler {\n        typealias InboundIn = HTTPPart<HTTPRequestHead, String>\n        typealias OutboundOut = HTTPServerResponsePart\n\n        var msgs: [String] = []\n\n        func channelRead(context: ChannelHandlerContext, data: NIOAny) {\n            let message = self.unwrapInboundIn(data)\n\n            switch message {\n            case .head(let head):\n                print(\"head: \\(head)\")\n            case .body(let msg):\n                self.msgs.append(msg)\n            case .end(let trailers):\n                print(\"trailers: \\(trailers)\")\n                var responseBuffer = context.channel.allocator.buffer(capacity: 32)\n                for msg in msgs {\n                    responseBuffer.writeString(msg)\n                    responseBuffer.writeStaticString(\"\\n\")\n                }\n                var headers = HTTPHeaders()\n                headers.add(name: \"content-length\", value: String(responseBuffer.readableBytes))\n\n                context.write(self.wrapOutboundOut(HTTPServerResponsePart.head(\n                    HTTPResponseHead(version: .http1_1,\n                                     status: .ok, headers: headers))), promise: nil)\n\n                context.write(self.wrapOutboundOut(HTTPServerResponsePart.body(\n                    .byteBuffer(responseBuffer))), promise: nil)\n                context.writeAndFlush(self.wrapOutboundOut(HTTPServerResponsePart.end(nil)), promise: nil)\n            }\n        }\n    }\n\n    let group = MultiThreadedEventLoopGroup(numberOfThreads: 1)\n    let bootstrap = ServerBootstrap(group: group).childChannelInitializer({channel in\n        channel.pipeline.configureHTTPServerPipeline(withPipeliningAssistance: true, withErrorHandling: true).flatMap { _ in\n            channel.pipeline.addHandlers([RawBodyMessageHandler(), DecodedBodyHTTPHandler()])\n        }\n    })\n    let channelFuture = bootstrap.bind(host: \"127.0.0.1\", port: 0)\n"},{"p":["Endianness","big"],"f":[["case",12],[" ",17],["big",7]],"s":[["case",12],[" ",17],["big",7]],"d":"big endian, the most significant byte (MSB) is at the lowest address"},{"p":["Endianness","little"],"f":[["case",12],[" ",17],["little",7]],"s":[["case",12],[" ",17],["little",7]],"d":"little endian, the least significant byte (LSB) is at the lowest address"},{"p":["ChannelError","ioOnClosedChannel"],"f":[["case",12],[" ",17],["ioOnClosedChannel",7]],"s":[["case",12],[" ",17],["ioOnClosedChannel",7]],"d":"An I/O operation (e.g. read/write/flush) called on a channel that is already closed."},{"p":["ChannelError","inputClosed"],"f":[["case",12],[" ",17],["inputClosed",7]],"s":[["case",12],[" ",17],["inputClosed",7]],"d":"Input-side of the channel is closed."},{"p":["ChannelError","outputClosed"],"f":[["case",12],[" ",17],["outputClosed",7]],"s":[["case",12],[" ",17],["outputClosed",7]],"d":"Output-side of the channel is closed."},{"p":["ChannelError","alreadyClosed"],"f":[["case",12],[" ",17],["alreadyClosed",7]],"s":[["case",12],[" ",17],["alreadyClosed",7]],"d":"Close was called on a channel that is already closed."},{"p":["ChannelError","connectPending"],"f":[["case",12],[" ",17],["connectPending",7]],"s":[["case",12],[" ",17],["connectPending",7]],"d":"Tried to connect on a `Channel` that is already connecting."},{"p":["ChannelError","connectTimeout(_:)"],"f":[["case",12],[" ",17],["connectTimeout",7],["(",17],["TimeAmount",18,62],[")",17]],"s":[["case",12],[" ",17],["connectTimeout",7],["(",17],["TimeAmount",18],[")",17]],"d":"Connect operation timed out"},{"p":["ChannelError","unremovableHandler"],"f":[["case",12],[" ",17],["unremovableHandler",7]],"s":[["case",12],[" ",17],["unremovableHandler",7]],"d":"An attempt was made to remove a ChannelHandler that is not removable."},{"p":["ChannelError","unknownLocalAddress"],"f":[["case",12],[" ",17],["unknownLocalAddress",7]],"s":[["case",12],[" ",17],["unknownLocalAddress",7]],"d":"The local address of the `Channel` could not be determined."},{"p":["ChannelError","operationUnsupported"],"f":[["case",12],[" ",17],["operationUnsupported",7]],"s":[["case",12],[" ",17],["operationUnsupported",7]],"d":"Unsupported operation triggered on a `Channel`. For example `connect` on a `ServerSocketChannel`."},{"p":["ChannelError","writeHostUnreachable"],"f":[["case",12],[" ",17],["writeHostUnreachable",7]],"s":[["case",12],[" ",17],["writeHostUnreachable",7]],"d":"A `DatagramChannel` `write` was made with an address that was not reachable and so could not be delivered."},{"p":["ChannelError","writeMessageTooLarge"],"f":[["case",12],[" ",17],["writeMessageTooLarge",7]],"s":[["case",12],[" ",17],["writeMessageTooLarge",7]],"d":"A `DatagramChannel` `write` was made with a buffer that is larger than the MTU for the connection, and so the\ndatagram was not written. Either shorten the datagram or manually fragment, and then try again."},{"p":["ChannelError","multicastNotSupported(_:)"],"f":[["case",12],[" ",17],["multicastNotSupported",7],["(",17],["NIONetworkInterface",18,124],[")",17]],"s":[["case",12],[" ",17],["multicastNotSupported",7],["(",17],["NIONetworkInterface",18],[")",17]],"a":{"a":{"d":true,"r":"NIOMulticastNotSupportedError"}},"d":"Multicast is not supported on Interface"},{"p":["ChannelError","illegalMulticastAddress(_:)"],"f":[["case",12],[" ",17],["illegalMulticastAddress",7],["(",17],["SocketAddress",18,43],[")",17]],"s":[["case",12],[" ",17],["illegalMulticastAddress",7],["(",17],["SocketAddress",18],[")",17]],"d":"An attempt was made to join a multicast group that does not correspond to a multicast\naddress."},{"p":["ChannelError","badInterfaceAddressFamily"],"f":[["case",12],[" ",17],["badInterfaceAddressFamily",7]],"s":[["case",12],[" ",17],["badInterfaceAddressFamily",7]],"d":"The address family of the provided multicast group join is not valid for this `Channel`."},{"p":["ChannelError","badMulticastGroupAddressFamily"],"f":[["case",12],[" ",17],["badMulticastGroupAddressFamily",7]],"s":[["case",12],[" ",17],["badMulticastGroupAddressFamily",7]],"d":"The address family of the multicast group was not valid for this `Channel`."},{"p":["ChannelError","inappropriateOperationForState"],"f":[["case",12],[" ",17],["inappropriateOperationForState",7]],"s":[["case",12],[" ",17],["inappropriateOperationForState",7]],"d":"An operation that was inappropriate given the current `Channel` state was attempted."},{"p":["ChannelError","eof"],"f":[["case",12],[" ",17],["eof",7]],"s":[["case",12],[" ",17],["eof",7]],"d":"A read operation reached end-of-file. This usually means the remote peer closed the socket but it's still\nopen locally."},{"p":["ChannelEvent","inputClosed"],"f":[["case",12],[" ",17],["inputClosed",7]],"s":[["case",12],[" ",17],["inputClosed",7]],"d":"`ChannelOptions.allowRemoteHalfClosure` is `true` and input portion of the `Channel` was closed."},{"p":["ChannelEvent","outputClosed"],"f":[["case",12],[" ",17],["outputClosed",7]],"s":[["case",12],[" ",17],["outputClosed",7]],"d":"Output portion of the `Channel` was closed."},{"p":["DecodingState","needMoreData"],"f":[["case",12],[" ",17],["needMoreData",7]],"s":[["case",12],[" ",17],["needMoreData",7]],"d":"Stop decoding until more data is ready to be processed."},{"p":["DecodingState","continue"],"f":[["case",12],[" ",17],["`continue`",7]],"s":[["case",12],[" ",17],["`continue`",7]],"d":"Continue decoding."},{"p":["SocketAddress","unixDomainSocket(_:)"],"f":[["case",12],[" ",17],["unixDomainSocket",7],["(",17],["SocketAddress",18,43],[".",17],["UnixSocketAddress",18,73],[")",17]],"s":[["case",12],[" ",17],["unixDomainSocket",7],["(",17],["SocketAddress",18],[".",17],["UnixSocketAddress",18],[")",17]],"d":"An UNIX Domain `SocketAddress`."},{"p":["SocketAddress","v4(_:)"],"f":[["case",12],[" ",17],["v4",7],["(",17],["SocketAddress",18,43],[".",17],["IPv4Address",18,71],[")",17]],"s":[["case",12],[" ",17],["v4",7],["(",17],["SocketAddress",18],[".",17],["IPv4Address",18],[")",17]],"d":"An IPv4 `SocketAddress`."},{"p":["SocketAddress","v6(_:)"],"f":[["case",12],[" ",17],["v6",7],["(",17],["SocketAddress",18,43],[".",17],["IPv6Address",18,72],[")",17]],"s":[["case",12],[" ",17],["v6",7],["(",17],["SocketAddress",18],[".",17],["IPv6Address",18],[")",17]],"d":"An IPv6 `SocketAddress`."},{"p":["ChannelOptions","Types","ConvenienceOptionValue","set(_:)"],"f":[["case",12],[" ",17],["set",7],["(",17],["ValueType",18],[")",17]],"s":[["case",12],[" ",17],["set",7],["(",17],["ValueType",18],[")",17]],"d":"The option was set with a value of type ValueType."},{"p":["ChannelOptions","Types","ConvenienceOptionValue","notSet"],"f":[["case",12],[" ",17],["notSet",7]],"s":[["case",12],[" ",17],["notSet",7]],"d":"The option was not set."},{"p":["EventLoopError","shutdownFailed"],"f":[["case",12],[" ",17],["shutdownFailed",7]],"s":[["case",12],[" ",17],["shutdownFailed",7]],"d":"Shutting down the `EventLoop` failed."},{"p":["EventLoopError","unsupportedOperation"],"f":[["case",12],[" ",17],["unsupportedOperation",7]],"s":[["case",12],[" ",17],["unsupportedOperation",7]],"d":"An operation was executed that is not supported by the `EventLoop`"},{"p":["EventLoopError","shutdown"],"f":[["case",12],[" ",17],["shutdown",7]],"s":[["case",12],[" ",17],["shutdown",7]],"d":"The `EventLoop` was shutdown already."},{"p":["EventLoopError","cancelled"],"f":[["case",12],[" ",17],["cancelled",7]],"s":[["case",12],[" ",17],["cancelled",7]],"d":"An scheduled task was cancelled."},{"p":["ChannelPipeline","Position","last"],"f":[["case",12],[" ",17],["last",7]],"s":[["case",12],[" ",17],["last",7]],"d":"The last `ChannelHandler` -- the back of the `ChannelPipeline`."},{"p":["ChannelPipeline","Position","after(_:)"],"f":[["case",12],[" ",17],["after",7],["(",17],["ChannelHandler",18,8],[")",17]],"s":[["case",12],[" ",17],["after",7],["(",17],["ChannelHandler",18],[")",17]],"d":"After the given `ChannelHandler`."},{"p":["ChannelPipeline","Position","first"],"f":[["case",12],[" ",17],["first",7]],"s":[["case",12],[" ",17],["first",7]],"d":"The first `ChannelHandler` -- the front of the `ChannelPipeline`."},{"p":["ChannelPipeline","Position","before(_:)"],"f":[["case",12],[" ",17],["before",7],["(",17],["ChannelHandler",18,8],[")",17]],"s":[["case",12],[" ",17],["before",7],["(",17],["ChannelHandler",18],[")",17]],"d":"Before the given `ChannelHandler`."},{"p":["IdleStateHandler","IdleStateEvent","all"],"f":[["case",12],[" ",17],["all",7]],"s":[["case",12],[" ",17],["all",7]],"d":"Will be triggered when neither read nor write was performed for the specified amount of time"},{"p":["IdleStateHandler","IdleStateEvent","read"],"f":[["case",12],[" ",17],["read",7]],"s":[["case",12],[" ",17],["read",7]],"d":"Will be triggered when no read was performed for the specified amount of time"},{"p":["IdleStateHandler","IdleStateEvent","write"],"f":[["case",12],[" ",17],["write",7]],"s":[["case",12],[" ",17],["write",7]],"d":"Will be triggered when no write was performed for the specified amount of time"},{"p":["SocketAddressError","unixDomainSocketPathTooLong"],"f":[["case",12],[" ",17],["unixDomainSocketPathTooLong",7]],"s":[["case",12],[" ",17],["unixDomainSocketPathTooLong",7]],"d":"The requested UDS path is too long."},{"p":["SocketAddressError","unsupported"],"f":[["case",12],[" ",17],["unsupported",7]],"s":[["case",12],[" ",17],["unsupported",7]],"d":"The requested `SocketAddress` is not supported."},{"p":["SocketAddressError","failedToParseIPString(_:)"],"f":[["case",12],[" ",17],["failedToParseIPString",7],["(",17],["String",18,1165],[")",17]],"s":[["case",12],[" ",17],["failedToParseIPString",7],["(",17],["String",18],[")",17]],"d":"Unable to parse a given IP string"},{"p":["SocketAddressError","unknown(host:port:)"],"f":[["case",12],[" ",17],["unknown",7],["(",17],["host",1],[": ",17],["String",18,1165],[", ",17],["port",1],[": ",17],["Int",18,1227],[")",17]],"s":[["case",12],[" ",17],["unknown",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[")",17]],"d":"The host is unknown (could not be resolved)."},{"p":["ChannelPipelineError","alreadyRemoved"],"f":[["case",12],[" ",17],["alreadyRemoved",7]],"s":[["case",12],[" ",17],["alreadyRemoved",7]],"d":"`ChannelHandler` was already removed."},{"p":["ChannelPipelineError","notFound"],"f":[["case",12],[" ",17],["notFound",7]],"s":[["case",12],[" ",17],["notFound",7]],"d":"`ChannelHandler` was not found."},{"p":["ByteToMessageDecoderError","dataReceivedInErrorState(_:_:)"],"f":[["case",12],[" ",17],["dataReceivedInErrorState",7],["(",17],["Error",18,1380],[", ",17],["ByteBuffer",18,58],[")",17]],"s":[["case",12],[" ",17],["dataReceivedInErrorState",7],["(",17],["Error",18],[", ",17],["ByteBuffer",18],[")",17]],"d":"More data has been received by a `ByteToMessageHandler` despite the fact that an error has previously been\nemitted. The associated `Error` is the error previously emitted and the `ByteBuffer` is the extra data that has\nbeen received. The common cause for this error to be emitted is the user not having torn down the `Channel`\nafter previously an `Error` has been sent through the pipeline using `fireErrorCaught`."},{"p":["ByteToMessageDecoderError","leftoverDataWhenDone(_:)"],"f":[["case",12],[" ",17],["leftoverDataWhenDone",7],["(",17],["ByteBuffer",18,58],[")",17]],"s":[["case",12],[" ",17],["leftoverDataWhenDone",7],["(",17],["ByteBuffer",18],[")",17]],"d":"This error can be thrown by `ByteToMessageDecoder`s if there was unexpectedly some left-over data when the\n`ByteToMessageDecoder` was removed from the pipeline or the `Channel` was closed."},{"p":["NIOEventLoopGroupProvider","shared(_:)"],"f":[["case",12],[" ",17],["shared",7],["(",17],["EventLoopGroup",18,10],[")",17]],"s":[["case",12],[" ",17],["shared",7],["(",17],["EventLoopGroup",18],[")",17]],"d":"Use an `EventLoopGroup` provided by the user.\nThe owner of this group is responsible for its lifecycle."},{"p":["NIOEventLoopGroupProvider","createNew"],"f":[["case",12],[" ",17],["createNew",7]],"s":[["case",12],[" ",17],["createNew",7]],"d":"Create a new `EventLoopGroup` when necessary.\nThe library which accepts this provider takes ownership of the created event loop group,\nand must ensure its proper shutdown when the library is being shut down."},{"p":["NIOExplicitCongestionNotificationState","transportNotCapable"],"f":[["case",12],[" ",17],["transportNotCapable",7]],"s":[["case",12],[" ",17],["transportNotCapable",7]],"d":"Non-ECN Capable Transport."},{"p":["NIOExplicitCongestionNotificationState","congestionExperienced"],"f":[["case",12],[" ",17],["congestionExperienced",7]],"s":[["case",12],[" ",17],["congestionExperienced",7]],"d":"Congestion Experienced."},{"p":["NIOExplicitCongestionNotificationState","transportCapableFlag0"],"f":[["case",12],[" ",17],["transportCapableFlag0",7]],"s":[["case",12],[" ",17],["transportCapableFlag0",7]],"d":"ECN Capable Transport (flag 0)."},{"p":["NIOExplicitCongestionNotificationState","transportCapableFlag1"],"f":[["case",12],[" ",17],["transportCapableFlag1",7]],"s":[["case",12],[" ",17],["transportCapableFlag1",7]],"d":"ECN Capable Transport (flag 1)."},{"p":["IOData","byteBuffer(_:)"],"f":[["case",12],[" ",17],["byteBuffer",7],["(",17],["ByteBuffer",18,58],[")",17]],"s":[["case",12],[" ",17],["byteBuffer",7],["(",17],["ByteBuffer",18],[")",17]],"d":"A `ByteBuffer`."},{"p":["IOData","fileRegion(_:)"],"f":[["case",12],[" ",17],["fileRegion",7],["(",17],["FileRegion",18,61],[")",17]],"s":[["case",12],[" ",17],["fileRegion",7],["(",17],["FileRegion",18],[")",17]],"d":"A `FileRegion`.\n\nSending a `FileRegion` through the `ChannelPipeline` using `write` can be useful because some `Channel`s can\nuse `sendfile` to send a `FileRegion` more efficiently."},{"p":["IOError","FailureDescription","reason(_:)"],"f":[["case",12],[" ",17],["reason",7],["(",17],["String",18,1165],[")",17]],"s":[["case",12],[" ",17],["reason",7],["(",17],["String",18],[")",17]],"a":{"a":{"d":true,"m":"NIO no longer uses FailureDescription."}}},{"p":["IOError","FailureDescription","function(_:)"],"f":[["case",12],[" ",17],["function",7],["(",17],["StaticString",18,1359],[")",17]],"s":[["case",12],[" ",17],["function",7],["(",17],["StaticString",18],[")",17]],"a":{"a":{"d":true,"m":"NIO no longer uses FailureDescription."}}},{"p":["CloseMode","all"],"f":[["case",12],[" ",17],["all",7]],"s":[["case",12],[" ",17],["all",7]],"d":"Close the whole `Channel (file descriptor)."},{"p":["CloseMode","input"],"f":[["case",12],[" ",17],["input",7]],"s":[["case",12],[" ",17],["input",7]],"d":"Close the input (reading) side of the `Channel` without closing the actual file descriptor.\nThis is an optional mode which means it may not be supported by all `Channel` implementations."},{"p":["CloseMode","output"],"f":[["case",12],[" ",17],["output",7]],"s":[["case",12],[" ",17],["output",7]],"d":"Close the output (writing) side of the `Channel` without closing the actual file descriptor.\nThis is an optional mode which means it may not be supported by all `Channel` implementations."},{"p":["ByteBuffer","init(dispatchData:)"],"f":[["init",10],["(",17],["dispatchData",1],[": ",17],["DispatchData",18,1110],[")",17]],"s":[["init",10],["(",17],["dispatchData",1],[": ",17],["DispatchData",18],[")",17]],"d":"Create a fresh `ByteBuffer` containing the bytes contained in the given `DispatchData`.\n\nThis will allocate a new `ByteBuffer` with enough space to fit the bytes of the `DispatchData` and potentially\nsome extra space using the default allocator.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(dispatchData:)`. Or if you want to write multiple items into\n        the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeDispatchData` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(staticString:)"],"f":[["init",10],["(",17],["staticString",1],[" ",17],["string",2],[": ",17],["StaticString",18,1359],[")",17]],"s":[["init",10],["(",17],["staticString",1],[": ",17],["StaticString",18],[")",17]],"d":"Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space using\nthe default allocator.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(staticString:)`. Or if you want to write multiple items into\n        the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeStaticString` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(bytes:)"],"f":[["init",10],["<",17],["Bytes",0],[">(",17],["bytes",1],[": ",17],["Bytes",18],[") ",17],["where",12],[" ",17],["Bytes",18],[" : ",17],["Sequence",18,1166],[", ",17],["Bytes",18],[".",17],["Element",18],[" == ",17],["UInt8",18,1384]],"s":[["init",10],["<",17],["Bytes",0],[">(",17],["bytes",1],[": ",17],["Bytes",18],[")",17]],"c":[["Bytes",1,"Sequence",1166],["Bytes.Element",2,"UInt8",1384]],"g":[["Bytes",0,0]],"d":"Create a fresh `ByteBuffer` containing the `bytes`.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `bytes` and potentially some extra space using\nthe default allocator.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(bytes:)`. Or if you want to write multiple items into the\n        buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeBytes` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(buffer:)"],"f":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[")",17]],"s":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[")",17]],"d":"Create a fresh `ByteBuffer` containing the readable bytes of `buffer`.\n\nThis may allocate a new `ByteBuffer` with enough space to fit `buffer` and potentially some extra space using\nthe default allocator.\n\n- note: Use this method only if you deliberately want to reallocate a potentially smaller `ByteBuffer` than the\n        one you already have. Given that `ByteBuffer` is a value type, defensive copies are not necessary. If\n        you have a `ByteBuffer` but would like the `readerIndex` to start at `0`, consider `readSlice` instead.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(buffer:)`. Or if you want to write multiple items into the\n        buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeImmutableBuffer` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(string:)"],"f":[["init",10],["(",17],["string",1],[": ",17],["String",18,1165],[")",17]],"s":[["init",10],["(",17],["string",1],[": ",17],["String",18],[")",17]],"d":"Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space using\nthe default allocator.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(string:)`. Or if you want to write multiple items into the\n        buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeString` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(integer:endianness:as:)"],"f":[["init",10],["<",17],["I",0],[">(",17],["integer",1],[": ",17],["I",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": ",17],["I",18],[".Type = I.self) ",17],["where",12],[" ",17],["I",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["init",10],["<",17],["I",0],[">(",17],["integer",1],[": ",17],["I",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["I",18],[".Type)",17]],"c":[["I",1,"FixedWidthInteger",1361]],"g":[["I",0,0]],"d":"Create a fresh `ByteBuffer` containing the bytes of the byte representation in the given `endianness` of\n`integer`.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `integer` and potentially some extra space using\nthe default allocator.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(integer:)`. Or if you want to write multiple items into the\n        buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeInteger` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(repeating:count:)"],"f":[["init",10],["(",17],["repeating",1],[" ",17],["byte",2],[": ",17],["UInt8",18,1384],[", ",17],["count",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["repeating",1],[": ",17],["UInt8",18],[", ",17],["count",1],[": ",17],["Int",18],[")",17]],"d":"Create a fresh `ByteBuffer` containing `count` repetitions of `byte`.\n\nThis will allocate a new `ByteBuffer` with at least `count` bytes.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(repeating:count:)`. Or if you want to write multiple items\n        into the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeRepeatingByte` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(substring:)"],"f":[["init",10],["(",17],["substring",1],[" ",17],["string",2],[": ",17],["Substring",18,1340],[")",17]],"s":[["init",10],["(",17],["substring",1],[": ",17],["Substring",18],[")",17]],"d":"Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space using\nthe default allocator.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` we\n        recommend using `channel.allocator.buffer(substring:)`. Or if you want to write multiple items into\n        the buffer use `channel.allocator.buffer(capacity: ...)` to allocate a `ByteBuffer` of the right\n        size followed by a `writeSubstring` instead of using this method. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"d":"Return an empty `ByteBuffer` allocated with `ByteBufferAllocator()`.\n\nCalling this constructor will not allocate because it will return a `ByteBuffer` that wraps a shared storage\nobject. As soon as you write to the constructed buffer however, you will incur an allocation because a\ncopy-on-write will happen.\n\n- info: If you have access to a `Channel`, `ChannelHandlerContext`, or `ByteBufferAllocator` it is\n        recommended using `channel.allocator.buffer(capacity: 0)`. This allows SwiftNIO to do\n        accounting and optimisations of resources acquired for operations on a given `Channel` in the future."},{"p":["ByteBuffer","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["view",2],[": ",17],["ByteBufferView",18,74],[")",17]],"s":[["init",10],["(",17],["ByteBufferView",18],[")",17]],"d":"Create a `ByteBuffer` from the given `ByteBufferView`s range.\n\n- parameter view: The `ByteBufferView` which you want to get a `ByteBuffer` from."},{"p":["FileRegion","init(fileHandle:readerIndex:endIndex:)"],"f":[["init",10],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,119],[", ",17],["readerIndex",1],[": ",17],["Int",18,1227],[", ",17],["endIndex",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[", ",17],["readerIndex",1],[": ",17],["Int",18],[", ",17],["endIndex",1],[": ",17],["Int",18],[")",17]],"d":"Create a new `FileRegion` from an open `NIOFileHandle`.\n\n- parameters:\n    - fileHandle: the `NIOFileHandle` to use.\n    - readerIndex: the index (offset) on which the reading will start.\n    - endIndex: the index which represent the end of the readable portion."},{"p":["FileRegion","init(fileHandle:)"],"f":[["init",10],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18,119],[") ",17],["throws",12]],"s":[["init",10],["(",17],["fileHandle",1],[": ",17],["NIOFileHandle",18],[") ",17],["throws",12]],"d":"Create a new `FileRegion` forming a complete file.\n\n- parameters:\n    - fileHandle: An open `NIOFileHandle` to the file."},{"p":["NIOBSDSocket","OptionLevel","init(rawValue:)"],"f":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64],[".",17],["RawValue",18,1027],[")",17]],"s":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18],[".",17],["RawValue",18],[")",17]]},{"p":["NIOBSDSocket","AddressFamily","init(rawValue:)"],"f":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["AddressFamily",18,65],[".",17],["RawValue",18,1028],[")",17]],"s":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18],[".",17],["AddressFamily",18],[".",17],["RawValue",18],[")",17]]},{"p":["NIOBSDSocket","ProtocolFamily","init(rawValue:)"],"f":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["ProtocolFamily",18,66],[".",17],["RawValue",18,1029],[")",17]],"s":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18],[".",17],["ProtocolFamily",18],[".",17],["RawValue",18],[")",17]]},{"p":["NIOBSDSocket","Option","init(rawValue:)"],"f":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67],[".",17],["RawValue",18,1031],[")",17]],"s":[["init",10],["(",17],["rawValue",1],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18],[".",17],["RawValue",18],[")",17]]},{"p":["NIOFileHandle","init(descriptor:)"],"f":[["init",10],["(",17],["descriptor",1],[": ",17],["CInt",18,1378],[")",17]],"s":[["init",10],["(",17],["descriptor",1],[": ",17],["CInt",18],[")",17]],"d":"Create a `NIOFileHandle` taking ownership of `descriptor`. You must call `NIOFileHandle.close` or `NIOFileHandle.takeDescriptorOwnership` before\nthis object can be safely released."},{"p":["NIOFileHandle","Mode","init(rawValue:)"],"f":[["init",10],["(",17],["rawValue",1],[": ",17],["UInt8",18,1384],[")",17]],"s":[["init",10],["(",17],["rawValue",1],[": ",17],["UInt8",18],[")",17]]},{"p":["NIOFileHandle","init(path:mode:flags:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["path",1],[": ",17],["String",18,1165],[", ",17],["mode",1],[": ",17],["NIOFileHandle",18,119],[".",17],["Mode",18,68],[" = .read, ",17],["flags",1],[": ",17],["NIOFileHandle",18,119],[".",17],["Flags",18,69],[" = .default) ",17],["throws",12]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["path",1],[": ",17],["String",18],[", ",17],["mode",1],[": ",17],["NIOFileHandle",18],[".",17],["Mode",18],[", ",17],["flags",1],[": ",17],["NIOFileHandle",18],[".",17],["Flags",18],[") ",17],["throws",12]],"d":"Open a new `NIOFileHandle`. This operation is blocking.\n\n- parameters:\n    - path: The path of the file to open. The ownership of the file descriptor is transferred to this `NIOFileHandle` and so it will be closed once `close` is called.\n    - mode: Access mode. Default mode is `.read`.\n    - flags: Additional POSIX flags."},{"p":["NIOFileHandle","init(path:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["path",1],[": ",17],["String",18,1165],[") ",17],["throws",12]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["path",1],[": ",17],["String",18],[") ",17],["throws",12]],"d":"Open a new `NIOFileHandle`. This operation is blocking.\n\n- parameters:\n    - path: The path of the file to open. The ownership of the file descriptor is transferred to this `NIOFileHandle` and so it will be closed once `close` is called."},{"p":["NIOPacketInfo","init(destinationAddress:interfaceIndex:)"],"f":[["init",10],["(",17],["destinationAddress",1],[": ",17],["SocketAddress",18,43],[", ",17],["interfaceIndex",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["destinationAddress",1],[": ",17],["SocketAddress",18],[", ",17],["interfaceIndex",1],[": ",17],["Int",18],[")",17]]},{"p":["SocketAddress","init(unixDomainSocketPath:)"],"f":[["init",10],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,1165],[") ",17],["throws",12]],"s":[["init",10],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[") ",17],["throws",12]],"d":"Creates a new UDS `SocketAddress`.\n\n- parameters:\n    - path: the path to use for the `SocketAddress`.\n- returns: the `SocketAddress` for the given path.\n- throws: may throw `SocketAddressError.unixDomainSocketPathTooLong` if the path is too long."},{"p":["SocketAddress","init(ipAddress:port:)"],"f":[["init",10],["(",17],["ipAddress",1],[": ",17],["String",18,1165],[", ",17],["port",1],[": ",17],["Int",18,1227],[") ",17],["throws",12]],"s":[["init",10],["(",17],["ipAddress",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") ",17],["throws",12]],"d":"Create a new `SocketAddress` for an IP address in string form.\n\n- parameters:\n    - string: The IP address, in string form.\n    - port: The target port.\n- returns: the `SocketAddress` corresponding to this string and port combination.\n- throws: may throw `SocketAddressError.failedToParseIPString` if the IP address cannot be parsed."},{"p":["SocketAddress","init(packedIPAddress:port:)"],"f":[["init",10],["(",17],["packedIPAddress",1],[": ",17],["ByteBuffer",18,58],[", ",17],["port",1],[": ",17],["Int",18,1227],[") ",17],["throws",12]],"s":[["init",10],["(",17],["packedIPAddress",1],[": ",17],["ByteBuffer",18],[", ",17],["port",1],[": ",17],["Int",18],[") ",17],["throws",12]],"d":"Create a new `SocketAddress` for an IP address in ByteBuffer form.\n\n- parameters:\n    - packedIPAddress: The IP address, in ByteBuffer form.\n    - port: The target port.\n- returns: the `SocketAddress` corresponding to this string and port combination.\n- throws: may throw `SocketAddressError.failedToParseIPByteBuffer` if the IP address cannot be parsed."},{"p":["SocketAddress","init(_:host:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["addr",2],[": ",17],["sockaddr_in",18,1095],[", ",17],["host",1],[": ",17],["String",18,1165],[")",17]],"s":[["init",10],["(",17],["sockaddr_in",18],[", ",17],["host",1],[": ",17],["String",18],[")",17]],"d":"Creates a new IPv4 `SocketAddress`.\n\n- parameters:\n    - addr: the `sockaddr_in` that holds the ipaddress and port.\n    - host: the hostname that resolved to the ipaddress."},{"p":["SocketAddress","init(_:host:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["addr",2],[": ",17],["sockaddr_in6",18,1096],[", ",17],["host",1],[": ",17],["String",18,1165],[")",17]],"s":[["init",10],["(",17],["sockaddr_in6",18],[", ",17],["host",1],[": ",17],["String",18],[")",17]],"d":"Creates a new IPv6 `SocketAddress`.\n\n- parameters:\n    - addr: the `sockaddr_in` that holds the ipaddress and port.\n    - host: the hostname that resolved to the ipaddress."},{"p":["SocketAddress","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["addr",2],[": ",17],["sockaddr_in",18,1095],[")",17]],"s":[["init",10],["(",17],["sockaddr_in",18],[")",17]],"d":"Creates a new IPv4 `SocketAddress`.\n\n- parameters:\n    - addr: the `sockaddr_in` that holds the ipaddress and port."},{"p":["SocketAddress","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["addr",2],[": ",17],["sockaddr_un",18,1097],[")",17]],"s":[["init",10],["(",17],["sockaddr_un",18],[")",17]],"d":"Creates a new Unix Domain Socket `SocketAddress`.\n\n- parameters:\n    - addr: the `sockaddr_un` that holds the socket path."},{"p":["SocketAddress","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["addr",2],[": ",17],["sockaddr_in6",18,1096],[")",17]],"s":[["init",10],["(",17],["sockaddr_in6",18],[")",17]],"d":"Creates a new IPv6 `SocketAddress`.\n\n- parameters:\n    - addr: the `sockaddr_in` that holds the ipaddress and port."},{"p":["ByteBufferView","init(arrayLiteral:)"],"f":[["init",10],["(",17],["arrayLiteral",1],[" ",17],["elements",2],[": ",17],["ByteBufferView",18,74],[".",17],["Element",18,1037],["...)",17]],"s":[["init",10],["(",17],["arrayLiteral",1],[": ",17],["ByteBufferView",18],[".",17],["Element",18],["...)",17]],"d":"required by `ExpressibleByArrayLiteral`"},{"p":["ByteBufferView","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ByteBufferView","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["buffer",2],[": ",17],["ByteBuffer",18,58],[")",17]],"s":[["init",10],["(",17],["ByteBuffer",18],[")",17]],"d":"Creates a `ByteBufferView` from the readable bytes of the given `buffer`."},{"p":["ChannelOptions","TCPConvenienceOptions","init(arrayLiteral:)"],"f":[["init",10],["(",17],["arrayLiteral",1],[" ",17],["elements",2],[": ",17],["ChannelOptions",18,75],[".",17],["TCPConvenienceOption",18,77],["...)",17]],"s":[["init",10],["(",17],["arrayLiteral",1],[": ",17],["ChannelOptions",18],[".",17],["TCPConvenienceOption",18],["...)",17]],"d":"Construct from an array literal."},{"p":["ChannelOptions","Types","SocketOption","init(level:name:)"],"f":[["init",10],["(",17],["level",1],[": ",17],["SocketOptionLevel",18,1063],[", ",17],["name",1],[": ",17],["SocketOptionName",18,1061],[")",17]],"s":[["init",10],["(",17],["level",1],[": ",17],["SocketOptionLevel",18],[", ",17],["name",1],[": ",17],["SocketOptionName",18],[")",17]],"d":"Create a new `SocketOption`.\n\n- parameters:\n    - level: The level for the option as defined in `man setsockopt`, e.g. SO_SOCKET.\n    - name: The name of the option as defined in `man setsockopt`, e.g. `SO_REUSEADDR`."},{"p":["ChannelOptions","Types","SocketOption","init(level:name:)"],"f":[["init",10],["(",17],["level",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64],[", ",17],["name",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67],[")",17]],"s":[["init",10],["(",17],["level",1],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18],[", ",17],["name",1],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18],[")",17]],"d":"Create a new `SocketOption`.\n\n- parameters:\n    - level: The level for the option as defined in `man setsockopt`, e.g. SO_SOCKET.\n    - name: The name of the option as defined in `man setsockopt`, e.g. `SO_REUSEADDR`."},{"p":["ChannelOptions","Types","BacklogOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","AutoReadOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","AllocatorOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","WriteSpinOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","ReceivePacketInfo","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","RecvAllocatorOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","ConnectTimeoutOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","WriteBufferWaterMark","init(low:high:)"],"f":[["init",10],["(",17],["low",1],[": ",17],["Int",18,1227],[", ",17],["high",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["low",1],[": ",17],["Int",18],[", ",17],["high",1],[": ",17],["Int",18],[")",17]],"d":"Create a new instance.\n\nValid initialization is restricted to `1 <= low <= high`.\n\n- parameters:\n     - low: The low watermark.\n     - high: The high watermark."},{"p":["ChannelOptions","Types","MaxMessagesPerReadOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","WriteBufferWaterMarkOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","AllowRemoteHalfClosureOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","DatagramVectorReadMessageCountOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Types","ExplicitCongestionNotificationsOption","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelOptions","Storage","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["CircularBuffer","init(arrayLiteral:)"],"f":[["init",10],["(",17],["arrayLiteral",1],[" ",17],["elements",2],[": ",17],["Element",18],["...)",17]],"s":[["init",10],["(",17],["arrayLiteral",1],[": ",17],["Element",18],["...)",17]],"g":[["Element",0,0]]},{"p":["CircularBuffer","init(initialCapacity:)"],"f":[["init",10],["(",17],["initialCapacity",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["initialCapacity",1],[": ",17],["Int",18],[")",17]],"g":[["Element",0,0]],"d":"Allocates a buffer that can hold up to `initialCapacity` elements and initialise an empty ring backed by\nthe buffer. When the ring grows to more than `initialCapacity` elements the buffer will be expanded."},{"p":["CircularBuffer","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"g":[["Element",0,0]],"d":"Allocates an empty buffer."},{"p":["ChannelPipeline","init(channel:)"],"f":[["init",10],["(",17],["channel",1],[": ",17],["Channel",18,27],[")",17]],"s":[["init",10],["(",17],["channel",1],[": ",17],["Channel",18],[")",17]],"d":"Create `ChannelPipeline` for a given `Channel`. This method should never be called by the end-user\ndirectly: it is only intended for use with custom `Channel` implementations. Users should always use\n`channel.pipeline` to access the `ChannelPipeline` for a `Channel`.\n\n- parameters:\n   - channel: The `Channel` this `ChannelPipeline` is created for."},{"p":["IdleStateHandler","init(readTimeout:writeTimeout:allTimeout:)"],"f":[["init",10],["(",17],["readTimeout",1],[": ",17],["TimeAmount",18,62],["? = nil, ",17],["writeTimeout",1],[": ",17],["TimeAmount",18,62],["? = nil, ",17],["allTimeout",1],[": ",17],["TimeAmount",18,62],["? = nil)",17]],"s":[["init",10],["(",17],["readTimeout",1],[": ",17],["TimeAmount",18],["?, ",17],["writeTimeout",1],[": ",17],["TimeAmount",18],["?, ",17],["allTimeout",1],[": ",17],["TimeAmount",18],["?)",17]]},{"p":["NIOInsecureNoTLS","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"c":[["Bootstrap",1,"NIOClientTCPBootstrapProtocol",24]],"g":[["Bootstrap",0,0]]},{"p":["NIONetworkDevice","init(name:address:netmask:broadcastAddress:pointToPointDestinationAddress:multicastSupported:interfaceIndex:)"],"f":[["init",10],["(",17],["name",1],[": ",17],["String",18,1165],[", ",17],["address",1],[": ",17],["SocketAddress",18,43],["?, ",17],["netmask",1],[": ",17],["SocketAddress",18,43],["?, ",17],["broadcastAddress",1],[": ",17],["SocketAddress",18,43],["?, ",17],["pointToPointDestinationAddress",1],[": ",17],["SocketAddress",18,43],[", ",17],["multicastSupported",1],[": ",17],["Bool",18,1224],[", ",17],["interfaceIndex",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["name",1],[": ",17],["String",18],[", ",17],["address",1],[": ",17],["SocketAddress",18],["?, ",17],["netmask",1],[": ",17],["SocketAddress",18],["?, ",17],["broadcastAddress",1],[": ",17],["SocketAddress",18],["?, ",17],["pointToPointDestinationAddress",1],[": ",17],["SocketAddress",18],[", ",17],["multicastSupported",1],[": ",17],["Bool",18],[", ",17],["interfaceIndex",1],[": ",17],["Int",18],[")",17]]},{"p":["NIONetworkDevice","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["interface",2],[": ",17],["NIONetworkInterface",18,124],[")",17]],"s":[["init",10],["(",17],["NIONetworkInterface",18],[")",17]],"a":{"a":{"d":true,"m":"This is a compatibility helper, and will be removed in a future release"}},"d":"Convert a `NIONetworkInterface` to a `NIONetworkDevice`. As `NIONetworkDevice`s are a superset of `NIONetworkInterface`s,\nit is always possible to perform this conversion."},{"p":["AddressedEnvelope","init(remoteAddress:data:metadata:)"],"f":[["init",10],["(",17],["remoteAddress",1],[": ",17],["SocketAddress",18,43],[", ",17],["data",1],[": ",17],["DataType",18],[", ",17],["metadata",1],[": ",17],["AddressedEnvelope",18,99],["<",17],["DataType",18],[">.",17],["Metadata",18,100],["?)",17]],"s":[["init",10],["(",17],["remoteAddress",1],[": ",17],["SocketAddress",18],[", ",17],["data",1],[": ",17],["DataType",18],[", ",17],["metadata",1],[": ",17],["AddressedEnvelope",18],["<",17],["DataType",18],[">.",17],["Metadata",18],["?)",17]],"g":[["DataType",0,0]]},{"p":["AddressedEnvelope","init(remoteAddress:data:)"],"f":[["init",10],["(",17],["remoteAddress",1],[": ",17],["SocketAddress",18,43],[", ",17],["data",1],[": ",17],["DataType",18],[")",17]],"s":[["init",10],["(",17],["remoteAddress",1],[": ",17],["SocketAddress",18],[", ",17],["data",1],[": ",17],["DataType",18],[")",17]],"g":[["DataType",0,0]]},{"p":["AddressedEnvelope","Metadata","init(ecnState:packetInfo:)"],"f":[["init",10],["(",17],["ecnState",1],[": ",17],["NIOExplicitCongestionNotificationState",18,53],[", ",17],["packetInfo",1],[": ",17],["NIOPacketInfo",18,70],["?)",17]],"s":[["init",10],["(",17],["ecnState",1],[": ",17],["NIOExplicitCongestionNotificationState",18],[", ",17],["packetInfo",1],[": ",17],["NIOPacketInfo",18],["?)",17]],"g":[["DataType",0,0]]},{"p":["AddressedEnvelope","Metadata","init(ecnState:)"],"f":[["init",10],["(",17],["ecnState",1],[": ",17],["NIOExplicitCongestionNotificationState",18,53],[")",17]],"s":[["init",10],["(",17],["ecnState",1],[": ",17],["NIOExplicitCongestionNotificationState",18],[")",17]],"g":[["DataType",0,0]]},{"p":["EventLoopIterator","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["eventLoops",2],[": [",17],["EventLoop",18,28],["])",17]],"s":[["init",10],["([",17],["EventLoop",18],["])",17]],"d":"Create an `EventLoopIterator` from an array of `EventLoop`s."},{"p":["SocketAddressError","FailedToParseIPByteBuffer","init(address:)"],"f":[["init",10],["(",17],["address",1],[": ",17],["ByteBuffer",18,58],[")",17]],"s":[["init",10],["(",17],["address",1],[": ",17],["ByteBuffer",18],[")",17]]},{"p":["BackPressureHandler","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ByteBufferAllocator","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"d":"Create a fresh `ByteBufferAllocator`. In the future the allocator might use for example allocation pools and\ntherefore it's recommended to reuse `ByteBufferAllocators` where possible instead of creating fresh ones in\nmany places."},{"p":["AcceptBackoffHandler","init(backoffProvider:)"],"f":[["init",10],["(",17],["backoffProvider",1],[": ",17],["@escaping",12],[" (",17],["IOError",18,116],[") -> ",17],["TimeAmount",18,62],["? = AcceptBackoffHandler.defaultBackoffProvider)",17]],"s":[["init",10],["(",17],["backoffProvider",1],[": (",17],["IOError",18],[") -> ",17],["TimeAmount",18],["?)",17]],"d":"Create a new instance\n\n- parameters:\n    - backoffProvider: returns a `TimeAmount` which will be the amount of time to wait before attempting another `read`."},{"p":["ByteToMessageHandler","init(_:maximumBufferSize:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["decoder",2],[": ",17],["Decoder",18],[", ",17],["maximumBufferSize",1],[": ",17],["Int",18,1227],["? = nil)",17]],"s":[["init",10],["(",17],["Decoder",18],[", ",17],["maximumBufferSize",1],[": ",17],["Int",18],["?)",17]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]],"d":"Initialize a `ByteToMessageHandler`.\n\n- parameters:\n    - decoder: The `ByteToMessageDecoder` to decode the bytes into message.\n    - maximumBufferSize: The maximum number of bytes to aggregate in-memory."},{"p":["ByteToMessageHandler","init(_:)"],"f":[["convenience",12],[" ",17],["init",10],["(",17],["_",1],[" ",17],["decoder",2],[": ",17],["Decoder",18],[")",17]],"s":[["convenience",12],[" ",17],["init",10],["(",17],["Decoder",18],[")",17]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]],"d":"@see: ByteToMessageHandler.init(_:maximumBufferSize)"},{"p":["MarkedCircularBuffer","init(initialCapacity:)"],"f":[["init",10],["(",17],["initialCapacity",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["initialCapacity",1],[": ",17],["Int",18],[")",17]],"g":[["Element",0,0]],"d":"Create a new instance.\n\n- parameters:\n    - initialCapacity: The initial capacity of the internal storage."},{"p":["MessageToByteHandler","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["encoder",2],[": ",17],["Encoder",18],[")",17]],"s":[["init",10],["(",17],["Encoder",18],[")",17]],"c":[["Encoder",1,"MessageToByteEncoder",14]],"g":[["Encoder",0,0]]},{"p":["NIOTooManyBytesError","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["NIOClientTCPBootstrap","init(_:tls:)"],"f":[["init",10],["<",17],["Bootstrap",0],[", ",17],["TLS",0],[">(",17],["_",1],[" ",17],["bootstrap",2],[": ",17],["Bootstrap",18],[", ",17],["tls",1],[": ",17],["TLS",18],[") ",17],["where",12],[" ",17],["Bootstrap",18],[" : ",17],["NIOClientTCPBootstrapProtocol",18,24],[", ",17],["Bootstrap",18],[" == ",17],["TLS",18],[".",17],["Bootstrap",18],[", ",17],["TLS",18],[" : ",17],["NIOClientTLSProvider",18,15]],"s":[["init",10],["<",17],["Bootstrap",0],[", ",17],["TLS",0],[">(",17],["Bootstrap",18],[", ",17],["tls",1],[": ",17],["TLS",18],[")",17]],"c":[["Bootstrap",1,"NIOClientTCPBootstrapProtocol",24],["Bootstrap",2,"TLS.Bootstrap"],["TLS",1,"NIOClientTLSProvider",15]],"g":[["Bootstrap",0,0],["TLS",1,0]],"d":"Initialize a `NIOClientTCPBootstrap` using the underlying `Bootstrap` alongside a compatible `TLS`\nimplementation.\n\n- note: If you do not require `TLS`, you can use `NIOInsecureNoTLS` which supports only plain-text\n        connections. We highly recommend to always use TLS.\n\n- parameters:\n    - bootstrap: The underlying bootstrap to use.\n    - tls: The TLS implementation to use, needs to be compatible with `Bootstrap`."},{"p":["NIOCloseOnErrorHandler","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"d":"Initialize a `NIOCloseOnErrorHandler`"},{"p":["ByteToMessageDecoderError","PayloadTooLargeError","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["ChannelShouldQuiesceEvent","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["NIOMulticastNotSupportedError","init(device:)"],"f":[["init",10],["(",17],["device",1],[": ",17],["NIONetworkDevice",18,98],[")",17]],"s":[["init",10],["(",17],["device",1],[": ",17],["NIONetworkDevice",18],[")",17]]},{"p":["AdaptiveRecvByteBufferAllocator","init(minimum:initial:maximum:)"],"f":[["init",10],["(",17],["minimum",1],[": ",17],["Int",18,1227],[", ",17],["initial",1],[": ",17],["Int",18,1227],[", ",17],["maximum",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["minimum",1],[": ",17],["Int",18],[", ",17],["initial",1],[": ",17],["Int",18],[", ",17],["maximum",1],[": ",17],["Int",18],[")",17]]},{"p":["AdaptiveRecvByteBufferAllocator","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["NIOMulticastNotImplementedError","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]]},{"p":["FixedSizeRecvByteBufferAllocator","init(capacity:)"],"f":[["init",10],["(",17],["capacity",1],[": ",17],["Int",18,1227],[")",17]],"s":[["init",10],["(",17],["capacity",1],[": ",17],["Int",18],[")",17]]},{"p":["NIOSingleStepByteToMessageProcessor","init(_:maximumBufferSize:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["decoder",2],[": ",17],["Decoder",18],[", ",17],["maximumBufferSize",1],[": ",17],["Int",18,1227],["? = nil)",17]],"s":[["init",10],["(",17],["Decoder",18],[", ",17],["maximumBufferSize",1],[": ",17],["Int",18],["?)",17]],"c":[["Decoder",1,"NIOSingleStepByteToMessageDecoder",25]],"g":[["Decoder",0,0]],"d":"Initialize a `NIOSingleStepByteToMessageProcessor`.\n\n- parameters:\n    - decoder: The `NIOSingleStepByteToMessageDecoder` to decode the bytes into message.\n    - maximumBufferSize: The maximum number of bytes to aggregate in-memory."},{"p":["NIOAny","init(_:)"],"f":[["init",10],["<",17],["T",0],[">(",17],["_",1],[" ",17],["value",2],[": ",17],["T",18],[")",17]],"s":[["init",10],["<",17],["T",0],[">(",17],["T",18],[")",17]],"g":[["T",0,0]],"d":"Wrap a value in a `NIOAny`. In most cases you should not create a `NIOAny` directly using this constructor.\nThe abstraction that accepts values of type `NIOAny` must also provide a mechanism to do the wrapping. An\nexample is a `ChannelInboundHandler` which provides `self.wrapInboundOut(aValueOfTypeInboundOut)`."},{"p":["IOError","init(errnoCode:reason:)"],"f":[["init",10],["(",17],["errnoCode",1],[" ",17],["code",2],[": ",17],["CInt",18,1378],[", ",17],["reason",1],[": ",17],["String",18,1165],[")",17]],"s":[["init",10],["(",17],["errnoCode",1],[": ",17],["CInt",18],[", ",17],["reason",1],[": ",17],["String",18],[")",17]],"d":"Creates a new `IOError``\n\n- parameters:\n    - errorCode: the `errno` that was set for the operation.\n    - reason: the actual reason (in an human-readable form)."},{"p":["IOError","init(errnoCode:function:)"],"f":[["init",10],["(",17],["errnoCode",1],[" ",17],["code",2],[": ",17],["CInt",18,1378],[", ",17],["function",1],[": ",17],["StaticString",18,1359],[")",17]],"s":[["init",10],["(",17],["errnoCode",1],[": ",17],["CInt",18],[", ",17],["function",1],[": ",17],["StaticString",18],[")",17]],"a":{"a":{"d":true,"r":"init(errnoCode:reason:)"}},"d":"Creates a new `IOError``\n\n- parameters:\n    - errorCode: the `errno` that was set for the operation.\n    - function: The function the error happened in, the human readable description will be generated automatically when needed."},{"p":["Scheduled","init(promise:cancellationTask:)"],"f":[["init",10],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["T",18],[">, ",17],["cancellationTask",1],[": ",17],["@escaping",12],[" () -> ",17],["Void",18,1379],[")",17]],"s":[["init",10],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["T",18],[">, ",17],["cancellationTask",1],[": () -> ",17],["Void",18],[")",17]],"g":[["T",0,0]]},{"p":["ByteBufferView","subscript(_:)"],"f":[["subscript",10],["(",17],["range",2],[": ",17],["Range",18,1338],["<",17],["ByteBufferView",18,74],[".",17],["Index",18,1036],[">) -> ",17],["ByteBufferView",18,74],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["Range",18],["<",17],["ByteBufferView",18],[".",17],["Index",18],[">) -> ",17],["ByteBufferView",18]]},{"p":["ByteBufferView","subscript(_:)"],"f":[["subscript",10],["(",17],["position",2],[": ",17],["ByteBufferView",18,74],[".",17],["Index",18,1036],[") -> ",17],["UInt8",18,1384],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["ByteBufferView",18],[".",17],["Index",18],[") -> ",17],["UInt8",18]]},{"p":["CircularBuffer","subscript(offset:)"],"f":[["subscript",10],["(",17],["offset",1],[" ",17],["offset",2],[": ",17],["Int",18,1227],[") -> ",17],["Element",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["offset",1],[" _: ",17],["Int",18],[") -> ",17],["Element",18]],"g":[["Element",0,0]],"d":"Return element `offset` from first element.\n\n*O(1)*"},{"p":["CircularBuffer","subscript(_:)"],"f":[["subscript",10],["(",17],["bounds",2],[": ",17],["Range",18,1338],["<",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[">) -> ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["SubSequence",18,1051],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["Range",18],["<",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[">) -> ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["SubSequence",18]],"g":[["Element",0,0]]},{"p":["CircularBuffer","subscript(_:)"],"f":[["subscript",10],["(",17],["position",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[") -> ",17],["Element",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Element",18]],"g":[["Element",0,0]],"d":"Accesses the element at the specified index.\n\nYou can subscript `CircularBuffer` with any valid index other than the\n`CircularBuffer`'s end index. The end index refers to the position one\npast the last element of a collection, so it doesn't correspond with an\nelement.\n\n- Parameter position: The position of the element to access. `position`\n  must be a valid index of the collection that is not equal to the\n  `endIndex` property.\n\n- Complexity: O(1)"},{"p":["MarkedCircularBuffer","subscript(_:)"],"f":[["subscript",10],["(",17],["bounds",2],[": ",17],["Range",18,1338],["<",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[">) -> ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["SubSequence",18,1077],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["Range",18],["<",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[">) -> ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["SubSequence",18]],"g":[["Element",0,0]]},{"p":["MarkedCircularBuffer","subscript(_:)"],"f":[["subscript",10],["(",17],["index",2],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[") -> ",17],["Element",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Element",18]],"g":[["Element",0,0]],"d":"Retrieves the element at the given index from the buffer, without removing it."},{"p":["ByteBuffer","CopyBytesError","unreadableSourceBytes"],"f":[["static",12],[" ",17],["let",12],[" ",17],["unreadableSourceBytes",7],[": ",17],["ByteBuffer",18,58],[".",17],["CopyBytesError",18,59]],"s":[["static",12],[" ",17],["let",12],[" ",17],["unreadableSourceBytes",7],[": ",17],["ByteBuffer",18],[".",17],["CopyBytesError",18]],"d":"The bytes to copy are not readable."},{"p":["ByteBuffer","CopyBytesError","negativeLength"],"f":[["static",12],[" ",17],["let",12],[" ",17],["negativeLength",7],[": ",17],["ByteBuffer",18,58],[".",17],["CopyBytesError",18,59]],"s":[["static",12],[" ",17],["let",12],[" ",17],["negativeLength",7],[": ",17],["ByteBuffer",18],[".",17],["CopyBytesError",18]],"d":"The length of the bytes to copy was negative."},{"p":["ByteBuffer","LengthPrefixError","messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat"],"f":[["static",12],[" ",17],["let",12],[" ",17],["messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat",7],[": ",17],["ByteBuffer",18,58],[".",17],["LengthPrefixError",18,60]],"s":[["static",12],[" ",17],["let",12],[" ",17],["messageLengthDoesNotFitExactlyIntoRequiredIntegerFormat",7],[": ",17],["ByteBuffer",18],[".",17],["LengthPrefixError",18]]},{"p":["ByteBuffer","LengthPrefixError","messageCouldNotBeReadSuccessfully"],"f":[["static",12],[" ",17],["let",12],[" ",17],["messageCouldNotBeReadSuccessfully",7],[": ",17],["ByteBuffer",18,58],[".",17],["LengthPrefixError",18,60]],"s":[["static",12],[" ",17],["let",12],[" ",17],["messageCouldNotBeReadSuccessfully",7],[": ",17],["ByteBuffer",18],[".",17],["LengthPrefixError",18]]},{"p":["Endianness","host"],"f":[["static",12],[" ",17],["let",12],[" ",17],["host",7],[": ",17],["Endianness",18,38]],"s":[["static",12],[" ",17],["let",12],[" ",17],["host",7],[": ",17],["Endianness",18]],"d":"The endianness of the machine running this program."},{"p":["TimeAmount","zero"],"f":[["static",12],[" ",17],["var",12],[" ",17],["zero",7],[": ",17],["TimeAmount",18,62],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["zero",7],[": ",17],["TimeAmount",18]],"d":"The zero value for `TimeAmount`."},{"p":["NIODeadline","distantPast"],"f":[["static",12],[" ",17],["let",12],[" ",17],["distantPast",7],[": ",17],["NIODeadline",18,63]],"s":[["static",12],[" ",17],["let",12],[" ",17],["distantPast",7],[": ",17],["NIODeadline",18]]},{"p":["NIODeadline","distantFuture"],"f":[["static",12],[" ",17],["let",12],[" ",17],["distantFuture",7],[": ",17],["NIODeadline",18,63]],"s":[["static",12],[" ",17],["let",12],[" ",17],["distantFuture",7],[": ",17],["NIODeadline",18]]},{"p":["NIOBSDSocket","OptionLevel","ip"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ip",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ip",7],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18]]},{"p":["NIOBSDSocket","OptionLevel","tcp"],"f":[["static",12],[" ",17],["let",12],[" ",17],["tcp",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64]],"s":[["static",12],[" ",17],["let",12],[" ",17],["tcp",7],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18]]},{"p":["NIOBSDSocket","OptionLevel","ipv6"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ipv6",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ipv6",7],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18]]},{"p":["NIOBSDSocket","OptionLevel","socket"],"f":[["static",12],[" ",17],["let",12],[" ",17],["socket",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64]],"s":[["static",12],[" ",17],["let",12],[" ",17],["socket",7],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18]],"d":"Socket options that apply to all sockets."},{"p":["NIOBSDSocket","AddressFamily","inet"],"f":[["static",12],[" ",17],["let",12],[" ",17],["inet",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["AddressFamily",18,65]],"s":[["static",12],[" ",17],["let",12],[" ",17],["inet",7],[": ",17],["NIOBSDSocket",18],[".",17],["AddressFamily",18]],"d":"Address for IP version 4."},{"p":["NIOBSDSocket","AddressFamily","unix"],"f":[["static",12],[" ",17],["let",12],[" ",17],["unix",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["AddressFamily",18,65]],"s":[["static",12],[" ",17],["let",12],[" ",17],["unix",7],[": ",17],["NIOBSDSocket",18],[".",17],["AddressFamily",18]],"d":"Unix local to host address."},{"p":["NIOBSDSocket","AddressFamily","inet6"],"f":[["static",12],[" ",17],["let",12],[" ",17],["inet6",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["AddressFamily",18,65]],"s":[["static",12],[" ",17],["let",12],[" ",17],["inet6",7],[": ",17],["NIOBSDSocket",18],[".",17],["AddressFamily",18]],"d":"Address for IP version 6."},{"p":["NIOBSDSocket","ProtocolFamily","inet"],"f":[["static",12],[" ",17],["let",12],[" ",17],["inet",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["ProtocolFamily",18,66]],"s":[["static",12],[" ",17],["let",12],[" ",17],["inet",7],[": ",17],["NIOBSDSocket",18],[".",17],["ProtocolFamily",18]],"d":"IP network 4 protocol."},{"p":["NIOBSDSocket","ProtocolFamily","unix"],"f":[["static",12],[" ",17],["let",12],[" ",17],["unix",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["ProtocolFamily",18,66]],"s":[["static",12],[" ",17],["let",12],[" ",17],["unix",7],[": ",17],["NIOBSDSocket",18],[".",17],["ProtocolFamily",18]],"d":"UNIX local to the host."},{"p":["NIOBSDSocket","ProtocolFamily","inet6"],"f":[["static",12],[" ",17],["let",12],[" ",17],["inet6",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["ProtocolFamily",18,66]],"s":[["static",12],[" ",17],["let",12],[" ",17],["inet6",7],[": ",17],["NIOBSDSocket",18],[".",17],["ProtocolFamily",18]],"d":"IP network 6 protocol."},{"p":["NIOBSDSocket","ProtocolFamily","local"],"f":[["static",12],[" ",17],["let",12],[" ",17],["local",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["ProtocolFamily",18,66]],"s":[["static",12],[" ",17],["let",12],[" ",17],["local",7],[": ",17],["NIOBSDSocket",18],[".",17],["ProtocolFamily",18]],"d":"UNIX local to the host, alias for `PF_UNIX` (`.unix`)"},{"p":["NIOBSDSocket","Option","ipv6_v6only"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_v6only",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_v6only",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Indicates if a socket created for the `AF_INET6` address family is\nrestricted to IPv6 only."},{"p":["NIOBSDSocket","Option","so_rcvtimeo"],"f":[["static",12],[" ",17],["let",12],[" ",17],["so_rcvtimeo",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["so_rcvtimeo",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Specifies the receive timeout."},{"p":["NIOBSDSocket","Option","tcp_nodelay"],"f":[["static",12],[" ",17],["let",12],[" ",17],["tcp_nodelay",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["tcp_nodelay",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Disables the Nagle algorithm for send coalescing."},{"p":["NIOBSDSocket","Option","so_keepalive"],"f":[["static",12],[" ",17],["let",12],[" ",17],["so_keepalive",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["so_keepalive",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Use keep-alives."},{"p":["NIOBSDSocket","Option","so_reuseaddr"],"f":[["static",12],[" ",17],["let",12],[" ",17],["so_reuseaddr",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["so_reuseaddr",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Allows the socket to be bound to an address that is already in use."},{"p":["NIOBSDSocket","Option","so_timestamp"],"f":[["static",12],[" ",17],["let",12],[" ",17],["so_timestamp",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["so_timestamp",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Indicate when to generate timestamps."},{"p":["NIOBSDSocket","Option","ip_multicast_if"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ip_multicast_if",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ip_multicast_if",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Set the interface for outgoing multicast packets."},{"p":["NIOBSDSocket","Option","ipv6_join_group"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_join_group",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_join_group",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Add an IPv6 group membership."},{"p":["NIOBSDSocket","Option","ip_multicast_ttl"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ip_multicast_ttl",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ip_multicast_ttl",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Control multicast time-to-live."},{"p":["NIOBSDSocket","Option","ipv6_leave_group"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_leave_group",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_leave_group",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Drop an IPv6 group membership."},{"p":["NIOBSDSocket","Option","ip_add_membership"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ip_add_membership",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ip_add_membership",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Add a multicast group membership."},{"p":["NIOBSDSocket","Option","ip_multicast_loop"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ip_multicast_loop",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ip_multicast_loop",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Control multicast loopback."},{"p":["NIOBSDSocket","Option","ipv6_multicast_if"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_multicast_if",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_multicast_if",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Set the interface for outgoing multicast packets."},{"p":["NIOBSDSocket","Option","ip_drop_membership"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ip_drop_membership",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ip_drop_membership",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Drop a multicast group membership."},{"p":["NIOBSDSocket","Option","ipv6_multicast_hops"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_multicast_hops",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_multicast_hops",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Specify the maximum number of router hops for an IPv6 packet."},{"p":["NIOBSDSocket","Option","ipv6_multicast_loop"],"f":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_multicast_loop",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["ipv6_multicast_loop",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Control multicast loopback."},{"p":["NIOBSDSocket","Option","so_error"],"f":[["static",12],[" ",17],["let",12],[" ",17],["so_error",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["so_error",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Get the error status and clear."},{"p":["NIOBSDSocket","Option","tcp_info"],"f":[["static",12],[" ",17],["let",12],[" ",17],["tcp_info",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["tcp_info",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Get information about the TCP connection."},{"p":["NIOBSDSocket","Option","so_linger"],"f":[["static",12],[" ",17],["let",12],[" ",17],["so_linger",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["so_linger",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Linger on close if unsent data is present."},{"p":["NIOBSDSocket","Option","so_rcvbuf"],"f":[["static",12],[" ",17],["let",12],[" ",17],["so_rcvbuf",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["static",12],[" ",17],["let",12],[" ",17],["so_rcvbuf",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]],"d":"Specifies the total per-socket buffer space reserved for receives."},{"p":["NIOFileHandle","Mode","read"],"f":[["static",12],[" ",17],["let",12],[" ",17],["read",7],[": ",17],["NIOFileHandle",18,119],[".",17],["Mode",18,68]],"s":[["static",12],[" ",17],["let",12],[" ",17],["read",7],[": ",17],["NIOFileHandle",18],[".",17],["Mode",18]],"d":"Opens file for reading"},{"p":["NIOFileHandle","Mode","write"],"f":[["static",12],[" ",17],["let",12],[" ",17],["write",7],[": ",17],["NIOFileHandle",18,119],[".",17],["Mode",18,68]],"s":[["static",12],[" ",17],["let",12],[" ",17],["write",7],[": ",17],["NIOFileHandle",18],[".",17],["Mode",18]],"d":"Opens file for writing"},{"p":["NIOFileHandle","Flags","default"],"f":[["static",12],[" ",17],["let",12],[" ",17],["`default`",7],[": ",17],["NIOFileHandle",18,119],[".",17],["Flags",18,69]],"s":[["static",12],[" ",17],["let",12],[" ",17],["`default`",7],[": ",17],["NIOFileHandle",18],[".",17],["Flags",18]]},{"p":["ChannelOptions","socketOption"],"f":[["static",12],[" ",17],["let",12],[" ",17],["socketOption",7],[": (",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67],[") -> ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["SocketOption",18,78]],"s":[["static",12],[" ",17],["let",12],[" ",17],["socketOption",7],[": (",17],["NIOBSDSocket",18],[".",17],["Option",18],[") -> ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["SocketOption",18]],"d":"- seealso: `SocketOption`."},{"p":["ChannelOptions","recvAllocator"],"f":[["static",12],[" ",17],["let",12],[" ",17],["recvAllocator",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["RecvAllocatorOption",18,84]],"s":[["static",12],[" ",17],["let",12],[" ",17],["recvAllocator",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["RecvAllocatorOption",18]],"d":"- seealso: `RecvAllocatorOption`."},{"p":["ChannelOptions","connectTimeout"],"f":[["static",12],[" ",17],["let",12],[" ",17],["connectTimeout",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["ConnectTimeoutOption",18,85]],"s":[["static",12],[" ",17],["let",12],[" ",17],["connectTimeout",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["ConnectTimeoutOption",18]],"d":"- seealso: `ConnectTimeoutOption`."},{"p":["ChannelOptions","receivePacketInfo"],"f":[["static",12],[" ",17],["let",12],[" ",17],["receivePacketInfo",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["ReceivePacketInfo",18,83]],"s":[["static",12],[" ",17],["let",12],[" ",17],["receivePacketInfo",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["ReceivePacketInfo",18]],"d":"- seealso: `ReceivePacketInfo`"},{"p":["ChannelOptions","maxMessagesPerRead"],"f":[["static",12],[" ",17],["let",12],[" ",17],["maxMessagesPerRead",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["MaxMessagesPerReadOption",18,87]],"s":[["static",12],[" ",17],["let",12],[" ",17],["maxMessagesPerRead",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["MaxMessagesPerReadOption",18]],"d":"- seealso: `MaxMessagesPerReadOption`."},{"p":["ChannelOptions","TCPConvenienceOption","disableAutoRead"],"f":[["static",12],[" ",17],["let",12],[" ",17],["disableAutoRead",7],[": ",17],["ChannelOptions",18,75],[".",17],["TCPConvenienceOption",18,77]],"s":[["static",12],[" ",17],["let",12],[" ",17],["disableAutoRead",7],[": ",17],["ChannelOptions",18],[".",17],["TCPConvenienceOption",18]],"d":"The user will manually call `Channel.read` once all the data is read from the transport."},{"p":["ChannelOptions","TCPConvenienceOption","allowRemoteHalfClosure"],"f":[["static",12],[" ",17],["let",12],[" ",17],["allowRemoteHalfClosure",7],[": ",17],["ChannelOptions",18,75],[".",17],["TCPConvenienceOption",18,77]],"s":[["static",12],[" ",17],["let",12],[" ",17],["allowRemoteHalfClosure",7],[": ",17],["ChannelOptions",18],[".",17],["TCPConvenienceOption",18]],"d":"Allows users to configure whether the `Channel` will close itself when its remote\npeer shuts down its send stream, or whether it will remain open. If set to `false` (the default), the `Channel`\nwill be closed automatically if the remote peer shuts down its send stream. If set to true, the `Channel` will\nnot be closed: instead, a `ChannelEvent.inboundClosed` user event will be sent on the `ChannelPipeline`,\nand no more data will be received."},{"p":["ChannelOptions","TCPConvenienceOption","allowLocalEndpointReuse"],"f":[["static",12],[" ",17],["let",12],[" ",17],["allowLocalEndpointReuse",7],[": ",17],["ChannelOptions",18,75],[".",17],["TCPConvenienceOption",18,77]],"s":[["static",12],[" ",17],["let",12],[" ",17],["allowLocalEndpointReuse",7],[": ",17],["ChannelOptions",18],[".",17],["TCPConvenienceOption",18]],"d":"Allow immediately reusing a local address."},{"p":["ChannelOptions","writeBufferWaterMark"],"f":[["static",12],[" ",17],["let",12],[" ",17],["writeBufferWaterMark",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["WriteBufferWaterMarkOption",18,88]],"s":[["static",12],[" ",17],["let",12],[" ",17],["writeBufferWaterMark",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["WriteBufferWaterMarkOption",18]],"d":"- seealso: `WriteBufferWaterMarkOption`."},{"p":["ChannelOptions","allowRemoteHalfClosure"],"f":[["static",12],[" ",17],["let",12],[" ",17],["allowRemoteHalfClosure",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["AllowRemoteHalfClosureOption",18,89]],"s":[["static",12],[" ",17],["let",12],[" ",17],["allowRemoteHalfClosure",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["AllowRemoteHalfClosureOption",18]],"d":"- seealso: `AllowRemoteHalfClosureOption`."},{"p":["ChannelOptions","datagramVectorReadMessageCount"],"f":[["static",12],[" ",17],["let",12],[" ",17],["datagramVectorReadMessageCount",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["DatagramVectorReadMessageCountOption",18,90]],"s":[["static",12],[" ",17],["let",12],[" ",17],["datagramVectorReadMessageCount",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["DatagramVectorReadMessageCountOption",18]],"d":"- seealso: `DatagramVectorReadMessageCountOption`"},{"p":["ChannelOptions","explicitCongestionNotification"],"f":[["static",12],[" ",17],["let",12],[" ",17],["explicitCongestionNotification",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["ExplicitCongestionNotificationsOption",18,91]],"s":[["static",12],[" ",17],["let",12],[" ",17],["explicitCongestionNotification",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["ExplicitCongestionNotificationsOption",18]],"d":"- seealso: `ExplicitCongestionNotificationsOption`"},{"p":["ChannelOptions","socket"],"f":[["static",12],[" ",17],["let",12],[" ",17],["socket",7],[": (",17],["SocketOptionLevel",18,1063],[", ",17],["SocketOptionName",18,1061],[") -> ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["SocketOption",18,78]],"s":[["static",12],[" ",17],["let",12],[" ",17],["socket",7],[": (",17],["SocketOptionLevel",18],[", ",17],["SocketOptionName",18],[") -> ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["SocketOption",18]]},{"p":["ChannelOptions","backlog"],"f":[["static",12],[" ",17],["let",12],[" ",17],["backlog",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["BacklogOption",18,79]],"s":[["static",12],[" ",17],["let",12],[" ",17],["backlog",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["BacklogOption",18]],"d":"- seealso: `BacklogOption`."},{"p":["ChannelOptions","autoRead"],"f":[["static",12],[" ",17],["let",12],[" ",17],["autoRead",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["AutoReadOption",18,80]],"s":[["static",12],[" ",17],["let",12],[" ",17],["autoRead",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["AutoReadOption",18]],"d":"- seealso: `AutoReadOption`."},{"p":["ChannelOptions","allocator"],"f":[["static",12],[" ",17],["let",12],[" ",17],["allocator",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["AllocatorOption",18,81]],"s":[["static",12],[" ",17],["let",12],[" ",17],["allocator",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["AllocatorOption",18]],"d":"- seealso: `AllocatorOption`."},{"p":["ChannelOptions","tcpOption"],"f":[["static",12],[" ",17],["let",12],[" ",17],["tcpOption",7],[": (",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67],[") -> ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["SocketOption",18,78]],"s":[["static",12],[" ",17],["let",12],[" ",17],["tcpOption",7],[": (",17],["NIOBSDSocket",18],[".",17],["Option",18],[") -> ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["SocketOption",18]],"d":"- seealso: `SocketOption`."},{"p":["ChannelOptions","writeSpin"],"f":[["static",12],[" ",17],["let",12],[" ",17],["writeSpin",7],[": ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["WriteSpinOption",18,82]],"s":[["static",12],[" ",17],["let",12],[" ",17],["writeSpin",7],[": ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["WriteSpinOption",18]],"d":"- seealso: `WriteSpinOption`."},{"p":["System","coreCount"],"f":[["static",12],[" ",17],["var",12],[" ",17],["coreCount",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["static",12],[" ",17],["var",12],[" ",17],["coreCount",7],[": ",17],["Int",18]],"d":"A utility function that returns an estimate of the number of *logical* cores\non the system.\n\nThis value can be used to help provide an estimate of how many threads to use with\nthe `MultiThreadedEventLoopGroup`. The exact ratio between this number and the number\nof threads to use is a matter for the programmer, and can be determined based on the\nspecific execution behaviour of the program.\n\n- returns: The logical core count on the system."},{"p":["ByteBuffer","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"d":"A `String` describing this `ByteBuffer`. Example:\n\n    ByteBuffer { readerIndex: 0, writerIndex: 4, readableBytes: 4, capacity: 512, storageCapacity: 1024, slice: 256..<768, storage: 0x0000000103001000 (1024 bytes)}\n\nThe format of the description is not API.\n\n- returns: A description of this `ByteBuffer`."},{"p":["ByteBuffer","readerIndex"],"f":[["var",12],[" ",17],["readerIndex",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["readerIndex",7],[": ",17],["Int",18]],"d":"The reader index or the number of bytes previously read from this `ByteBuffer`. `readerIndex` is `0` for a\nnewly allocated `ByteBuffer`."},{"p":["ByteBuffer","writerIndex"],"f":[["var",12],[" ",17],["writerIndex",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["writerIndex",7],[": ",17],["Int",18]],"d":"The write index or the number of bytes previously written to this `ByteBuffer`. `writerIndex` is `0` for a\nnewly allocated `ByteBuffer`."},{"p":["ByteBuffer","readableBytes"],"f":[["var",12],[" ",17],["readableBytes",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["readableBytes",7],[": ",17],["Int",18]],"d":"The number of bytes readable (`readableBytes` = `writerIndex` - `readerIndex`)."},{"p":["ByteBuffer","writableBytes"],"f":[["var",12],[" ",17],["writableBytes",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["writableBytes",7],[": ",17],["Int",18]],"d":"The number of bytes writable until `ByteBuffer` will need to grow its underlying storage which will likely\ntrigger a copy of the bytes."},{"p":["ByteBuffer","CopyBytesError","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]]},{"p":["ByteBuffer","storageCapacity"],"f":[["var",12],[" ",17],["storageCapacity",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["storageCapacity",7],[": ",17],["Int",18]],"d":"The current capacity of the underlying storage of this `ByteBuffer`.\nA COW slice of the buffer (e.g. readSlice(length: x)) will posses the same storageCapacity as the original\nbuffer until new data is written."},{"p":["ByteBuffer","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]],"d":"A `String` describing this `ByteBuffer` with some portion of the readable bytes dumped too. Example:\n\n    ByteBuffer { readerIndex: 0, writerIndex: 4, readableBytes: 4, capacity: 512, slice: 256..<768, storage: 0x0000000103001000 (1024 bytes)}\n    readable bytes (max 1k): [ 00 01 02 03 ]\n\nThe format of the description is not API.\n\n- returns: A description of this `ByteBuffer` useful for debugging."},{"p":["ByteBuffer","readableBytesView"],"f":[["var",12],[" ",17],["readableBytesView",7],[": ",17],["ByteBufferView",18,74],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["readableBytesView",7],[": ",17],["ByteBufferView",18]],"d":"A view into the readable bytes of the `ByteBuffer`."},{"p":["ByteBuffer","capacity"],"f":[["var",12],[" ",17],["capacity",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["capacity",7],[": ",17],["Int",18]],"d":"The current capacity of the storage of this `ByteBuffer`, this is not constant and does _not_ signify the number\nof bytes that have been written to this `ByteBuffer`."},{"p":["FileRegion","fileHandle"],"f":[["let",12],[" ",17],["fileHandle",7],[": ",17],["NIOFileHandle",18,119]],"s":[["let",12],[" ",17],["fileHandle",7],[": ",17],["NIOFileHandle",18]],"d":"The `NIOFileHandle` that is used by this `FileRegion`."},{"p":["FileRegion","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["FileRegion","readerIndex"],"f":[["var",12],[" ",17],["readerIndex",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["readerIndex",7],[": ",17],["Int",18]],"d":"The current reader index of this `FileRegion`"},{"p":["FileRegion","readableBytes"],"f":[["var",12],[" ",17],["readableBytes",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["readableBytes",7],[": ",17],["Int",18]],"d":"The number of readable bytes within this FileRegion (taking the `readerIndex` and `endIndex` into account)."},{"p":["FileRegion","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18]],"d":"The end index of this `FileRegion`."},{"p":["TimeAmount","nanoseconds"],"f":[["let",12],[" ",17],["nanoseconds",7],[": ",17],["Int64",18,1382]],"s":[["let",12],[" ",17],["nanoseconds",7],[": ",17],["Int64",18]],"d":"The nanoseconds representation of the `TimeAmount`."},{"p":["NIODeadline","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["NIODeadline","uptimeNanoseconds"],"f":[["var",12],[" ",17],["uptimeNanoseconds",7],[": ",17],["UInt64",18,1388],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["uptimeNanoseconds",7],[": ",17],["UInt64",18]],"d":"The nanoseconds since boot representation of the `NIODeadline`."},{"p":["NIOBSDSocket","OptionLevel","rawValue"],"f":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64],[".",17],["RawValue",18,1027]],"s":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18],[".",17],["RawValue",18]]},{"p":["NIOBSDSocket","AddressFamily","rawValue"],"f":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["AddressFamily",18,65],[".",17],["RawValue",18,1028]],"s":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18],[".",17],["AddressFamily",18],[".",17],["RawValue",18]]},{"p":["NIOBSDSocket","ProtocolFamily","rawValue"],"f":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["ProtocolFamily",18,66],[".",17],["RawValue",18,1029]],"s":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18],[".",17],["ProtocolFamily",18],[".",17],["RawValue",18]]},{"p":["NIOBSDSocket","Option","rawValue"],"f":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67],[".",17],["RawValue",18,1031]],"s":[["var",12],[" ",17],["rawValue",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18],[".",17],["RawValue",18]]},{"p":["NIOFileHandle","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["NIOFileHandle","Mode","rawValue"],"f":[["let",12],[" ",17],["rawValue",7],[": ",17],["UInt8",18,1384]],"s":[["let",12],[" ",17],["rawValue",7],[": ",17],["UInt8",18]]},{"p":["NIOFileHandle","isOpen"],"f":[["var",12],[" ",17],["isOpen",7],[": ",17],["Bool",18,1224],[" { get }",17]],"s":[["var",12],[" ",17],["isOpen",7],[": ",17],["Bool",18]]},{"p":["NIOPacketInfo","interfaceIndex"],"f":[["var",12],[" ",17],["interfaceIndex",7],[": ",17],["Int",18,1227]],"s":[["var",12],[" ",17],["interfaceIndex",7],[": ",17],["Int",18]]},{"p":["NIOPacketInfo","destinationAddress"],"f":[["var",12],[" ",17],["destinationAddress",7],[": ",17],["SocketAddress",18,43]],"s":[["var",12],[" ",17],["destinationAddress",7],[": ",17],["SocketAddress",18]]},{"p":["SocketAddress","ipAddress"],"f":[["var",12],[" ",17],["ipAddress",7],[": ",17],["String",18,1165],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["ipAddress",7],[": ",17],["String",18],["?",17]],"d":"Get the IP address as a string"},{"p":["SocketAddress","IPv4Address","host"],"f":[["var",12],[" ",17],["host",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["host",7],[": ",17],["String",18]],"d":"The host this address is for, if known."},{"p":["SocketAddress","IPv4Address","address"],"f":[["var",12],[" ",17],["address",7],[": ",17],["sockaddr_in",18,1095],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["address",7],[": ",17],["sockaddr_in",18]],"d":"The libc socket address for an IPv4 address."},{"p":["SocketAddress","IPv6Address","host"],"f":[["var",12],[" ",17],["host",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["host",7],[": ",17],["String",18]],"d":"The host this address is for, if known."},{"p":["SocketAddress","IPv6Address","address"],"f":[["var",12],[" ",17],["address",7],[": ",17],["sockaddr_in6",18,1096],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["address",7],[": ",17],["sockaddr_in6",18]],"d":"The libc socket address for an IPv6 address."},{"p":["SocketAddress","UnixSocketAddress","address"],"f":[["var",12],[" ",17],["address",7],[": ",17],["sockaddr_un",18,1097],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["address",7],[": ",17],["sockaddr_un",18]],"d":"The libc socket address for a Unix Domain Socket."},{"p":["SocketAddress","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"d":"A human-readable description of this `SocketAddress`. Mostly useful for logging."},{"p":["SocketAddress","isMulticast"],"f":[["var",12],[" ",17],["isMulticast",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isMulticast",7],[": ",17],["Bool",18]],"d":"Whether this `SocketAddress` corresponds to a multicast address."},{"p":["SocketAddress","protocolFamily"],"f":[["var",12],[" ",17],["protocolFamily",7],[": ",17],["Int32",18,1381],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["protocolFamily",7],[": ",17],["Int32",18]],"a":{"a":{"d":true,"r":"SocketAddress.protocol"}}},{"p":["SocketAddress","port"],"f":[["var",12],[" ",17],["port",7],[": ",17],["Int",18,1227],["? { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["port",7],[": ",17],["Int",18],["?",17]],"d":"Get and set the port associated with the address, if defined.\nWhen setting to `nil` the port will default to `0` for compatible sockets. The rationale for this is that both `nil` and `0` can\nbe interpreted as \"no preference\".\nSetting a non-nil value for a unix domain socket is invalid and will result in a fatal error."},{"p":["SocketAddress","pathname"],"f":[["var",12],[" ",17],["pathname",7],[": ",17],["String",18,1165],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["pathname",7],[": ",17],["String",18],["?",17]],"d":"Get the pathname of a UNIX domain socket as a string"},{"p":["SocketAddress","protocol"],"f":[["var",12],[" ",17],["`protocol`",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["ProtocolFamily",18,66],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["`protocol`",7],[": ",17],["NIOBSDSocket",18],[".",17],["ProtocolFamily",18]],"d":"Returns the protocol family as defined in `man 2 socket` of this `SocketAddress`."},{"p":["ByteBufferView","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["ByteBufferView",18,74],[".",17],["Index",18,1036],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["ByteBufferView",18],[".",17],["Index",18]]},{"p":["ByteBufferView","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]]},{"p":["ByteBufferView","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["ByteBufferView",18,74],[".",17],["Index",18,1036],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["ByteBufferView",18],[".",17],["Index",18]]},{"p":["ChannelOptions","Types","SocketOption","optionName"],"f":[["var",12],[" ",17],["optionName",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67]],"s":[["var",12],[" ",17],["optionName",7],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18]]},{"p":["ChannelOptions","Types","SocketOption","optionLevel"],"f":[["var",12],[" ",17],["optionLevel",7],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64]],"s":[["var",12],[" ",17],["optionLevel",7],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18]]},{"p":["ChannelOptions","Types","SocketOption","name"],"f":[["var",12],[" ",17],["name",7],[": ",17],["SocketOptionName",18,1061],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["name",7],[": ",17],["SocketOptionName",18]]},{"p":["ChannelOptions","Types","SocketOption","level"],"f":[["var",12],[" ",17],["level",7],[": ",17],["SocketOptionLevel",18,1063],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["level",7],[": ",17],["SocketOptionLevel",18]]},{"p":["ChannelOptions","Types","WriteBufferWaterMark","low"],"f":[["let",12],[" ",17],["low",7],[": ",17],["Int",18,1227]],"s":[["let",12],[" ",17],["low",7],[": ",17],["Int",18]],"d":"The low mark setting for a `Channel`.\n\nWhen the amount of buffered bytes in the `Channel`s outbound buffer drops below this value the `Channel` will be\nmarked as writable again (after it was non-writable)."},{"p":["ChannelOptions","Types","WriteBufferWaterMark","high"],"f":[["let",12],[" ",17],["high",7],[": ",17],["Int",18,1227]],"s":[["let",12],[" ",17],["high",7],[": ",17],["Int",18]],"d":"The high mark setting for a `Channel`.\n\nWhen the amount of buffered bytes in the `Channel`s outbound exceeds this value the `Channel` will be\nmarked as non-writable. It will be marked as writable again once the amount of buffered bytes drops below `low`."},{"p":["ChannelOptions","Types","ConvenienceOptionValue","isSet"],"f":[["var",12],[" ",17],["isSet",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isSet",7],[": ",17],["Bool",18]],"e":[["ValueType",2,"()"]],"d":"Convenience method working with bool options as bool values for set."},{"p":["CircularBuffer","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"d":"The position of the first element in a nonempty `CircularBuffer`.\n\nIf the `CircularBuffer` is empty, `startIndex` is equal to `endIndex`."},{"p":["CircularBuffer","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"d":"Returns a human readable description of the ring."},{"p":["CircularBuffer","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]],"d":"Returns the number of element in the ring."},{"p":["CircularBuffer","first"],"f":[["var",12],[" ",17],["first",7],[": ",17],["Element",18],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["first",7],[": ",17],["Element",18],["?",17]],"d":"The first `Element` of the `CircularBuffer` (or `nil` if empty)."},{"p":["CircularBuffer","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"d":"Returns whether the ring is empty."},{"p":["CircularBuffer","capacity"],"f":[["var",12],[" ",17],["capacity",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["capacity",7],[": ",17],["Int",18]],"d":"The total number of elements that the ring can contain without allocating new storage."},{"p":["CircularBuffer","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"d":"The `CircularBuffer`'s \"past the end\" position---that is, the position one\ngreater than the last valid subscript argument.\n\nWhen you need a range that includes the last element of a collection, use\nthe half-open range operator (`..<`) with `endIndex`. The `..<` operator\ncreates a range that doesn't include the upper bound, so it's always\nsafe to use with `endIndex`.\n\nIf the `CircularBuffer` is empty, `endIndex` is equal to `startIndex`."},{"p":["EventLoopError","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["EventLoopGroup","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["FileDescriptor","isOpen"],"f":[["var",12],[" ",17],["isOpen",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isOpen",7],[": ",17],["Bool",18]],"d":"`true` if this `FileDescriptor` is open (which means it was not closed yet)."},{"p":["ChannelPipeline","syncOperations"],"f":[["var",12],[" ",17],["syncOperations",7],[": ",17],["ChannelPipeline",18,120],[".",17],["SynchronousOperations",18,95],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["syncOperations",7],[": ",17],["ChannelPipeline",18],[".",17],["SynchronousOperations",18]],"d":"Returns a view of operations which can be performed synchronously on this pipeline. All\noperations **must** be called on the event loop."},{"p":["ChannelPipeline","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]]},{"p":["ChannelPipeline","SynchronousOperations","eventLoop"],"f":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18,28],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18]],"d":"The `EventLoop` of the `Channel` this synchronous operations view corresponds to."},{"p":["ChannelPipeline","eventLoop"],"f":[["let",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18,28]],"s":[["let",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18]],"d":"The `EventLoop` that is used by the underlying `Channel`."},{"p":["EventLoopFuture","eventLoop"],"f":[["let",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18,28]],"s":[["let",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18]],"d":"The `EventLoop` which is tied to the `EventLoopFuture` and is used to notify all registered callbacks."},{"p":["EventLoopPromise","futureResult"],"f":[["let",12],[" ",17],["futureResult",7],[": ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["let",12],[" ",17],["futureResult",7],[": ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"d":"The `EventLoopFuture` which is used by the `EventLoopPromise`. You can use it to add callbacks which are notified once the\n`EventLoopPromise` is completed."},{"p":["IdleStateHandler","allTimeout"],"f":[["let",12],[" ",17],["allTimeout",7],[": ",17],["TimeAmount",18,62],["?",17]],"s":[["let",12],[" ",17],["allTimeout",7],[": ",17],["TimeAmount",18],["?",17]]},{"p":["IdleStateHandler","readTimeout"],"f":[["let",12],[" ",17],["readTimeout",7],[": ",17],["TimeAmount",18,62],["?",17]],"s":[["let",12],[" ",17],["readTimeout",7],[": ",17],["TimeAmount",18],["?",17]]},{"p":["IdleStateHandler","writeTimeout"],"f":[["let",12],[" ",17],["writeTimeout",7],[": ",17],["TimeAmount",18,62],["?",17]],"s":[["let",12],[" ",17],["writeTimeout",7],[": ",17],["TimeAmount",18],["?",17]]},{"p":["NIONetworkDevice","interfaceIndex"],"f":[["var",12],[" ",17],["interfaceIndex",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["interfaceIndex",7],[": ",17],["Int",18]],"d":"The index of the interface, as provided by `if_nametoindex`."},{"p":["NIONetworkDevice","broadcastAddress"],"f":[["var",12],[" ",17],["broadcastAddress",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["broadcastAddress",7],[": ",17],["SocketAddress",18],["?",17]],"d":"The broadcast address associated with this socket interface, if it has one. Some\ninterfaces do not, especially those that have a `pointToPointDestinationAddress`."},{"p":["NIONetworkDevice","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]]},{"p":["NIONetworkDevice","multicastSupported"],"f":[["var",12],[" ",17],["multicastSupported",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["multicastSupported",7],[": ",17],["Bool",18]],"d":"If the Interface supports Multicast"},{"p":["NIONetworkDevice","pointToPointDestinationAddress"],"f":[["var",12],[" ",17],["pointToPointDestinationAddress",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["pointToPointDestinationAddress",7],[": ",17],["SocketAddress",18],["?",17]],"d":"The address of the peer on a point-to-point interface, if this is one. Some\ninterfaces do not have such an address: most of those have a `broadcastAddress`\ninstead."},{"p":["NIONetworkDevice","name"],"f":[["var",12],[" ",17],["name",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["name",7],[": ",17],["String",18]],"d":"The name of the network device."},{"p":["NIONetworkDevice","address"],"f":[["var",12],[" ",17],["address",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["address",7],[": ",17],["SocketAddress",18],["?",17]],"d":"The address associated with the given network device."},{"p":["NIONetworkDevice","netmask"],"f":[["var",12],[" ",17],["netmask",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["netmask",7],[": ",17],["SocketAddress",18],["?",17]],"d":"The netmask associated with this address, if any."},{"p":["AddressedEnvelope","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["AddressedEnvelope","remoteAddress"],"f":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18,43]],"s":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18]]},{"p":["AddressedEnvelope","data"],"f":[["var",12],[" ",17],["data",7],[": ",17],["DataType",18]],"s":[["var",12],[" ",17],["data",7],[": ",17],["DataType",18]]},{"p":["AddressedEnvelope","Metadata","packetInfo"],"f":[["var",12],[" ",17],["packetInfo",7],[": ",17],["NIOPacketInfo",18,70],["?",17]],"s":[["var",12],[" ",17],["packetInfo",7],[": ",17],["NIOPacketInfo",18],["?",17]]},{"p":["AddressedEnvelope","Metadata","ecnState"],"f":[["var",12],[" ",17],["ecnState",7],[": ",17],["NIOExplicitCongestionNotificationState",18,53]],"s":[["var",12],[" ",17],["ecnState",7],[": ",17],["NIOExplicitCongestionNotificationState",18]],"d":"Details of any congestion state."},{"p":["AddressedEnvelope","metadata"],"f":[["var",12],[" ",17],["metadata",7],[": ",17],["AddressedEnvelope",18,99],["<",17],["DataType",18],[">.",17],["Metadata",18,100],["?",17]],"s":[["var",12],[" ",17],["metadata",7],[": ",17],["AddressedEnvelope",18],["<",17],["DataType",18],[">.",17],["Metadata",18],["?",17]],"d":"Any metadata associated with this `AddressedEnvelope`"},{"p":["SocketAddressError","FailedToParseIPByteBuffer","address"],"f":[["var",12],[" ",17],["address",7],[": ",17],["ByteBuffer",18,58]],"s":[["var",12],[" ",17],["address",7],[": ",17],["ByteBuffer",18]]},{"p":["NIONetworkInterface","interfaceIndex"],"f":[["let",12],[" ",17],["interfaceIndex",7],[": ",17],["Int",18,1227]],"s":[["let",12],[" ",17],["interfaceIndex",7],[": ",17],["Int",18]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"The index of the interface, as provided by `if_nametoindex`."},{"p":["NIONetworkInterface","broadcastAddress"],"f":[["let",12],[" ",17],["broadcastAddress",7],[": ",17],["SocketAddress",18,43],["?",17]],"s":[["let",12],[" ",17],["broadcastAddress",7],[": ",17],["SocketAddress",18],["?",17]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"The broadcast address associated with this socket interface, if it has one. Some\ninterfaces do not, especially those that have a `pointToPointDestinationAddress`."},{"p":["NIONetworkInterface","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}}},{"p":["NIONetworkInterface","multicastSupported"],"f":[["let",12],[" ",17],["multicastSupported",7],[": ",17],["Bool",18,1224]],"s":[["let",12],[" ",17],["multicastSupported",7],[": ",17],["Bool",18]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"If the Interface supports Multicast"},{"p":["NIONetworkInterface","pointToPointDestinationAddress"],"f":[["let",12],[" ",17],["pointToPointDestinationAddress",7],[": ",17],["SocketAddress",18,43],["?",17]],"s":[["let",12],[" ",17],["pointToPointDestinationAddress",7],[": ",17],["SocketAddress",18],["?",17]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"The address of the peer on a point-to-point interface, if this is one. Some\ninterfaces do not have such an address: most of those have a `broadcastAddress`\ninstead."},{"p":["NIONetworkInterface","name"],"f":[["let",12],[" ",17],["name",7],[": ",17],["String",18,1165]],"s":[["let",12],[" ",17],["name",7],[": ",17],["String",18]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"The name of the network interface."},{"p":["NIONetworkInterface","address"],"f":[["let",12],[" ",17],["address",7],[": ",17],["SocketAddress",18,43]],"s":[["let",12],[" ",17],["address",7],[": ",17],["SocketAddress",18]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"The address associated with the given network interface."},{"p":["NIONetworkInterface","netmask"],"f":[["let",12],[" ",17],["netmask",7],[": ",17],["SocketAddress",18,43],["?",17]],"s":[["let",12],[" ",17],["netmask",7],[": ",17],["SocketAddress",18],["?",17]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}},"d":"The netmask associated with this address, if any."},{"p":["MarkedCircularBuffer","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]]},{"p":["MarkedCircularBuffer","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["MarkedCircularBuffer","markedElement"],"f":[["var",12],[" ",17],["markedElement",7],[": ",17],["Element",18],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["markedElement",7],[": ",17],["Element",18],["?",17]],"d":"Returns the marked element."},{"p":["MarkedCircularBuffer","markedElementIndex"],"f":[["var",12],[" ",17],["markedElementIndex",7],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["markedElementIndex",7],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],["?",17]],"d":"Returns the index of the marked element."},{"p":["MarkedCircularBuffer","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]],"d":"The number of elements in the buffer."},{"p":["MarkedCircularBuffer","first"],"f":[["var",12],[" ",17],["first",7],[": ",17],["Element",18],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["first",7],[": ",17],["Element",18],["?",17]],"d":"The first element in the buffer."},{"p":["MarkedCircularBuffer","hasMark"],"f":[["var",12],[" ",17],["hasMark",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["hasMark",7],[": ",17],["Bool",18]],"d":"Returns true if the buffer has been marked at all."},{"p":["MarkedCircularBuffer","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"d":"If the buffer is empty."},{"p":["MarkedCircularBuffer","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]]},{"p":["SocketOptionProvider","eventLoop"],"f":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18,28],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18]],"d":"The `EventLoop` which is used by this `SocketOptionProvider` for execution."},{"p":["ChannelHandlerContext","localAddress"],"f":[["var",12],[" ",17],["localAddress",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["localAddress",7],[": ",17],["SocketAddress",18],["?",17]]},{"p":["ChannelHandlerContext","remoteAddress"],"f":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18],["?",17]]},{"p":["ChannelHandlerContext","name"],"f":[["let",12],[" ",17],["name",7],[": ",17],["String",18,1165]],"s":[["let",12],[" ",17],["name",7],[": ",17],["String",18]]},{"p":["ChannelHandlerContext","channel"],"f":[["var",12],[" ",17],["channel",7],[": ",17],["Channel",18,27],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["channel",7],[": ",17],["Channel",18]]},{"p":["ChannelHandlerContext","handler"],"f":[["var",12],[" ",17],["handler",7],[": ",17],["ChannelHandler",18,8],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["handler",7],[": ",17],["ChannelHandler",18]]},{"p":["ChannelHandlerContext","pipeline"],"f":[["let",12],[" ",17],["pipeline",7],[": ",17],["ChannelPipeline",18,120]],"s":[["let",12],[" ",17],["pipeline",7],[": ",17],["ChannelPipeline",18]]},{"p":["ChannelHandlerContext","eventLoop"],"f":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18,28],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18]]},{"p":["NIOClientTCPBootstrap","underlyingBootstrap"],"f":[["let",12],[" ",17],["underlyingBootstrap",7],[": ",17],["NIOClientTCPBootstrapProtocol",18,24]],"s":[["let",12],[" ",17],["underlyingBootstrap",7],[": ",17],["NIOClientTCPBootstrapProtocol",18]]},{"p":["ChannelOutboundInvoker","eventLoop"],"f":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18,28],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["eventLoop",7],[": ",17],["EventLoop",18]],"d":"The `EventLoop` which is used by this `ChannelOutboundInvoker` for execution."},{"p":["NIOMulticastNotSupportedError","device"],"f":[["var",12],[" ",17],["device",7],[": ",17],["NIONetworkDevice",18,98]],"s":[["var",12],[" ",17],["device",7],[": ",17],["NIONetworkDevice",18]]},{"p":["AdaptiveRecvByteBufferAllocator","initial"],"f":[["let",12],[" ",17],["initial",7],[": ",17],["Int",18,1227]],"s":[["let",12],[" ",17],["initial",7],[": ",17],["Int",18]]},{"p":["AdaptiveRecvByteBufferAllocator","maximum"],"f":[["let",12],[" ",17],["maximum",7],[": ",17],["Int",18,1227]],"s":[["let",12],[" ",17],["maximum",7],[": ",17],["Int",18]]},{"p":["AdaptiveRecvByteBufferAllocator","minimum"],"f":[["let",12],[" ",17],["minimum",7],[": ",17],["Int",18,1227]],"s":[["let",12],[" ",17],["minimum",7],[": ",17],["Int",18]]},{"p":["FixedSizeRecvByteBufferAllocator","capacity"],"f":[["let",12],[" ",17],["capacity",7],[": ",17],["Int",18,1227]],"s":[["let",12],[" ",17],["capacity",7],[": ",17],["Int",18]]},{"p":["IOData","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["IOData","readableBytes"],"f":[["var",12],[" ",17],["readableBytes",7],[": ",17],["Int",18,1227],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["readableBytes",7],[": ",17],["Int",18]],"d":"Returns the number of readable bytes in this `IOData`."},{"p":["NIOAny","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["Channel","isWritable"],"f":[["var",12],[" ",17],["isWritable",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isWritable",7],[": ",17],["Bool",18]],"d":"Returns if this `Channel` is currently writable."},{"p":["Channel","closeFuture"],"f":[["var",12],[" ",17],["closeFuture",7],[": ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["closeFuture",7],[": ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"The `closeFuture` will fire when the `Channel` has been closed."},{"p":["Channel","syncOptions"],"f":[["var",12],[" ",17],["syncOptions",7],[": ",17],["NIOSynchronousChannelOptions",18,23],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["syncOptions",7],[": ",17],["NIOSynchronousChannelOptions",18],["?",17]],"d":"Returns a view of the `Channel` exposing synchronous versions of `setOption` and `getOption`.\nThe default implementation returns `nil`, and `Channel` implementations must opt in to\nsupport this behavior."},{"p":["Channel","localAddress"],"f":[["var",12],[" ",17],["localAddress",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["localAddress",7],[": ",17],["SocketAddress",18],["?",17]],"d":"The local `SocketAddress`."},{"p":["Channel","remoteAddress"],"f":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18,43],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["remoteAddress",7],[": ",17],["SocketAddress",18],["?",17]],"d":"The remote peer's `SocketAddress`."},{"p":["Channel","parent"],"f":[["var",12],[" ",17],["parent",7],[": ",17],["Channel",18,27],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["parent",7],[": ",17],["Channel",18],["?",17]],"d":"`Channel`s are hierarchical and might have a parent `Channel`. `Channel` hierarchies are in use for certain\nprotocols such as HTTP/2."},{"p":["Channel","isActive"],"f":[["var",12],[" ",17],["isActive",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isActive",7],[": ",17],["Bool",18]],"d":"Returns if this `Channel` is currently active. Active is defined as the period of time after the\n`channelActive` and before `channelInactive` has fired. The main use for this is to know if `channelActive`\nor `channelInactive` can be expected next when `handlerAdded` was received."},{"p":["Channel","pipeline"],"f":[["var",12],[" ",17],["pipeline",7],[": ",17],["ChannelPipeline",18,120],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["pipeline",7],[": ",17],["ChannelPipeline",18]],"d":"The `ChannelPipeline` which handles all I/O events and requests associated with this `Channel`."},{"p":["Channel","allocator"],"f":[["var",12],[" ",17],["allocator",7],[": ",17],["ByteBufferAllocator",18,103],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["allocator",7],[": ",17],["ByteBufferAllocator",18]],"d":"The `Channel`'s `ByteBuffer` allocator. This is _the only_ supported way of allocating `ByteBuffer`s to be used with this `Channel`."},{"p":["Channel","syncOptions"],"f":[["var",12],[" ",17],["syncOptions",7],[": ",17],["NIOSynchronousChannelOptions",18,23],["? { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["syncOptions",7],[": ",17],["NIOSynchronousChannelOptions",18],["?",17]],"d":"Default implementation: `NIOSynchronousChannelOptions` are not supported."},{"p":["IOError","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]]},{"p":["IOError","localizedDescription"],"f":[["var",12],[" ",17],["localizedDescription",7],[": ",17],["String",18,1165],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["localizedDescription",7],[": ",17],["String",18]]},{"p":["IOError","reason"],"f":[["var",12],[" ",17],["reason",7],[": ",17],["IOError",18,116],[".",17],["FailureDescription",18,56],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["reason",7],[": ",17],["IOError",18],[".",17],["FailureDescription",18]],"a":{"a":{"d":true,"m":"NIO no longer uses FailureDescription, use IOError.description for a human-readable error description"}}},{"p":["IOError","errnoCode"],"f":[["var",12],[" ",17],["errnoCode",7],[": ",17],["CInt",18,1378],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["errnoCode",7],[": ",17],["CInt",18]],"d":"The `errno` that was set for the operation."},{"p":["EventLoop","inEventLoop"],"f":[["var",12],[" ",17],["inEventLoop",7],[": ",17],["Bool",18,1224],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["inEventLoop",7],[": ",17],["Bool",18]],"d":"Returns `true` if the current `NIOThread` is the same as the `NIOThread` that is tied to this `EventLoop`. `false` otherwise."},{"p":["Scheduled","futureResult"],"f":[["var",12],[" ",17],["futureResult",7],[": ",17],["EventLoopFuture",18,121],["<",17],["T",18],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["futureResult",7],[": ",17],["EventLoopFuture",18],["<",17],["T",18],[">",17]],"d":"Returns the `EventLoopFuture` which will be notified once the execution of the scheduled task completes."},{"p":["TimeAmount","nanoseconds(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["nanoseconds",7],["(",17],["_",1],[" ",17],["amount",2],[": ",17],["Int64",18,1382],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["nanoseconds",7],["(",17],["Int64",18],[") -> ",17],["TimeAmount",18]],"d":"Creates a new `TimeAmount` for the given amount of nanoseconds.\n\n- parameters:\n    - amount: the amount of nanoseconds this `TimeAmount` represents.\n- returns: the `TimeAmount` for the given amount."},{"p":["TimeAmount","microseconds(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["microseconds",7],["(",17],["_",1],[" ",17],["amount",2],[": ",17],["Int64",18,1382],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["microseconds",7],["(",17],["Int64",18],[") -> ",17],["TimeAmount",18]],"d":"Creates a new `TimeAmount` for the given amount of microseconds.\n\n- parameters:\n    - amount: the amount of microseconds this `TimeAmount` represents.\n- returns: the `TimeAmount` for the given amount."},{"p":["TimeAmount","milliseconds(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["milliseconds",7],["(",17],["_",1],[" ",17],["amount",2],[": ",17],["Int64",18,1382],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["milliseconds",7],["(",17],["Int64",18],[") -> ",17],["TimeAmount",18]],"d":"Creates a new `TimeAmount` for the given amount of milliseconds.\n\n- parameters:\n    - amount: the amount of milliseconds this `TimeAmount` represents.\n- returns: the `TimeAmount` for the given amount."},{"p":["TimeAmount","hours(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["hours",7],["(",17],["_",1],[" ",17],["amount",2],[": ",17],["Int64",18,1382],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["hours",7],["(",17],["Int64",18],[") -> ",17],["TimeAmount",18]],"d":"Creates a new `TimeAmount` for the given amount of hours.\n\n- parameters:\n    - amount: the amount of hours this `TimeAmount` represents.\n- returns: the `TimeAmount` for the given amount."},{"p":["TimeAmount","minutes(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["minutes",7],["(",17],["_",1],[" ",17],["amount",2],[": ",17],["Int64",18,1382],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["minutes",7],["(",17],["Int64",18],[") -> ",17],["TimeAmount",18]],"d":"Creates a new `TimeAmount` for the given amount of minutes.\n\n- parameters:\n    - amount: the amount of minutes this `TimeAmount` represents.\n- returns: the `TimeAmount` for the given amount."},{"p":["TimeAmount","seconds(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["seconds",7],["(",17],["_",1],[" ",17],["amount",2],[": ",17],["Int64",18,1382],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["seconds",7],["(",17],["Int64",18],[") -> ",17],["TimeAmount",18]],"d":"Creates a new `TimeAmount` for the given amount of seconds.\n\n- parameters:\n    - amount: the amount of seconds this `TimeAmount` represents.\n- returns: the `TimeAmount` for the given amount."},{"p":["NIODeadline","uptimeNanoseconds(_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["uptimeNanoseconds",7],["(",17],["_",1],[" ",17],["nanoseconds",2],[": ",17],["UInt64",18,1388],[") -> ",17],["NIODeadline",18,63]],"s":[["static",12],[" ",17],["func",12],[" ",17],["uptimeNanoseconds",7],["(",17],["UInt64",18],[") -> ",17],["NIODeadline",18]]},{"p":["NIODeadline","now()"],"f":[["static",12],[" ",17],["func",12],[" ",17],["now",7],["() -> ",17],["NIODeadline",18,63]],"s":[["static",12],[" ",17],["func",12],[" ",17],["now",7],["() -> ",17],["NIODeadline",18]]},{"p":["NIOFileHandle","Flags","allowFileCreation(posixMode:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["allowFileCreation",7],["(",17],["posixMode",1],[": ",17],["mode_t",18,1099],[" = S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH) -> ",17],["NIOFileHandle",18,119],[".",17],["Flags",18,69]],"s":[["static",12],[" ",17],["func",12],[" ",17],["allowFileCreation",7],["(",17],["posixMode",1],[": ",17],["mode_t",18],[") -> ",17],["NIOFileHandle",18],[".",17],["Flags",18]],"d":"Allows file creation when opening file for writing. File owner is set to the effective user ID of the process.\n\n- parameters:\n    - posixMode: `file mode` applied when file is created. Default permissions are: read and write for fileowner, read for owners group and others."},{"p":["NIOFileHandle","Flags","posix(flags:mode:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["posix",7],["(",17],["flags",1],[": ",17],["CInt",18,1378],[", ",17],["mode",1],[": ",17],["mode_t",18,1099],[") -> ",17],["NIOFileHandle",18,119],[".",17],["Flags",18,69]],"s":[["static",12],[" ",17],["func",12],[" ",17],["posix",7],["(",17],["flags",1],[": ",17],["CInt",18],[", ",17],["mode",1],[": ",17],["mode_t",18],[") -> ",17],["NIOFileHandle",18],[".",17],["Flags",18]],"d":"Allows the specification of POSIX flags (e.g. `O_TRUNC`) and mode (e.g. `S_IWUSR`)\n\n- parameters:\n    - flags: The POSIX open flags (the second parameter for `open(2)`).\n    - mode: The POSIX mode (the third parameter for `open(2)`).\n- returns: A `NIOFileHandle.Mode` equivalent to the given POSIX flags and mode."},{"p":["SocketAddress","makeAddressResolvingHost(_:port:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["makeAddressResolvingHost",7],["(",17],["_",1],[" ",17],["host",2],[": ",17],["String",18,1165],[", ",17],["port",1],[": ",17],["Int",18,1227],[") ",17],["throws",12],[" -> ",17],["SocketAddress",18,43]],"s":[["static",12],[" ",17],["func",12],[" ",17],["makeAddressResolvingHost",7],["(",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") ",17],["throws",12],[" -> ",17],["SocketAddress",18]],"d":"Creates a new `SocketAddress` for the given host (which will be resolved) and port.\n\n- warning: This is a blocking call, so please avoid calling this from an `EventLoop`.\n\n- parameters:\n    - host: the hostname which should be resolved.\n    - port: the port itself\n- returns: the `SocketAddress` for the host / port pair.\n- throws: a `SocketAddressError.unknown` if we could not resolve the `host`, or `SocketAddressError.unsupported` if the address itself is not supported (yet)."},{"p":["EventLoopFuture","andAllSucceed(_:on:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["andAllSucceed",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["on",1],[" ",17],["eventLoop",2],[": ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["andAllSucceed",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["on",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"g":[["Value",0,0]],"d":"Returns a new `EventLoopFuture` that succeeds only if all of the provided futures succeed.\n\nThis method acts as a successful completion notifier - values fulfilled by each future are discarded.\n\nThe returned `EventLoopFuture` fails as soon as any of the provided futures fail.\n\nIf it is desired to always succeed, regardless of failures, use `andAllComplete` instead.\n- Parameters:\n    - futures: An array of homogenous `EventLoopFutures`s to wait for.\n    - on: The `EventLoop` on which the new `EventLoopFuture` callbacks will execute on.\n- Returns: A new `EventLoopFuture` that waits for the other futures to succeed."},{"p":["EventLoopFuture","andAllSucceed(_:promise:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["andAllSucceed",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["andAllSucceed",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">)",17]],"g":[["Value",0,0]],"d":"Succeeds the promise if all of the provided futures succeed. If any of the provided\nfutures fail then the `promise` will be failed -- even if some futures are yet to complete.\n\nIf the results of all futures should be collected use `andAllComplete` instead.\n\n- Parameters:\n    - futures: An array of homogenous `EventLoopFutures`s to wait for.\n    - promise: The `EventLoopPromise` to complete with the result of this call."},{"p":["EventLoopFuture","andAllComplete(_:on:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["andAllComplete",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["on",1],[" ",17],["eventLoop",2],[": ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["andAllComplete",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["on",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"g":[["Value",0,0]],"d":"Returns a new `EventLoopFuture` that succeeds when all of the provided `EventLoopFuture`s complete.\n\nThe returned `EventLoopFuture` always succeeds, acting as a completion notification.\nValues fulfilled by each future are discarded.\n\nIf the results are needed, use `whenAllComplete` instead.\n- Parameters:\n    - futures: An array of homogenous `EventLoopFuture`s to wait for.\n    - on: The `EventLoop` on which the new `EventLoopFuture` callbacks will execute on.\n- Returns: A new `EventLoopFuture` that succeeds after all futures complete."},{"p":["EventLoopFuture","andAllComplete(_:promise:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["andAllComplete",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["andAllComplete",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">)",17]],"g":[["Value",0,0]],"d":"Completes a `promise` when all of the provided `EventLoopFuture`s have completed.\n\nThe promise will always be succeeded, regardless of the outcome of the individual futures.\n\nIf the results are required, use `whenAllComplete` instead.\n\n- Parameters:\n    - futures: An array of homogenous `EventLoopFuture`s to wait for.\n    - promise: The `EventLoopPromise` to succeed when all futures have completed."},{"p":["EventLoopFuture","whenAllSucceed(_:on:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["whenAllSucceed",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["on",1],[" ",17],["eventLoop",2],[": ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<[",17],["Value",18],["]>",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["whenAllSucceed",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["on",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<[",17],["Value",18],["]>",17]],"g":[["Value",0,0]],"d":"Returns a new `EventLoopFuture` that succeeds only if all of the provided futures succeed.\nThe new `EventLoopFuture` will contain all of the values fulfilled by the futures.\n\nThe returned `EventLoopFuture` will fail as soon as any of the futures fails.\n- Parameters:\n    - futures: An array of homogenous `EventLoopFuture`s to wait on for fulfilled values.\n    - on: The `EventLoop` on which the new `EventLoopFuture` callbacks will fire.\n- Returns: A new `EventLoopFuture` with all of the values fulfilled by the provided futures."},{"p":["EventLoopFuture","whenAllSucceed(_:promise:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["whenAllSucceed",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<[",17],["Value",18],["]>)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["whenAllSucceed",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<[",17],["Value",18],["]>)",17]],"g":[["Value",0,0]],"d":"Completes the `promise` with the values of all `futures` if all provided futures succeed. If\nany of the provided futures fail then `promise` will be failed.\n\nIf the _results of all futures should be collected use `andAllComplete` instead.\n\n- Parameters:\n    - futures: An array of homogenous `EventLoopFutures`s to wait for.\n    - promise: The `EventLoopPromise` to complete with the result of this call."},{"p":["EventLoopFuture","whenAllComplete(_:on:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["whenAllComplete",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["on",1],[" ",17],["eventLoop",2],[": ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<[",17],["Result",18,1386],["<",17],["Value",18],[", ",17],["Error",18,1380],[">]>",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["whenAllComplete",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["on",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<[",17],["Result",18],["<",17],["Value",18],[", ",17],["Error",18],[">]>",17]],"g":[["Value",0,0]],"d":"Returns a new `EventLoopFuture` that succeeds when all of the provided `EventLoopFuture`s complete.\nThe new `EventLoopFuture` will contain an array of results, maintaining ordering for each of the `EventLoopFuture`s.\n\nThe returned `EventLoopFuture` always succeeds, regardless of any failures from the waiting futures.\n\nIf it is desired to flatten them into a single `EventLoopFuture` that fails on the first `EventLoopFuture` failure,\nuse one of the `reduce` methods instead.\n- Parameters:\n    - futures: An array of homogenous `EventLoopFuture`s to gather results from.\n    - on: The `EventLoop` on which the new `EventLoopFuture` callbacks will fire.\n- Returns: A new `EventLoopFuture` with all the results of the provided futures."},{"p":["EventLoopFuture","whenAllComplete(_:promise:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["whenAllComplete",7],["(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<[",17],["Result",18,1386],["<",17],["Value",18],[", ",17],["Error",18,1380],[">]>)",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["whenAllComplete",7],["([",17],["EventLoopFuture",18],["<",17],["Value",18],[">], ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<[",17],["Result",18],["<",17],["Value",18],[", ",17],["Error",18],[">]>)",17]],"g":[["Value",0,0]],"d":"Completes a `promise` with the results of all provided `EventLoopFuture`s.\n\nThe promise will always be succeeded, regardless of the outcome of the futures.\n\n- Parameters:\n    - futures: An array of homogenous `EventLoopFuture`s to gather results from.\n    - promise: The `EventLoopPromise` to complete with the result of the futures."},{"p":["EventLoopFuture","reduce(into:_:on:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["reduce",7],["<",17],["InputValue",0],[">(",17],["into",1],[" ",17],["initialResult",2],[": ",17],["Value",18],[", ",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["InputValue",18],[">], ",17],["on",1],[" ",17],["eventLoop",2],[": ",17],["EventLoop",18,28],[", ",17],["_",1],[" ",17],["updateAccumulatingResult",2],[": ",17],["@escaping",12],[" (",17],["inout",12],[" ",17],["Value",18],[", ",17],["InputValue",18],[") -> ",17],["Void",18,1379],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["reduce",7],["<",17],["InputValue",0],[">(",17],["into",1],[": ",17],["Value",18],[", [",17],["EventLoopFuture",18],["<",17],["InputValue",18],[">], ",17],["on",1],[": ",17],["EventLoop",18],[", (",17],["inout",12],[" ",17],["Value",18],[", ",17],["InputValue",18],[") -> ",17],["Void",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0],["InputValue",0,1]],"d":"Returns a new `EventLoopFuture` that fires only when all the provided futures complete.\nThe new `EventLoopFuture` contains the result of combining the `initialResult` with the\nvalues of the `[EventLoopFuture<NewValue>]`. This function is analogous to the standard library's\n`reduce(into:)`, which does not make copies of the result type for each `EventLoopFuture`.\n\nThe returned `EventLoopFuture` will fail as soon as a failure is encountered in any of the\n`futures`. However, the failure will not occur until all preceding\n`EventLoopFutures` have completed. At the point the failure is encountered, all subsequent\n`EventLoopFuture` objects will no longer be waited for. This function therefore fails fast: once\na failure is encountered, it will immediately fail the overall `EventLoopFuture`.\n\n- parameters:\n    - initialResult: An initial result to begin the reduction.\n    - futures: An array of `EventLoopFuture` to wait for.\n    - eventLoop: The `EventLoop` on which the new `EventLoopFuture` callbacks will fire.\n    - updateAccumulatingResult: The bifunction used to combine partialResults with new elements.\n- returns: A new `EventLoopFuture` with the combined value."},{"p":["EventLoopFuture","reduce(_:_:on:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["reduce",7],["<",17],["InputValue",0],[">(",17],["_",1],[" ",17],["initialResult",2],[": ",17],["Value",18],[", ",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["InputValue",18],[">], ",17],["on",1],[" ",17],["eventLoop",2],[": ",17],["EventLoop",18,28],[", ",17],["_",1],[" ",17],["nextPartialResult",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[", ",17],["InputValue",18],[") -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["reduce",7],["<",17],["InputValue",0],[">(",17],["Value",18],[", [",17],["EventLoopFuture",18],["<",17],["InputValue",18],[">], ",17],["on",1],[": ",17],["EventLoop",18],[", (",17],["Value",18],[", ",17],["InputValue",18],[") -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0],["InputValue",0,1]],"d":"Returns a new `EventLoopFuture` that fires only when all the provided futures complete.\nThe new `EventLoopFuture` contains the result of reducing the `initialResult` with the\nvalues of the `[EventLoopFuture<NewValue>]`.\n\nThis function makes copies of the result for each EventLoopFuture, for a version which avoids\nmaking copies, check out `reduce<NewValue>(into:)`.\n\nThe returned `EventLoopFuture` will fail as soon as a failure is encountered in any of the\n`futures`. However, the failure will not occur until all preceding\n`EventLoopFutures` have completed. At the point the failure is encountered, all subsequent\n`EventLoopFuture` objects will no longer be waited for. This function therefore fails fast: once\na failure is encountered, it will immediately fail the overall `EventLoopFuture`.\n\n- parameters:\n    - initialResult: An initial result to begin the reduction.\n    - futures: An array of `EventLoopFuture` to wait for.\n    - eventLoop: The `EventLoop` on which the new `EventLoopFuture` callbacks will fire.\n    - nextPartialResult: The bifunction used to produce partial results.\n- returns: A new `EventLoopFuture` with the reduced value."},{"p":["AcceptBackoffHandler","defaultBackoffProvider(error:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["defaultBackoffProvider",7],["(",17],["error",1],[": ",17],["IOError",18,116],[") -> ",17],["TimeAmount",18,62],["?",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["defaultBackoffProvider",7],["(",17],["error",1],[": ",17],["IOError",18],[") -> ",17],["TimeAmount",18],["?",17]],"d":"Default implementation used as `backoffProvider` which delays accept by 1 second."},{"p":["System","enumerateDevices()"],"f":[["static",12],[" ",17],["func",12],[" ",17],["enumerateDevices",7],["() ",17],["throws",12],[" -> [",17],["NIONetworkDevice",18,98],["]",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["enumerateDevices",7],["() ",17],["throws",12],[" -> [",17],["NIONetworkDevice",18],["]",17]],"d":"A utility function that enumerates the available network devices on this machine.\n\nThis function returns values that are true for a brief snapshot in time. These results can\nchange, and the returned values will not change to reflect them. This function must be called\nagain to get new results.\n\n- returns: An array of network devices available on this machine.\n- throws: If an error is encountered while enumerating interfaces."},{"p":["System","enumerateInterfaces()"],"f":[["static",12],[" ",17],["func",12],[" ",17],["enumerateInterfaces",7],["() ",17],["throws",12],[" -> [",17],["NIONetworkInterface",18,124],["]",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["enumerateInterfaces",7],["() ",17],["throws",12],[" -> [",17],["NIONetworkInterface",18],["]",17]],"a":{"a":{"d":true,"r":"enumerateDevices"}},"d":"A utility function that enumerates the available network interfaces on this machine.\n\nThis function returns values that are true for a brief snapshot in time. These results can\nchange, and the returned values will not change to reflect them. This function must be called\nagain to get new results.\n\n- returns: An array of network interfaces available on this machine.\n- throws: If an error is encountered while enumerating interfaces."},{"p":["ByteBuffer","setRepeatingByte(_:count:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setRepeatingByte",7],["(",17],["_",1],[" ",17],["byte",2],[": ",17],["UInt8",18,1384],[", ",17],["count",1],[": ",17],["Int",18,1227],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setRepeatingByte",7],["(",17],["UInt8",18],[", ",17],["count",1],[": ",17],["Int",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Sets the given `byte` `count` times at the given `index`. Will reserve more memory if necessary. Does not move the writer index.\n\n- parameter byte: The `UInt8` byte to repeat.\n- parameter count: How many times to repeat the given `byte`\n- returns: How many bytes were written."},{"p":["ByteBuffer","writeImmutableBuffer(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeImmutableBuffer",7],["(",17],["_",1],[" ",17],["buffer",2],[": ",17],["ByteBuffer",18,58],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeImmutableBuffer",7],["(",17],["ByteBuffer",18],[") -> ",17],["Int",18]]},{"p":["ByteBuffer","writeRepeatingByte(_:count:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeRepeatingByte",7],["(",17],["_",1],[" ",17],["byte",2],[": ",17],["UInt8",18,1384],[", ",17],["count",1],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeRepeatingByte",7],["(",17],["UInt8",18],[", ",17],["count",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Writes `byte` `count` times. Moves the writer index forward by the number of bytes written.\n\n- parameter byte: The `UInt8` byte to repeat.\n- parameter count: How many times to repeat the given `byte`\n- returns: How many bytes were written."},{"p":["ByteBuffer","setBuffer(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setBuffer",7],["(",17],["_",1],[" ",17],["buffer",2],[": ",17],["ByteBuffer",18,58],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setBuffer",7],["(",17],["ByteBuffer",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Copy `buffer`'s readable bytes into this `ByteBuffer` starting at `index`. Does not move any of the reader or writer indices.\n\n- parameters:\n    - buffer: The `ByteBuffer` to copy.\n    - index: The index for the first byte.\n- returns: The number of bytes written."},{"p":["ByteBuffer","writeBuffer(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeBuffer",7],["(",17],["_",1],[" ",17],["buffer",2],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeBuffer",7],["(",17],["inout",12],[" ",17],["ByteBuffer",18],[") -> ",17],["Int",18]],"d":"Write `buffer`'s readable bytes into this `ByteBuffer` starting at `writerIndex`. This will move both this\n`ByteBuffer`'s writer index as well as `buffer`'s reader index by the number of bytes readable in `buffer`.\n\n- parameters:\n    - buffer: The `ByteBuffer` to write.\n- returns: The number of bytes written to this `ByteBuffer` which is equal to the number of bytes read from `buffer`."},{"p":["ByteBuffer","getInteger(at:endianness:as:)"],"f":[["func",12],[" ",17],["getInteger",7],["<",17],["T",0],[">(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = Endianness.big, ",17],["as",1],[": ",17],["T",18],[".Type = T.self) -> ",17],["T",18],["? ",17],["where",12],[" ",17],["T",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["getInteger",7],["<",17],["T",0],[">(",17],["at",1],[": ",17],["Int",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["T",18],[".Type) -> ",17],["T",18],["?",17]],"c":[["T",1,"FixedWidthInteger",1361]],"g":[["T",0,0]],"d":"Get the integer at `index` from this `ByteBuffer`. Does not move the reader index.\nThe selected bytes must be readable or else `nil` will be returned.\n\n- parameters:\n    - index: The starting index of the bytes for the integer into the `ByteBuffer`.\n    - endianness: The endianness of the integer in this `ByteBuffer` (defaults to big endian).\n    - as: the desired `FixedWidthInteger` type (optional parameter)\n- returns: An integer value deserialized from this `ByteBuffer` or `nil` if the bytes of interest are not\n           readable."},{"p":["ByteBuffer","readString(length:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readString",7],["(",17],["length",1],[": ",17],["Int",18,1227],[") -> ",17],["String",18,1165],["?",17]],"s":[["func",12],[" ",17],["readString",7],["(",17],["length",1],[": ",17],["Int",18],[") -> ",17],["String",18],["?",17]],"d":"Read `length` bytes off this `ByteBuffer`, decoding it as `String` using the UTF-8 encoding. Move the reader index forward by `length`.\n\n- parameters:\n    - length: The number of bytes making up the string.\n- returns: A `String` value deserialized from this `ByteBuffer` or `nil` if there aren't at least `length` bytes readable."},{"p":["ByteBuffer","setInteger(_:at:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setInteger",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["integer",2],[": ",17],["T",18],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": ",17],["T",18],[".Type = T.self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["setInteger",7],["<",17],["T",0],[">(",17],["T",18],[", ",17],["at",1],[": ",17],["Int",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["T",18],[".Type) -> ",17],["Int",18]],"c":[["T",1,"FixedWidthInteger",1361]],"g":[["T",0,0]],"d":"Write `integer` into this `ByteBuffer` starting at `index`. This does not alter the writer index.\n\n- parameters:\n    - integer: The integer to serialize.\n    - index: The index of the first byte to write.\n    - endianness: The endianness to use, defaults to big endian.\n- returns: The number of bytes written."},{"p":["ByteBuffer","writeBytes(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeBytes",7],["(",17],["_",1],[" ",17],["bytes",2],[": ",17],["UnsafeRawBufferPointer",18,1215],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeBytes",7],["(",17],["UnsafeRawBufferPointer",18],[") -> ",17],["Int",18]],"d":"Write `bytes` into this `ByteBuffer`. Moves the writer index forward by the number of bytes written.\n\n- parameters:\n    - bytes: An `UnsafeRawBufferPointer`\n- returns: The number of bytes written or `bytes.count`."},{"p":["ByteBuffer","writeBytes(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeBytes",7],["<",17],["Bytes",0],[">(",17],["_",1],[" ",17],["bytes",2],[": ",17],["Bytes",18],[") -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["Bytes",18],[" : ",17],["Sequence",18,1166],[", ",17],["Bytes",18],[".",17],["Element",18],[" == ",17],["UInt8",18,1384]],"s":[["func",12],[" ",17],["writeBytes",7],["<",17],["Bytes",0],[">(",17],["Bytes",18],[") -> ",17],["Int",18]],"c":[["Bytes",1,"Sequence",1166],["Bytes.Element",2,"UInt8",1384]],"g":[["Bytes",0,0]],"d":"Write `bytes`, a `Sequence` of `UInt8` into this `ByteBuffer`. Moves the writer index forward by the number of bytes written.\n\n- parameters:\n    - bytes: A `Collection` of `UInt8` to be written.\n- returns: The number of bytes written or `bytes.count`."},{"p":["ByteBuffer","readInteger(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readInteger",7],["<",17],["T",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": ",17],["T",18],[".Type = T.self) -> ",17],["T",18],["? ",17],["where",12],[" ",17],["T",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readInteger",7],["<",17],["T",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["T",18],[".Type) -> ",17],["T",18],["?",17]],"c":[["T",1,"FixedWidthInteger",1361]],"g":[["T",0,0]],"d":"Read an integer off this `ByteBuffer`, move the reader index forward by the integer's byte size and return the result.\n\n- parameters:\n    - endianness: The endianness of the integer in this `ByteBuffer` (defaults to big endian).\n    - as: the desired `FixedWidthInteger` type (optional parameter)\n- returns: An integer value deserialized from this `ByteBuffer` or `nil` if there aren't enough bytes readable."},{"p":["ByteBuffer","writeString(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeString",7],["(",17],["_",1],[" ",17],["string",2],[": ",17],["String",18,1165],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeString",7],["(",17],["String",18],[") -> ",17],["Int",18]],"d":"Write `string` into this `ByteBuffer` using UTF-8 encoding, moving the writer index forward appropriately.\n\n- parameters:\n    - string: The string to write.\n- returns: The number of bytes written."},{"p":["ByteBuffer","setSubstring(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setSubstring",7],["(",17],["_",1],[" ",17],["substring",2],[": ",17],["Substring",18,1340],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setSubstring",7],["(",17],["Substring",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Write `substring` into this `ByteBuffer` at `index` using UTF-8 encoding. Does not move the writer index.\n\n- parameters:\n    - substring: The substring to write.\n    - index: The index for the first serialized byte.\n- returns: The number of bytes written"},{"p":["ByteBuffer","writeInteger(_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeInteger",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["integer",2],[": ",17],["T",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": ",17],["T",18],[".Type = T.self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeInteger",7],["<",17],["T",0],[">(",17],["T",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["T",18],[".Type) -> ",17],["Int",18]],"c":[["T",1,"FixedWidthInteger",1361]],"g":[["T",0,0]],"d":"Write `integer` into this `ByteBuffer`, moving the writer index forward appropriately.\n\n- parameters:\n    - integer: The integer to serialize.\n    - endianness: The endianness to use, defaults to big endian.\n- returns: The number of bytes written."},{"p":["ByteBuffer","writeSubstring(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeSubstring",7],["(",17],["_",1],[" ",17],["substring",2],[": ",17],["Substring",18,1340],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeSubstring",7],["(",17],["Substring",18],[") -> ",17],["Int",18]],"d":"Write `substring` into this `ByteBuffer` using UTF-8 encoding, moving the writer index forward appropriately.\n\n- parameters:\n    - substring: The substring to write.\n- returns: The number of bytes written."},{"p":["ByteBuffer","getDispatchData(at:length:)"],"f":[["func",12],[" ",17],["getDispatchData",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["length",1],[": ",17],["Int",18,1227],[") -> ",17],["DispatchData",18,1110],["?",17]],"s":[["func",12],[" ",17],["getDispatchData",7],["(",17],["at",1],[": ",17],["Int",18],[", ",17],["length",1],[": ",17],["Int",18],[") -> ",17],["DispatchData",18],["?",17]],"d":"Get the bytes at `index` from this `ByteBuffer` as a `DispatchData`. Does not move the reader index.\nThe selected bytes must be readable or else `nil` will be returned.\n\n- parameters:\n    - index: The starting index into `ByteBuffer` containing the string of interest.\n    - length: The number of bytes.\n- returns: A `DispatchData` value deserialized from this `ByteBuffer` or `nil` if the requested bytes\n           are not readable."},{"p":["ByteBuffer","moveReaderIndex(to:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["moveReaderIndex",7],["(",17],["to",1],[" ",17],["offset",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["moveReaderIndex",7],["(",17],["to",1],[": ",17],["Int",18],[")",17]],"d":"Set the reader index to `offset`.\n\n- warning: By contract the bytes between (including) `readerIndex` and (excluding) `writerIndex` must be\n           initialised, ie. have been written before. Also the `readerIndex` must always be less than or equal\n           to the `writerIndex`. Failing to meet either of these requirements leads to undefined behaviour.\n- parameters:\n  - offset: The offset in bytes to set the reader index to."},{"p":["ByteBuffer","moveReaderIndex(forwardBy:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["moveReaderIndex",7],["(",17],["forwardBy",1],[" ",17],["offset",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["moveReaderIndex",7],["(",17],["forwardBy",1],[": ",17],["Int",18],[")",17]],"d":"Move the reader index forward by `offset` bytes.\n\n- warning: By contract the bytes between (including) `readerIndex` and (excluding) `writerIndex` must be\n           initialised, ie. have been written before. Also the `readerIndex` must always be less than or equal\n           to the `writerIndex`. Failing to meet either of these requirements leads to undefined behaviour.\n- parameters:\n  - offset: The number of bytes to move the reader index forward by."},{"p":["ByteBuffer","moveWriterIndex(to:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["moveWriterIndex",7],["(",17],["to",1],[" ",17],["offset",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["moveWriterIndex",7],["(",17],["to",1],[": ",17],["Int",18],[")",17]],"d":"Set the writer index to `offset`.\n\n- warning: By contract the bytes between (including) `readerIndex` and (excluding) `writerIndex` must be\n           initialised, ie. have been written before. Also the `readerIndex` must always be less than or equal\n           to the `writerIndex`. Failing to meet either of these requirements leads to undefined behaviour.\n- parameters:\n  - offset: The offset in bytes to set the reader index to."},{"p":["ByteBuffer","moveWriterIndex(forwardBy:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["moveWriterIndex",7],["(",17],["forwardBy",1],[" ",17],["offset",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["moveWriterIndex",7],["(",17],["forwardBy",1],[": ",17],["Int",18],[")",17]],"d":"Move the writer index forward by `offset` bytes.\n\n- warning: By contract the bytes between (including) `readerIndex` and (excluding) `writerIndex` must be\n           initialised, ie. have been written before. Also the `readerIndex` must always be less than or equal\n           to the `writerIndex`. Failing to meet either of these requirements leads to undefined behaviour.\n- parameters:\n  - offset: The number of bytes to move the writer index forward by."},{"p":["ByteBuffer","reserveCapacity(minimumWritableBytes:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reserveCapacity",7],["(",17],["minimumWritableBytes",1],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["reserveCapacity",7],["(",17],["minimumWritableBytes",1],[": ",17],["Int",18],[")",17]],"d":"Reserves enough space to write at least the specified number of bytes.\n\nThis method will ensure that the buffer has enough writable space for at least as many bytes\nas requested. If the buffer already has space to write the requested number of bytes, this\nmethod will be a no-op.\n\n- Parameter minimumWritableBytes: The minimum number of writable bytes this buffer must have."},{"p":["ByteBuffer","reserveCapacity(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reserveCapacity",7],["(",17],["_",1],[" ",17],["minimumCapacity",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["reserveCapacity",7],["(",17],["Int",18],[")",17]],"d":"Reserves enough space to store the specified number of bytes.\n\nThis method will ensure that the buffer has space for at least as many bytes as requested.\nThis includes any bytes already stored, and completely disregards the reader/writer indices.\nIf the buffer already has space to store the requested number of bytes, this method will be\na no-op.\n\n- parameters:\n    - minimumCapacity: The minimum number of bytes this buffer must be able to store."},{"p":["ByteBuffer","setDispatchData(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setDispatchData",7],["(",17],["_",1],[" ",17],["dispatchData",2],[": ",17],["DispatchData",18,1110],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setDispatchData",7],["(",17],["DispatchData",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Write `dispatchData` into this `ByteBuffer` at `index`. Does not move the writer index.\n\n- parameters:\n    - dispatchData: The `DispatchData` to write.\n    - index: The index for the first serialized byte.\n- returns: The number of bytes written."},{"p":["ByteBuffer","setStaticString(_:at:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["setStaticString",7],["(",17],["_",1],[" ",17],["string",2],[": ",17],["StaticString",18,1359],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setStaticString",7],["(",17],["StaticString",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Write the static `string` into this `ByteBuffer` at `index` using UTF-8 encoding, moving the writer index forward appropriately.\n\n- parameters:\n    - string: The string to write.\n    - index: The index for the first serialized byte.\n- returns: The number of bytes written."},{"p":["ByteBuffer","discardReadBytes()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["discardReadBytes",7],["() -> ",17],["Bool",18,1224]],"s":[["func",12],[" ",17],["discardReadBytes",7],["() -> ",17],["Bool",18]],"d":"Discard the bytes before the reader index. The byte at index `readerIndex` before calling this method will be\nat index `0` after the call returns.\n\n- returns: `true` if one or more bytes have been discarded, `false` if there are no bytes to discard."},{"p":["ByteBuffer","readDispatchData(length:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readDispatchData",7],["(",17],["length",1],[": ",17],["Int",18,1227],[") -> ",17],["DispatchData",18,1110],["?",17]],"s":[["func",12],[" ",17],["readDispatchData",7],["(",17],["length",1],[": ",17],["Int",18],[") -> ",17],["DispatchData",18],["?",17]],"d":"Read `length` bytes off this `ByteBuffer` and return them as a `DispatchData`. Move the reader index forward by `length`.\n\n- parameters:\n    - length: The number of bytes.\n- returns: A `DispatchData` value containing the bytes from this `ByteBuffer` or `nil` if there aren't at least `length` bytes readable."},{"p":["ByteBuffer","writeDispatchData(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeDispatchData",7],["(",17],["_",1],[" ",17],["dispatchData",2],[": ",17],["DispatchData",18,1110],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeDispatchData",7],["(",17],["DispatchData",18],[") -> ",17],["Int",18]],"d":"Write `dispatchData` into this `ByteBuffer`, moving the writer index forward appropriately.\n\n- parameters:\n    - dispatchData: The `DispatchData` instance to write to the `ByteBuffer`.\n- returns: The number of bytes written."},{"p":["ByteBuffer","writeStaticString(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeStaticString",7],["(",17],["_",1],[" ",17],["string",2],[": ",17],["StaticString",18,1359],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeStaticString",7],["(",17],["StaticString",18],[") -> ",17],["Int",18]],"d":"Write the static `string` into this `ByteBuffer` using UTF-8 encoding, moving the writer index forward appropriately.\n\n- parameters:\n    - string: The string to write.\n- returns: The number of bytes written."},{"p":["ByteBuffer","readLengthPrefixed(endianness:as:readMessage:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readLengthPrefixed",7],["<",17],["Integer",0],[", ",17],["Result",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[" ",17],["integer",2],[": ",17],["Integer",18],[".Type, ",17],["readMessage",1],[": (",17],["ByteBuffer",18,58],[") ",17],["throws",12],[" -> ",17],["Result",18],["?) ",17],["throws",12],[" -> ",17],["Result",18],["? ",17],["where",12],[" ",17],["Integer",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readLengthPrefixed",7],["<",17],["Integer",0],[", ",17],["Result",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["Integer",18],[".Type, ",17],["readMessage",1],[": (",17],["ByteBuffer",18],[") ",17],["throws",12],[" -> ",17],["Result",18],["?) ",17],["throws",12],[" -> ",17],["Result",18],["?",17]],"c":[["Integer",1,"FixedWidthInteger",1361]],"g":[["Integer",0,0],["Result",1,0]],"d":"Reads an `Integer` from `self`, reads a slice of that length and passes it to `readMessage`. \nIt is checked that `readMessage` returns a non-nil value.\n\nThe `readerIndex` is **not** moved forward if the length prefix could not be read or `self` does not contain enough bytes. Otherwise `readerIndex` is moved forward even if `readMessage` throws or returns nil.\n- Parameters:\n    - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).\n    - integer: the desired `Integer` type used to read the length prefix\n    - readMessage: A closure that takes a `ByteBuffer` slice which contains the message after the length prefix\n- Throws: if `readMessage` returns nil\n- Returns: `nil` if the length prefix could not be read, \n           the length prefix is negative or\n           the buffer does not contain enough bytes to read a message of this length.\n           Otherwise the result of `readMessage`."},{"p":["ByteBuffer","withVeryUnsafeBytes(_:)"],"f":[["func",12],[" ",17],["withVeryUnsafeBytes",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeRawBufferPointer",18,1215],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withVeryUnsafeBytes",7],["<",17],["T",0],[">((",17],["UnsafeRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"This vends a pointer to the storage of the `ByteBuffer`. It's marked as _very unsafe_ because it might contain\nuninitialised memory and it's undefined behaviour to read it. In most cases you should use `withUnsafeReadableBytes`.\n\n- warning: Do not escape the pointer from the closure for later use."},{"p":["ByteBuffer","writeLengthPrefixed(endianness:as:writeMessage:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeLengthPrefixed",7],["<",17],["Integer",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[" ",17],["integer",2],[": ",17],["Integer",18],[".Type, ",17],["writeMessage",1],[": (",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["throws",12],[" -> ",17],["Int",18,1227],[") ",17],["throws",12],[" -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["Integer",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeLengthPrefixed",7],["<",17],["Integer",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["Integer",18],[".Type, ",17],["writeMessage",1],[": (",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["throws",12],[" -> ",17],["Int",18],[") ",17],["throws",12],[" -> ",17],["Int",18]],"c":[["Integer",1,"FixedWidthInteger",1361]],"g":[["Integer",0,0]],"d":"Prefixes a message written by `writeMessage` with the number of bytes written as an `Integer`.\n- Parameters:\n    - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).\n    - integer: the desired `Integer` type used to write the length prefix\n    - writeMessage: A closure that takes a buffer, writes a message to it and returns the number of bytes written\n- Throws: If the number of bytes written during `writeMessage` can not be exactly represented as the given `Integer` i.e. if the number of bytes written is greater than `Integer.max`\n- Returns: Number of total bytes written"},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[", ",17],["T15",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["T15",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["T15",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T13",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T14",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T15",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[", ",17],["T15",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["T15",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["T15",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361],["T13",1,"FixedWidthInteger",1361],["T14",1,"FixedWidthInteger",1361],["T15",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0],["T13",12,0],["T14",13,0],["T15",14,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T13",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T14",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361],["T13",1,"FixedWidthInteger",1361],["T14",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0],["T13",12,0],["T14",13,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T13",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361],["T13",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0],["T13",12,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[").Type = (T1, T2, T3, T4, T5, T6, T7).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[").Type = (T1, T2, T3, T4, T5, T6).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[").Type = (T1, T2, T3, T4, T5).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[").Type = (T1, T2, T3, T4).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[").Type = (T1, T2, T3).self) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0]]},{"p":["ByteBuffer","readMultipleIntegers(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[").Type = (T1, T2).self) -> (",17],["T1",18],[", ",17],["T2",18],[")? ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[").Type) -> (",17],["T1",18],[", ",17],["T2",18],[")?",17]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0]]},{"p":["ByteBuffer","modifyIfUniquelyOwned(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["modifyIfUniquelyOwned",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18],["?",17]],"s":[["func",12],[" ",17],["modifyIfUniquelyOwned",7],["<",17],["T",0],[">((",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18],["?",17]],"g":[["T",0,0]],"d":"Modify this `ByteBuffer` if this `ByteBuffer` is known to uniquely own its storage.\n\nIn some cases it is possible that code is holding a `ByteBuffer` that has been shared with other\nparts of the code, and may want to mutate that `ByteBuffer`. In some cases it may be worth modifying\na `ByteBuffer` only if that `ByteBuffer` is guaranteed to not perform a copy-on-write operation to do\nso, for example when a different buffer could be used or more cheaply allocated instead.\n\nThis function will execute the provided block only if it is guaranteed to be able to avoid a copy-on-write\noperation. If it cannot execute the block the returned value will be `nil`.\n\n- parameters:\n    - body: The modification operation to execute, with this `ByteBuffer` passed `inout` as an argument.\n- returns: The return value of `body`."},{"p":["ByteBuffer","writeMultipleIntegers(_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[").Type = (T1, T2).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[").Type = (T1, T2, T3).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[").Type = (T1, T2, T3, T4).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[").Type = (T1, T2, T3, T4, T5).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[").Type = (T1, T2, T3, T4, T5, T6).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[").Type = (T1, T2, T3, T4, T5, T6, T7).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["_",1],[" ",17],["value9",2],[": ",17],["T9",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["_",1],[" ",17],["value9",2],[": ",17],["T9",18],[", ",17],["_",1],[" ",17],["value10",2],[": ",17],["T10",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["_",1],[" ",17],["value9",2],[": ",17],["T9",18],[", ",17],["_",1],[" ",17],["value10",2],[": ",17],["T10",18],[", ",17],["_",1],[" ",17],["value11",2],[": ",17],["T11",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["_",1],[" ",17],["value9",2],[": ",17],["T9",18],[", ",17],["_",1],[" ",17],["value10",2],[": ",17],["T10",18],[", ",17],["_",1],[" ",17],["value11",2],[": ",17],["T11",18],[", ",17],["_",1],[" ",17],["value12",2],[": ",17],["T12",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["_",1],[" ",17],["value9",2],[": ",17],["T9",18],[", ",17],["_",1],[" ",17],["value10",2],[": ",17],["T10",18],[", ",17],["_",1],[" ",17],["value11",2],[": ",17],["T11",18],[", ",17],["_",1],[" ",17],["value12",2],[": ",17],["T12",18],[", ",17],["_",1],[" ",17],["value13",2],[": ",17],["T13",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T13",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361],["T13",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0],["T13",12,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["_",1],[" ",17],["value9",2],[": ",17],["T9",18],[", ",17],["_",1],[" ",17],["value10",2],[": ",17],["T10",18],[", ",17],["_",1],[" ",17],["value11",2],[": ",17],["T11",18],[", ",17],["_",1],[" ",17],["value12",2],[": ",17],["T12",18],[", ",17],["_",1],[" ",17],["value13",2],[": ",17],["T13",18],[", ",17],["_",1],[" ",17],["value14",2],[": ",17],["T14",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T13",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T14",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361],["T13",1,"FixedWidthInteger",1361],["T14",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0],["T13",12,0],["T14",13,0]]},{"p":["ByteBuffer","writeMultipleIntegers(_:_:_:_:_:_:_:_:_:_:_:_:_:_:_:endianness:as:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[", ",17],["T15",0],[">(",17],["_",1],[" ",17],["value1",2],[": ",17],["T1",18],[", ",17],["_",1],[" ",17],["value2",2],[": ",17],["T2",18],[", ",17],["_",1],[" ",17],["value3",2],[": ",17],["T3",18],[", ",17],["_",1],[" ",17],["value4",2],[": ",17],["T4",18],[", ",17],["_",1],[" ",17],["value5",2],[": ",17],["T5",18],[", ",17],["_",1],[" ",17],["value6",2],[": ",17],["T6",18],[", ",17],["_",1],[" ",17],["value7",2],[": ",17],["T7",18],[", ",17],["_",1],[" ",17],["value8",2],[": ",17],["T8",18],[", ",17],["_",1],[" ",17],["value9",2],[": ",17],["T9",18],[", ",17],["_",1],[" ",17],["value10",2],[": ",17],["T10",18],[", ",17],["_",1],[" ",17],["value11",2],[": ",17],["T11",18],[", ",17],["_",1],[" ",17],["value12",2],[": ",17],["T12",18],[", ",17],["_",1],[" ",17],["value13",2],[": ",17],["T13",18],[", ",17],["_",1],[" ",17],["value14",2],[": ",17],["T14",18],[", ",17],["_",1],[" ",17],["value15",2],[": ",17],["T15",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["T15",18],[").Type = (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15).self) -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["T1",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T2",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T3",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T4",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T5",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T6",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T7",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T8",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T9",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T10",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T11",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T12",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T13",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T14",18],[" : ",17],["FixedWidthInteger",18,1361],[", ",17],["T15",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["writeMultipleIntegers",7],["<",17],["T1",0],[", ",17],["T2",0],[", ",17],["T3",0],[", ",17],["T4",0],[", ",17],["T5",0],[", ",17],["T6",0],[", ",17],["T7",0],[", ",17],["T8",0],[", ",17],["T9",0],[", ",17],["T10",0],[", ",17],["T11",0],[", ",17],["T12",0],[", ",17],["T13",0],[", ",17],["T14",0],[", ",17],["T15",0],[">(",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["T15",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": (",17],["T1",18],[", ",17],["T2",18],[", ",17],["T3",18],[", ",17],["T4",18],[", ",17],["T5",18],[", ",17],["T6",18],[", ",17],["T7",18],[", ",17],["T8",18],[", ",17],["T9",18],[", ",17],["T10",18],[", ",17],["T11",18],[", ",17],["T12",18],[", ",17],["T13",18],[", ",17],["T14",18],[", ",17],["T15",18],[").Type) -> ",17],["Int",18]],"c":[["T1",1,"FixedWidthInteger",1361],["T2",1,"FixedWidthInteger",1361],["T3",1,"FixedWidthInteger",1361],["T4",1,"FixedWidthInteger",1361],["T5",1,"FixedWidthInteger",1361],["T6",1,"FixedWidthInteger",1361],["T7",1,"FixedWidthInteger",1361],["T8",1,"FixedWidthInteger",1361],["T9",1,"FixedWidthInteger",1361],["T10",1,"FixedWidthInteger",1361],["T11",1,"FixedWidthInteger",1361],["T12",1,"FixedWidthInteger",1361],["T13",1,"FixedWidthInteger",1361],["T14",1,"FixedWidthInteger",1361],["T15",1,"FixedWidthInteger",1361]],"g":[["T1",0,0],["T2",1,0],["T3",2,0],["T4",3,0],["T5",4,0],["T6",5,0],["T7",6,0],["T8",7,0],["T9",8,0],["T10",9,0],["T11",10,0],["T12",11,0],["T13",12,0],["T14",13,0],["T15",14,0]]},{"p":["ByteBuffer","getLengthPrefixedSlice(at:endianness:as:)"],"f":[["func",12],[" ",17],["getLengthPrefixedSlice",7],["<",17],["Integer",0],[">(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[" ",17],["integer",2],[": ",17],["Integer",18],[".Type) -> ",17],["ByteBuffer",18,58],["? ",17],["where",12],[" ",17],["Integer",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["getLengthPrefixedSlice",7],["<",17],["Integer",0],[">(",17],["at",1],[": ",17],["Int",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["Integer",18],[".Type) -> ",17],["ByteBuffer",18],["?",17]],"c":[["Integer",1,"FixedWidthInteger",1361]],"g":[["Integer",0,0]],"d":"Gets an `Integer` from `self` and gets a slice of that length from `self` and returns it.\n\n- Parameters:\n    - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).\n    - integer: the desired `Integer` type used to get the length prefix\n- Returns: `nil` if the length prefix could not be read, \n           the length prefix is negative or\n           the buffer does not contain enough bytes to read a message of this length.\n           Otherwise the message after the length prefix."},{"p":["ByteBuffer","getNullTerminatedString(at:)"],"f":[["func",12],[" ",17],["getNullTerminatedString",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["String",18,1165],["?",17]],"s":[["func",12],[" ",17],["getNullTerminatedString",7],["(",17],["at",1],[": ",17],["Int",18],[") -> ",17],["String",18],["?",17]],"d":"Get the string at `index` from this `ByteBuffer` decoding using the UTF-8 encoding. Does not move the reader index.\nThe selected bytes must be readable or else `nil` will be returned.\n\n- parameters:\n    - index: The starting index into `ByteBuffer` containing the null terminated string of interest.\n- returns: A `String` value deserialized from this `ByteBuffer` or `nil` if there isn't a complete null-terminated string,\n           including null-terminator, in the readable bytes after `index` in the buffer"},{"p":["ByteBuffer","readLengthPrefixedSlice(endianness:as:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readLengthPrefixedSlice",7],["<",17],["Integer",0],[">(",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[" ",17],["integer",2],[": ",17],["Integer",18],[".Type) -> ",17],["ByteBuffer",18,58],["? ",17],["where",12],[" ",17],["Integer",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["readLengthPrefixedSlice",7],["<",17],["Integer",0],[">(",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["Integer",18],[".Type) -> ",17],["ByteBuffer",18],["?",17]],"c":[["Integer",1,"FixedWidthInteger",1361]],"g":[["Integer",0,0]],"d":"Reads an `Integer` from `self` and reads a slice of that length from `self` and returns it.\n\nIf nil is returned, `readerIndex` is **not** moved forward.\n- Parameters:\n    - endianness: The endianness of the length prefix `Integer` in this `ByteBuffer` (defaults to big endian).\n    - integer: the desired `Integer` type used to read the length prefix\n- Returns: `nil` if the length prefix could not be read, \n           the length prefix is negative or\n           the buffer does not contain enough bytes to read a message of this length.\n           Otherwise the message after the length prefix."},{"p":["ByteBuffer","setNullTerminatedString(_:at:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["setNullTerminatedString",7],["(",17],["_",1],[" ",17],["string",2],[": ",17],["String",18,1165],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setNullTerminatedString",7],["(",17],["String",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Write `string` null terminated into this `ByteBuffer` at `index` using UTF-8 encoding. Does not move the writer index.\n\n- parameters:\n    - string: The string to write.\n    - index: The index for the first serialized byte.\n- returns: The number of bytes written."},{"p":["ByteBuffer","withUnsafeReadableBytes(_:)"],"f":[["func",12],[" ",17],["withUnsafeReadableBytes",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeRawBufferPointer",18,1215],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withUnsafeReadableBytes",7],["<",17],["T",0],[">((",17],["UnsafeRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"Yields a buffer pointer containing this `ByteBuffer`'s readable bytes.\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes.\n- returns: The value returned by `body`."},{"p":["ByteBuffer","readNullTerminatedString()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readNullTerminatedString",7],["() -> ",17],["String",18,1165],["?",17]],"s":[["func",12],[" ",17],["readNullTerminatedString",7],["() -> ",17],["String",18],["?",17]],"d":"Read a null terminated string off this `ByteBuffer`, decoding it as `String` using the UTF-8 encoding. Move the reader index\nforward by the string's length and its null terminator.\n\n- returns: A `String` value deserialized from this `ByteBuffer` or `nil` if there isn't a complete null-terminated string,\n           including null-terminator, in the readable bytes of the buffer"},{"p":["ByteBuffer","writeNullTerminatedString(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeNullTerminatedString",7],["(",17],["_",1],[" ",17],["string",2],[": ",17],["String",18,1165],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeNullTerminatedString",7],["(",17],["String",18],[") -> ",17],["Int",18]],"d":"Write `string` into this `ByteBuffer` null terminated using UTF-8 encoding, moving the writer index forward appropriately.\n\n- parameters:\n    - string: The string to write.\n- returns: The number of bytes written."},{"p":["ByteBuffer","withVeryUnsafeMutableBytes(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["withVeryUnsafeMutableBytes",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeMutableRawBufferPointer",18,1344],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withVeryUnsafeMutableBytes",7],["<",17],["T",0],[">((",17],["UnsafeMutableRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"This vends a pointer to the storage of the `ByteBuffer`. It's marked as _very unsafe_ because it might contain\nuninitialised memory and it's undefined behaviour to read it. In most cases you should use `withUnsafeMutableWritableBytes`.\n\n- warning: Do not escape the pointer from the closure for later use."},{"p":["ByteBuffer","readWithUnsafeReadableBytes(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["readWithUnsafeReadableBytes",7],["(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeRawBufferPointer",18,1215],[") ",17],["throws",12],[" -> ",17],["Int",18,1227],[") ",17],["rethrows",12],[" -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["readWithUnsafeReadableBytes",7],["((",17],["UnsafeRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["Int",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"d":"Yields an immutable buffer pointer containing this `ByteBuffer`'s readable bytes. Will move the reader index\nby the number of bytes returned by `body`.\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes and returns the number of bytes it processed.\n- returns: The number of bytes read."},{"p":["ByteBuffer","readWithUnsafeReadableBytes(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readWithUnsafeReadableBytes",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeRawBufferPointer",18,1215],[") ",17],["throws",12],[" -> (",17],["Int",18,1227],[", ",17],["T",18],[")) ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["readWithUnsafeReadableBytes",7],["<",17],["T",0],[">((",17],["UnsafeRawBufferPointer",18],[") ",17],["throws",12],[" -> (",17],["Int",18],[", ",17],["T",18],[")) ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"Yields an immutable buffer pointer containing this `ByteBuffer`'s readable bytes. Will move the reader index\nby the number of bytes `body` returns in the first tuple component.\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes and returns the number of bytes it processed along with some other value.\n- returns: The value `body` returned in the second tuple component."},{"p":["ByteBuffer","writeWithUnsafeMutableBytes(minimumWritableBytes:_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeWithUnsafeMutableBytes",7],["(",17],["minimumWritableBytes",1],[": ",17],["Int",18,1227],[", ",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeMutableRawBufferPointer",18,1344],[") ",17],["throws",12],[" -> ",17],["Int",18,1227],[") ",17],["rethrows",12],[" -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeWithUnsafeMutableBytes",7],["(",17],["minimumWritableBytes",1],[": ",17],["Int",18],[", (",17],["UnsafeMutableRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["Int",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"d":"This vends a pointer of the `ByteBuffer` at the `writerIndex` after ensuring that the buffer has at least `minimumWritableBytes` of writable bytes available.\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - minimumWritableBytes: The number of writable bytes to reserve capacity for before vending the `ByteBuffer` pointer to `body`.\n    - body: The closure that will accept the yielded bytes and return the number of bytes written.\n- returns: The number of bytes written."},{"p":["ByteBuffer","writeWithUnsafeMutableBytes(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["writeWithUnsafeMutableBytes",7],["(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeMutableRawBufferPointer",18,1344],[") ",17],["throws",12],[" -> ",17],["Int",18,1227],[") ",17],["rethrows",12],[" -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["writeWithUnsafeMutableBytes",7],["((",17],["UnsafeMutableRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["Int",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"a":{"a":{"d":true,"m":"please use writeWithUnsafeMutableBytes(minimumWritableBytes:_:) instead to ensure sufficient write capacity."}}},{"p":["ByteBuffer","withUnsafeMutableReadableBytes(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["withUnsafeMutableReadableBytes",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeMutableRawBufferPointer",18,1344],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withUnsafeMutableReadableBytes",7],["<",17],["T",0],[">((",17],["UnsafeMutableRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"Yields a mutable buffer pointer containing this `ByteBuffer`'s readable bytes. You may modify those bytes.\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes.\n- returns: The value returned by `body`."},{"p":["ByteBuffer","withUnsafeMutableWritableBytes(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["withUnsafeMutableWritableBytes",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeMutableRawBufferPointer",18,1344],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withUnsafeMutableWritableBytes",7],["<",17],["T",0],[">((",17],["UnsafeMutableRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"Yields the bytes currently writable (`bytesWritable` = `capacity` - `writerIndex`). Before reading those bytes you must first\nwrite to them otherwise you will trigger undefined behaviour. The writer index will remain unchanged.\n\n- note: In almost all cases you should use `writeWithUnsafeMutableBytes` which will move the write pointer instead of this method\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes and return the number of bytes written.\n- returns: The number of bytes written."},{"p":["ByteBuffer","readWithUnsafeMutableReadableBytes(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["readWithUnsafeMutableReadableBytes",7],["(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeMutableRawBufferPointer",18,1344],[") ",17],["throws",12],[" -> ",17],["Int",18,1227],[") ",17],["rethrows",12],[" -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["readWithUnsafeMutableReadableBytes",7],["((",17],["UnsafeMutableRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["Int",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"d":"Yields a mutable buffer pointer containing this `ByteBuffer`'s readable bytes. You may modify the yielded bytes.\nWill move the reader index by the number of bytes returned by `body` but leave writer index as it was.\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes and returns the number of bytes it processed.\n- returns: The number of bytes read."},{"p":["ByteBuffer","readWithUnsafeMutableReadableBytes(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readWithUnsafeMutableReadableBytes",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeMutableRawBufferPointer",18,1344],[") ",17],["throws",12],[" -> (",17],["Int",18,1227],[", ",17],["T",18],[")) ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["readWithUnsafeMutableReadableBytes",7],["<",17],["T",0],[">((",17],["UnsafeMutableRawBufferPointer",18],[") ",17],["throws",12],[" -> (",17],["Int",18],[", ",17],["T",18],[")) ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"Yields a mutable buffer pointer containing this `ByteBuffer`'s readable bytes. You may modify the yielded bytes.\nWill move the reader index by the number of bytes `body` returns in the first tuple component but leave writer index as it was.\n\n- warning: Do not escape the pointer from the closure for later use.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes and returns the number of bytes it processed along with some other value.\n- returns: The value `body` returned in the second tuple component."},{"p":["ByteBuffer","set(buffer:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["set",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["set",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"a":{"a":{"d":true,"r":"setBuffer(_:at:)"}},"d":"Copy `buffer`'s readable bytes into this `ByteBuffer` starting at `index`. Does not move any of the reader or writer indices.\n\n- parameters:\n    - buffer: The `ByteBuffer` to copy.\n    - index: The index for the first byte.\n- returns: The number of bytes written."},{"p":["ByteBuffer","withVeryUnsafeBytesWithStorageManagement(_:)"],"f":[["func",12],[" ",17],["withVeryUnsafeBytesWithStorageManagement",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeRawBufferPointer",18,1215],[", ",17],["Unmanaged",18,1404],["<",17],["AnyObject",18,1390],[">) ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withVeryUnsafeBytesWithStorageManagement",7],["<",17],["T",0],[">((",17],["UnsafeRawBufferPointer",18],[", ",17],["Unmanaged",18],["<",17],["AnyObject",18],[">) ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"See `withUnsafeReadableBytesWithStorageManagement` and `withVeryUnsafeBytes`."},{"p":["ByteBuffer","withUnsafeReadableBytesWithStorageManagement(_:)"],"f":[["func",12],[" ",17],["withUnsafeReadableBytesWithStorageManagement",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeRawBufferPointer",18,1215],[", ",17],["Unmanaged",18,1404],["<",17],["AnyObject",18,1390],[">) ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withUnsafeReadableBytesWithStorageManagement",7],["<",17],["T",0],[">((",17],["UnsafeRawBufferPointer",18],[", ",17],["Unmanaged",18],["<",17],["AnyObject",18],[">) ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"Yields a buffer pointer containing this `ByteBuffer`'s readable bytes. You may hold a pointer to those bytes\neven after the closure returned iff you model the lifetime of those bytes correctly using the `Unmanaged`\ninstance. If you don't require the pointer after the closure returns, use `withUnsafeReadableBytes`.\n\nIf you escape the pointer from the closure, you _must_ call `storageManagement.retain()` to get ownership to\nthe bytes and you also must call `storageManagement.release()` if you no longer require those bytes. Calls to\n`retain` and `release` must be balanced.\n\n- parameters:\n    - body: The closure that will accept the yielded bytes and the `storageManagement`.\n- returns: The value returned by `body`."},{"p":["ByteBuffer","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,1385],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"d":"The hash value for the readable bytes."},{"p":["ByteBuffer","clear(minimumCapacity:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["clear",7],["(",17],["minimumCapacity",1],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["clear",7],["(",17],["minimumCapacity",1],[": ",17],["Int",18],[")",17]],"d":"Set both reader index and writer index to `0`. This will reset the state of this `ByteBuffer` to the state\nof a freshly allocated one, if possible without allocations. This is the cheapest way to recycle a `ByteBuffer`\nfor a new use-case.\n\n- note: This method will allocate if the underlying storage is referenced by another `ByteBuffer`. Even if an\n        allocation is necessary this will be cheaper as the copy of the storage is elided.\n\n- parameters:\n    - minimumCapacity: The minimum capacity that will be (re)allocated for this buffer"},{"p":["ByteBuffer","clear(minimumCapacity:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["clear",7],["(",17],["minimumCapacity",1],[": ",17],["UInt32",18,1387],[")",17]],"s":[["func",12],[" ",17],["clear",7],["(",17],["minimumCapacity",1],[": ",17],["UInt32",18],[")",17]],"a":{"a":{"d":true,"m":"Use an `Int` as the argument"}},"d":"Set both reader index and writer index to `0`. This will reset the state of this `ByteBuffer` to the state\nof a freshly allocated one, if possible without allocations. This is the cheapest way to recycle a `ByteBuffer`\nfor a new use-case.\n\n- note: This method will allocate if the underlying storage is referenced by another `ByteBuffer`. Even if an\n        allocation is necessary this will be cheaper as the copy of the storage is elided.\n\n- parameters:\n    - minimumCapacity: The minimum capacity that will be (re)allocated for this buffer"},{"p":["ByteBuffer","clear()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["clear",7],["()",17]],"s":[["func",12],[" ",17],["clear",7],["()",17]],"d":"Set both reader index and writer index to `0`. This will reset the state of this `ByteBuffer` to the state\nof a freshly allocated one, if possible without allocations. This is the cheapest way to recycle a `ByteBuffer`\nfor a new use-case.\n\n- note: This method will allocate if the underlying storage is referenced by another `ByteBuffer`. Even if an\n        allocation is necessary this will be cheaper as the copy of the storage is elided."},{"p":["ByteBuffer","slice()"],"f":[["func",12],[" ",17],["slice",7],["() -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["slice",7],["() -> ",17],["ByteBuffer",18]],"d":"Slice the readable bytes off this `ByteBuffer` without modifying the reader index. This method will return a\n`ByteBuffer` sharing the underlying storage with the `ByteBuffer` the method was invoked on. The returned\n`ByteBuffer` will contain the bytes in the range `readerIndex..<writerIndex` of the original `ByteBuffer`.\n\n- note: Because `ByteBuffer` implements copy-on-write a copy of the storage will be automatically triggered when either of the `ByteBuffer`s sharing storage is written to.\n\n- returns: A `ByteBuffer` sharing storage containing the readable bytes only."},{"p":["ByteBuffer","getBytes(at:length:)"],"f":[["func",12],[" ",17],["getBytes",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["length",1],[": ",17],["Int",18,1227],[") -> [",17],["UInt8",18,1384],["]?",17]],"s":[["func",12],[" ",17],["getBytes",7],["(",17],["at",1],[": ",17],["Int",18],[", ",17],["length",1],[": ",17],["Int",18],[") -> [",17],["UInt8",18],["]?",17]],"d":"Get `length` bytes starting at `index` and return the result as `[UInt8]`. This will not change the reader index.\nThe selected bytes must be readable or else `nil` will be returned.\n\n- parameters:\n    - index: The starting index of the bytes of interest into the `ByteBuffer`.\n    - length: The number of bytes of interest.\n- returns: A `[UInt8]` value containing the bytes of interest or `nil` if the bytes `ByteBuffer` are not readable."},{"p":["ByteBuffer","getSlice(at:length:)"],"f":[["func",12],[" ",17],["getSlice",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["length",1],[": ",17],["Int",18,1227],[") -> ",17],["ByteBuffer",18,58],["?",17]],"s":[["func",12],[" ",17],["getSlice",7],["(",17],["at",1],[": ",17],["Int",18],[", ",17],["length",1],[": ",17],["Int",18],[") -> ",17],["ByteBuffer",18],["?",17]],"d":"Returns a slice of size `length` bytes, starting at `index`. The `ByteBuffer` this is invoked on and the\n`ByteBuffer` returned will share the same underlying storage. However, the byte at `index` in this `ByteBuffer`\nwill correspond to index `0` in the returned `ByteBuffer`.\nThe `readerIndex` of the returned `ByteBuffer` will be `0`, the `writerIndex` will be `length`.\n\nThe selected bytes must be readable or else `nil` will be returned.\n\n- parameters:\n    - index: The index the requested slice starts at.\n    - length: The length of the requested slice.\n- returns: A `ByteBuffer` containing the selected bytes as readable bytes or `nil` if the selected bytes were\n           not readable in the initial `ByteBuffer`."},{"p":["ByteBuffer","setBytes(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setBytes",7],["(",17],["_",1],[" ",17],["bytes",2],[": ",17],["UnsafeRawBufferPointer",18,1215],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setBytes",7],["(",17],["UnsafeRawBufferPointer",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Copy `bytes` into the `ByteBuffer` at `index`. Does not move the writer index."},{"p":["ByteBuffer","setBytes(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setBytes",7],["<",17],["Bytes",0],[">(",17],["_",1],[" ",17],["bytes",2],[": ",17],["Bytes",18],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227],[" ",17],["where",12],[" ",17],["Bytes",18],[" : ",17],["Sequence",18,1166],[", ",17],["Bytes",18],[".",17],["Element",18],[" == ",17],["UInt8",18,1384]],"s":[["func",12],[" ",17],["setBytes",7],["<",17],["Bytes",0],[">(",17],["Bytes",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"c":[["Bytes",1,"Sequence",1166],["Bytes.Element",2,"UInt8",1384]],"g":[["Bytes",0,0]],"d":"Copy the collection of `bytes` into the `ByteBuffer` at `index`. Does not move the writer index."},{"p":["ByteBuffer","copyBytes(at:to:length:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["copyBytes",7],["(",17],["at",1],[" ",17],["fromIndex",2],[": ",17],["Int",18,1227],[", ",17],["to",1],[" ",17],["toIndex",2],[": ",17],["Int",18,1227],[", ",17],["length",1],[": ",17],["Int",18,1227],[") ",17],["throws",12],[" -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["copyBytes",7],["(",17],["at",1],[": ",17],["Int",18],[", ",17],["to",1],[": ",17],["Int",18],[", ",17],["length",1],[": ",17],["Int",18],[") ",17],["throws",12],[" -> ",17],["Int",18]],"d":"Copies `length` `bytes` starting at the `fromIndex` to `toIndex`. Does not move the writer index.\n\n- Note: Overlapping ranges, for example `copyBytes(at: 1, to: 2, length: 5)` are allowed.\n- Precondition: The range represented by `fromIndex` and `length` must be readable bytes,\n    that is: `fromIndex >= readerIndex` and `fromIndex + length <= writerIndex`.\n- Parameter fromIndex: The index of the first byte to copy.\n- Parameter toIndex: The index into to which the first byte will be copied.\n- Parameter length: The number of bytes which should be copied."},{"p":["ByteBuffer","getString(at:length:)"],"f":[["func",12],[" ",17],["getString",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["length",1],[": ",17],["Int",18,1227],[") -> ",17],["String",18,1165],["?",17]],"s":[["func",12],[" ",17],["getString",7],["(",17],["at",1],[": ",17],["Int",18],[", ",17],["length",1],[": ",17],["Int",18],[") -> ",17],["String",18],["?",17]],"d":"Get the string at `index` from this `ByteBuffer` decoding using the UTF-8 encoding. Does not move the reader index.\nThe selected bytes must be readable or else `nil` will be returned.\n\n- parameters:\n    - index: The starting index into `ByteBuffer` containing the string of interest.\n    - length: The number of bytes making up the string.\n- returns: A `String` value containing the UTF-8 decoded selected bytes from this `ByteBuffer` or `nil` if\n           the requested bytes are not readable."},{"p":["ByteBuffer","readBytes(length:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readBytes",7],["(",17],["length",1],[": ",17],["Int",18,1227],[") -> [",17],["UInt8",18,1384],["]?",17]],"s":[["func",12],[" ",17],["readBytes",7],["(",17],["length",1],[": ",17],["Int",18],[") -> [",17],["UInt8",18],["]?",17]],"d":"Read `length` bytes off this `ByteBuffer`, move the reader index forward by `length` bytes and return the result\nas `[UInt8]`.\n\n- parameters:\n    - length: The number of bytes to be read from this `ByteBuffer`.\n- returns: A `[UInt8]` value containing `length` bytes or `nil` if there aren't at least `length` bytes readable."},{"p":["ByteBuffer","readSlice(length:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["readSlice",7],["(",17],["length",1],[": ",17],["Int",18,1227],[") -> ",17],["ByteBuffer",18,58],["?",17]],"s":[["func",12],[" ",17],["readSlice",7],["(",17],["length",1],[": ",17],["Int",18],[") -> ",17],["ByteBuffer",18],["?",17]],"d":"Slice `length` bytes off this `ByteBuffer` and move the reader index forward by `length`.\nIf enough bytes are readable the `ByteBuffer` returned by this method will share the underlying storage with\nthe `ByteBuffer` the method was invoked on.\nThe returned `ByteBuffer` will contain the bytes in the range `readerIndex..<(readerIndex + length)` of the\noriginal `ByteBuffer`.\nThe `readerIndex` of the returned `ByteBuffer` will be `0`, the `writerIndex` will be `length`.\n\n- note: Because `ByteBuffer` implements copy-on-write a copy of the storage will be automatically triggered when either of the `ByteBuffer`s sharing storage is written to.\n\n- parameters:\n    - length: The number of bytes to slice off.\n- returns: A `ByteBuffer` sharing storage containing `length` bytes or `nil` if the not enough bytes were readable."},{"p":["ByteBuffer","setString(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setString",7],["(",17],["_",1],[" ",17],["string",2],[": ",17],["String",18,1165],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setString",7],["(",17],["String",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"d":"Write `string` into this `ByteBuffer` at `index` using UTF-8 encoding. Does not move the writer index.\n\n- parameters:\n    - string: The string to write.\n    - index: The index for the first serialized byte.\n- returns: The number of bytes written."},{"p":["ByteBuffer","viewBytes(at:length:)"],"f":[["func",12],[" ",17],["viewBytes",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,1227],[", ",17],["length",1],[": ",17],["Int",18,1227],[") -> ",17],["ByteBufferView",18,74],["?",17]],"s":[["func",12],[" ",17],["viewBytes",7],["(",17],["at",1],[": ",17],["Int",18],[", ",17],["length",1],[": ",17],["Int",18],[") -> ",17],["ByteBufferView",18],["?",17]],"d":"Returns a view into some portion of the readable bytes of a `ByteBuffer`.\n\n- parameters:\n  - index: The index the view should start at\n  - length: The length of the view (in bytes)\n- returns: A view into a portion of a `ByteBuffer` or `nil` if the requested bytes were not readable."},{"p":["FileRegion","moveReaderIndex(forwardBy:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["moveReaderIndex",7],["(",17],["forwardBy",1],[" ",17],["offset",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["moveReaderIndex",7],["(",17],["forwardBy",1],[": ",17],["Int",18],[")",17]],"d":"Move the readerIndex forward by `offset`."},{"p":["ChannelCore","channelRead0(_:)"],"f":[["func",12],[" ",17],["channelRead0",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[")",17]],"s":[["func",12],[" ",17],["channelRead0",7],["(",17],["NIOAny",18],[")",17]],"d":"Called when data was read from the `Channel` but it was not consumed by any `ChannelInboundHandler` in the `ChannelPipeline`.\n\n- parameters:\n    - data: The data that was read, wrapped in a `NIOAny`."},{"p":["ChannelCore","errorCaught0(error:)"],"f":[["func",12],[" ",17],["errorCaught0",7],["(",17],["error",1],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["errorCaught0",7],["(",17],["error",1],[": ",17],["Error",18],[")",17]],"d":"Called when an inbound error was encountered but was not consumed by any `ChannelInboundHandler` in the `ChannelPipeline`.\n\n- parameters:\n    - error: The `Error` that was encountered."},{"p":["ChannelCore","localAddress0()"],"f":[["func",12],[" ",17],["localAddress0",7],["() ",17],["throws",12],[" -> ",17],["SocketAddress",18,43]],"s":[["func",12],[" ",17],["localAddress0",7],["() ",17],["throws",12],[" -> ",17],["SocketAddress",18]],"d":"Returns the local bound `SocketAddress`."},{"p":["ChannelCore","remoteAddress0()"],"f":[["func",12],[" ",17],["remoteAddress0",7],["() ",17],["throws",12],[" -> ",17],["SocketAddress",18,43]],"s":[["func",12],[" ",17],["remoteAddress0",7],["() ",17],["throws",12],[" -> ",17],["SocketAddress",18]],"d":"Return the connected `SocketAddress`."},{"p":["ChannelCore","triggerUserOutboundEvent0(_:promise:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent0",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent0",7],["(",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Trigger an outbound event.\n\n- parameters:\n    - event: The triggered event.\n    - promise: The `EventLoopPromise` which should be notified once the operation completes, or nil if no notification should take place."},{"p":["ChannelCore","registerAlreadyConfigured0(promise:)"],"f":[["func",12],[" ",17],["registerAlreadyConfigured0",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["registerAlreadyConfigured0",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Register channel as already connected or bound socket.\n- parameters:\n    - promise: The `EventLoopPromise` which should be notified once the operation completes, or nil if no notification should take place."},{"p":["ChannelCore","bind0(to:promise:)"],"f":[["func",12],[" ",17],["bind0",7],["(",17],["to",1],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["bind0",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Bind to a `SocketAddress`.\n\n- parameters:\n    - to: The `SocketAddress` to which we should bind the `Channel`.\n    - promise: The `EventLoopPromise` which should be notified once the operation completes, or nil if no notification should take place."},{"p":["ChannelCore","read0()"],"f":[["func",12],[" ",17],["read0",7],["()",17]],"s":[["func",12],[" ",17],["read0",7],["()",17]],"d":"Request that the `Channel` perform a read when data is ready."},{"p":["ChannelCore","close0(error:mode:promise:)"],"f":[["func",12],[" ",17],["close0",7],["(",17],["error",1],[": ",17],["Error",18,1380],[", ",17],["mode",1],[": ",17],["CloseMode",18,57],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["close0",7],["(",17],["error",1],[": ",17],["Error",18],[", ",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Close the `Channel`.\n\n- parameters:\n    - error: The `Error` which will be used to fail any pending writes.\n    - mode: The `CloseMode` to apply.\n    - promise: The `EventLoopPromise` which should be notified once the operation completes, or nil if no notification should take place."},{"p":["ChannelCore","flush0()"],"f":[["func",12],[" ",17],["flush0",7],["()",17]],"s":[["func",12],[" ",17],["flush0",7],["()",17]],"d":"Try to flush out all previous written messages that are pending."},{"p":["ChannelCore","write0(_:promise:)"],"f":[["func",12],[" ",17],["write0",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write0",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Write the given data to the outbound buffer.\n\n- parameters:\n    - data: The data to write, wrapped in a `NIOAny`.\n    - promise: The `EventLoopPromise` which should be notified once the operation completes, or nil if no notification should take place."},{"p":["ChannelCore","connect0(to:promise:)"],"f":[["func",12],[" ",17],["connect0",7],["(",17],["to",1],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["connect0",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Connect to a `SocketAddress`.\n\n- parameters:\n    - to: The `SocketAddress` to which we should connect the `Channel`.\n    - promise: The `EventLoopPromise` which should be notified once the operation completes, or nil if no notification should take place."},{"p":["ChannelCore","register0(promise:)"],"f":[["func",12],[" ",17],["register0",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["register0",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Register with the `EventLoop` to receive I/O notifications.\n\n- parameters:\n    - promise: The `EventLoopPromise` which should be notified once the operation completes, or nil if no notification should take place."},{"p":["ChannelCore","unwrapData(_:as:)"],"f":[["func",12],[" ",17],["unwrapData",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["as",1],[": ",17],["T",18],[".Type = T.self) -> ",17],["T",18]],"s":[["func",12],[" ",17],["unwrapData",7],["<",17],["T",0],[">(",17],["NIOAny",18],[", ",17],["as",1],[": ",17],["T",18],[".Type) -> ",17],["T",18]],"g":[["T",0,1]],"d":"Unwraps the given `NIOAny` as a specific concrete type.\n\nThis method is intended for use when writing custom `ChannelCore` implementations.\nThis can safely be called in methods like `write0` to extract data from the `NIOAny`\nprovided in those cases.\n\nNote that if the unwrap fails, this will cause a runtime trap. `ChannelCore`\nimplementations should be concrete about what types they support writing. If multiple\ntypes are supported, consider using a tagged union to store the type information like\nNIO's own `IOData`, which will minimise the amount of runtime type checking.\n\n- parameters:\n    - data: The `NIOAny` to unwrap.\n    - as: The type to extract from the `NIOAny`.\n- returns: The content of the `NIOAny`."},{"p":["ChannelCore","tryUnwrapData(_:as:)"],"f":[["func",12],[" ",17],["tryUnwrapData",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["as",1],[": ",17],["T",18],[".Type = T.self) -> ",17],["T",18],["?",17]],"s":[["func",12],[" ",17],["tryUnwrapData",7],["<",17],["T",0],[">(",17],["NIOAny",18],[", ",17],["as",1],[": ",17],["T",18],[".Type) -> ",17],["T",18],["?",17]],"g":[["T",0,1]],"d":"Attempts to unwrap the given `NIOAny` as a specific concrete type.\n\nThis method is intended for use when writing custom `ChannelCore` implementations.\nThis can safely be called in methods like `write0` to extract data from the `NIOAny`\nprovided in those cases.\n\nIf the unwrap fails, this will return `nil`. `ChannelCore` implementations should almost\nalways support only one runtime type, so in general they should avoid using this and prefer\nusing `unwrapData` instead. This method exists for rare use-cases where tolerating type\nmismatches is acceptable.\n\n- parameters:\n    - data: The `NIOAny` to unwrap.\n    - as: The type to extract from the `NIOAny`.\n- returns: The content of the `NIOAny`, or `nil` if the type is incorrect.\n- warning: If you are implementing a `ChannelCore`, you should use `unwrapData` unless you\n    are doing something _extremely_ unusual."},{"p":["ChannelCore","removeHandlers(channel:)"],"f":[["func",12],[" ",17],["removeHandlers",7],["(",17],["channel",1],[": ",17],["Channel",18,27],[")",17]],"s":[["func",12],[" ",17],["removeHandlers",7],["(",17],["channel",1],[": ",17],["Channel",18],[")",17]],"a":{"a":{"d":true,"r":"removeHandlers(pipeline:)"}},"d":"Removes the `ChannelHandler`s from the `ChannelPipeline` belonging to `channel`, and\ncloses that `ChannelPipeline`.\n\nThis method is intended for use when writing custom `ChannelCore` implementations.\nThis can be called from `close0` to tear down the `ChannelPipeline` when closure is\ncomplete.\n\n- parameters:\n    - channel: The `Channel` whose `ChannelPipeline` will be closed."},{"p":["ChannelCore","removeHandlers(pipeline:)"],"f":[["func",12],[" ",17],["removeHandlers",7],["(",17],["pipeline",1],[": ",17],["ChannelPipeline",18,120],[")",17]],"s":[["func",12],[" ",17],["removeHandlers",7],["(",17],["pipeline",1],[": ",17],["ChannelPipeline",18],[")",17]],"d":"Removes the `ChannelHandler`s from the `ChannelPipeline` `pipeline`, and\ncloses that `ChannelPipeline`.\n\nThis method is intended for use when writing custom `ChannelCore` implementations.\nThis can be called from `close0` to tear down the `ChannelPipeline` when closure is\ncomplete.\n\n- parameters:\n    - pipeline: The `ChannelPipline` to be closed."},{"p":["RepeatedTask","cancel(promise:)"],"f":[["func",12],[" ",17],["cancel",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">? = nil)",17]],"s":[["func",12],[" ",17],["cancel",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Try to cancel the execution of the repeated task.\n\nWhether the execution of the task is immediately canceled depends on whether the execution of a task has already begun.\n This means immediate cancellation is not guaranteed.\n\nThe safest way to cancel is by using the passed reference of `RepeatedTask` inside the task closure.\n\nIf the promise parameter is not `nil`, the passed promise is fulfilled when cancellation is complete.\nPassing a promise does not prevent fulfillment of any promise provided on original task creation."},{"p":["NIOFileHandle","takeDescriptorOwnership()"],"f":[["func",12],[" ",17],["takeDescriptorOwnership",7],["() ",17],["throws",12],[" -> ",17],["CInt",18,1378]],"s":[["func",12],[" ",17],["takeDescriptorOwnership",7],["() ",17],["throws",12],[" -> ",17],["CInt",18]],"d":"Take the ownership of the underlying file descriptor. This is similar to `close()` but the underlying file\ndescriptor remains open. The caller is responsible for closing the file descriptor by some other means.\n\nAfter calling this, the `NIOFileHandle` cannot be used for anything else and all the operations will throw.\n\n- returns: The underlying file descriptor, now owned by the caller."},{"p":["NIOFileHandle","withUnsafeFileDescriptor(_:)"],"f":[["func",12],[" ",17],["withUnsafeFileDescriptor",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["CInt",18,1378],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["throws",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withUnsafeFileDescriptor",7],["<",17],["T",0],[">((",17],["CInt",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["throws",12],[" -> ",17],["T",18]],"g":[["T",0,0]]},{"p":["NIOFileHandle","close()"],"f":[["func",12],[" ",17],["close",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["close",7],["() ",17],["throws",12]]},{"p":["NIOFileHandle","duplicate()"],"f":[["func",12],[" ",17],["duplicate",7],["() ",17],["throws",12],[" -> ",17],["NIOFileHandle",18,119]],"s":[["func",12],[" ",17],["duplicate",7],["() ",17],["throws",12],[" -> ",17],["NIOFileHandle",18]],"d":"Duplicates this `NIOFileHandle`. This means that a new `NIOFileHandle` object with a new underlying file descriptor\nis returned. The caller takes ownership of the returned `NIOFileHandle` and is responsible for closing it.\n\n- warning: The returned `NIOFileHandle` is not fully independent, the seek pointer is shared as documented by `dup(2)`.\n\n- returns: A new `NIOFileHandle` with a fresh underlying file descriptor but shared seek pointer."},{"p":["SocketAddress","withSockAddr(_:)"],"f":[["func",12],[" ",17],["withSockAddr",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafePointer",18,1160],["<",17],["sockaddr",18,1094],[">, ",17],["Int",18,1227],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withSockAddr",7],["<",17],["T",0],[">((",17],["UnsafePointer",18],["<",17],["sockaddr",18],[">, ",17],["Int",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["T",18]],"g":[["T",0,0]],"d":"Calls the given function with a pointer to a `sockaddr` structure and the associated size\nof that structure."},{"p":["SocketAddress","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,1385],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]]},{"p":["ByteBufferView","replaceSubrange(_:with:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["replaceSubrange",7],["<",17],["C",0],[">(",17],["_",1],[" ",17],["subrange",2],[": ",17],["Range",18,1338],["<",17],["ByteBufferView",18,74],[".",17],["Index",18,1036],[">, ",17],["with",1],[" ",17],["newElements",2],[": ",17],["C",18],[") ",17],["where",12],[" ",17],["C",18],[" : ",17],["Collection",18,1233],[", ",17],["C",18],[".",17],["Element",18],[" == ",17],["UInt8",18,1384]],"s":[["func",12],[" ",17],["replaceSubrange",7],["<",17],["C",0],[">(",17],["Range",18],["<",17],["ByteBufferView",18],[".",17],["Index",18],[">, ",17],["with",1],[": ",17],["C",18],[")",17]],"c":[["C",1,"Collection",1233],["C.Element",2,"UInt8",1384]],"g":[["C",0,0]]},{"p":["ByteBufferView","withUnsafeBytes(_:)"],"f":[["func",12],[" ",17],["withUnsafeBytes",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeRawBufferPointer",18,1215],[") ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"s":[["func",12],[" ",17],["withUnsafeBytes",7],["<",17],["R",0],[">((",17],["UnsafeRawBufferPointer",18],[") ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"g":[["R",0,0]]},{"p":["ByteBufferView","withContiguousStorageIfAvailable(_:)"],"f":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeBufferPointer",18,1164],["<",17],["UInt8",18,1384],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"s":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">((",17],["UnsafeBufferPointer",18],["<",17],["UInt8",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"g":[["R",0,0]]},{"p":["ByteBufferView","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,1385],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"d":"required by `Hashable`"},{"p":["ByteBufferView","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["ByteBufferView",18,74],[".",17],["Index",18,1036],[") -> ",17],["ByteBufferView",18,74],[".",17],["Index",18,1036]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["ByteBufferView",18],[".",17],["Index",18],[") -> ",17],["ByteBufferView",18],[".",17],["Index",18]]},{"p":["ChannelHandler","handlerAdded(context:)"],"f":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"d":"Called when this `ChannelHandler` is added to the `ChannelPipeline`.\n\n- parameters:\n    - context: The `ChannelHandlerContext` which this `ChannelHandler` belongs to."},{"p":["ChannelHandler","handlerRemoved(context:)"],"f":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"d":"Called when this `ChannelHandler` is removed from the `ChannelPipeline`.\n\n- parameters:\n    - context: The `ChannelHandlerContext` which this `ChannelHandler` belongs to."},{"p":["ChannelHandler","handlerAdded(context:)"],"f":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"d":"Do nothing by default."},{"p":["ChannelHandler","handlerRemoved(context:)"],"f":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"d":"Do nothing by default."},{"p":["ChannelOptions","TCPConvenienceOptions","consumeDisableAutoRead()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["consumeDisableAutoRead",7],["() -> ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["ConvenienceOptionValue",18,45],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["consumeDisableAutoRead",7],["() -> ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["ConvenienceOptionValue",18],["<",17],["Void",18],[">",17]],"d":"Caller is consuming the knowledge that disableAutoRead was set or not.\nThe setting will nolonger be set after this call.\n- Returns: If disableAutoRead was set."},{"p":["ChannelOptions","TCPConvenienceOptions","consumeAllowRemoteHalfClosure()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["consumeAllowRemoteHalfClosure",7],["() -> ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["ConvenienceOptionValue",18,45],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["consumeAllowRemoteHalfClosure",7],["() -> ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["ConvenienceOptionValue",18],["<",17],["Void",18],[">",17]],"d":"Caller is consuming the knowledge that allowRemoteHalfClosure was set or not.\nThe setting will nolonger be set after this call.\n- Returns: If allowRemoteHalfClosure was set."},{"p":["ChannelOptions","TCPConvenienceOptions","consumeAllowLocalEndpointReuse()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["consumeAllowLocalEndpointReuse",7],["() -> ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["ConvenienceOptionValue",18,45],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["consumeAllowLocalEndpointReuse",7],["() -> ",17],["ChannelOptions",18],[".",17],["Types",18],[".",17],["ConvenienceOptionValue",18],["<",17],["Void",18],[">",17]],"d":"Caller is consuming the knowledge that `allowLocalEndpointReuse` was set or not.\nThe setting will nolonger be set after this call.\n- Returns: If `allowLocalEndpointReuse` was set."},{"p":["ChannelOptions","Storage","applyAllChannelOptions(to:)"],"f":[["func",12],[" ",17],["applyAllChannelOptions",7],["(",17],["to",1],[" ",17],["channel",2],[": ",17],["Channel",18,27],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["applyAllChannelOptions",7],["(",17],["to",1],[": ",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Apply all stored `ChannelOption`s to `Channel`.\n\n- parameters:\n   - channel: The `Channel` to apply the `ChannelOption`s to\n- returns:\n   - An `EventLoopFuture` that is fulfilled when all `ChannelOption`s have been applied to the `Channel`."},{"p":["ChannelOptions","Storage","append(key:value:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["append",7],["<",17],["Option",0],[">(",17],["key",1],[" ",17],["newKey",2],[": ",17],["Option",18],[", ",17],["value",1],[" ",17],["newValue",2],[": ",17],["Option",18],[".",17],["Value",18],[") ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["append",7],["<",17],["Option",0],[">(",17],["key",1],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[")",17]],"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,0]],"d":"Add `Options`, a `ChannelOption` to the `ChannelOptions.Storage`.\n\n- parameters:\n   - key: the key for the option\n   - value: the value for the option"},{"p":["CircularBuffer","removeLast()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["() -> ",17],["Element",18]],"s":[["func",12],[" ",17],["removeLast",7],["() -> ",17],["Element",18]],"g":[["Element",0,0]],"d":"Removes and returns the last element of the `CircularBuffer`.\n\nThe `CircularBuffer` must not be empty.\n\nCalling this method may invalidate all saved indices of this\n`CircularBuffer`. Do not rely on a previously stored index value after\naltering the `CircularBuffer` with any operation that can change its length.\n\n- Returns: The last element of the `CircularBuffer`.\n\n- Complexity: O(*1*)"},{"p":["CircularBuffer","removeLast(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["(",17],["_",1],[" ",17],["k",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["removeLast",7],["(",17],["Int",18],[")",17]],"g":[["Element",0,0]],"d":"Removes the specified number of elements from the end of the\n`CircularBuffer`.\n\nAttempting to remove more elements than exist in the `CircularBuffer`\ntriggers a runtime error.\n\nCalling this method may invalidate all saved indices of this\n`CircularBuffer`. Do not rely on a previously stored index value after\naltering a `CircularBuffer` with any operation that can change its length.\n\n- Parameter k: The number of elements to remove from the `CircularBuffer`.\n  `k` must be greater than or equal to zero and must not exceed the\n  number of elements in the `CircularBuffer`.\n\n- Complexity: O(*k*), where *k* is the specified number of elements."},{"p":["CircularBuffer","removeFirst()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["() -> ",17],["Element",18]],"s":[["func",12],[" ",17],["removeFirst",7],["() -> ",17],["Element",18]],"g":[["Element",0,0]],"d":"Removes and returns the first element of the `CircularBuffer`.\n\nThe `CircularBuffer` must not be empty.\n\nCalling this method may invalidate any existing indices for use with this\n`CircularBuffer`.\n\n- Returns: The removed element.\n\n- Complexity: O(*1*)"},{"p":["CircularBuffer","removeFirst(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["(",17],["_",1],[" ",17],["k",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["removeFirst",7],["(",17],["Int",18],[")",17]],"g":[["Element",0,0]],"d":"Removes the specified number of elements from the beginning of the\n`CircularBuffer`.\n\nCalling this method may invalidate any existing indices for use with this\n`CircularBuffer`.\n\n- Parameter k: The number of elements to remove.\n  `k` must be greater than or equal to zero and must not exceed the\n  number of elements in the `CircularBuffer`.\n\n- Complexity: O(*k*), where *k* is the specified number of elements."},{"p":["CircularBuffer","removeSubrange(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeSubrange",7],["(",17],["_",1],[" ",17],["bounds",2],[": ",17],["Range",18,1338],["<",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[">)",17]],"s":[["func",12],[" ",17],["removeSubrange",7],["(",17],["Range",18],["<",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[">)",17]],"g":[["Element",0,0]],"d":"Removes the elements in the specified subrange from the circular buffer.\n\n- Parameter bounds: The range of the circular buffer to be removed. The bounds of the range must be valid indices of the collection."},{"p":["CircularBuffer","replaceSubrange(_:with:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["replaceSubrange",7],["<",17],["C",0],[">(",17],["_",1],[" ",17],["subrange",2],[": ",17],["Range",18,1338],["<",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[">, ",17],["with",1],[" ",17],["newElements",2],[": ",17],["C",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["C",18],[".",17],["Element",18],[", ",17],["C",18],[" : ",17],["Collection",18,1233]],"s":[["func",12],[" ",17],["replaceSubrange",7],["<",17],["C",0],[">(",17],["Range",18],["<",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[">, ",17],["with",1],[": ",17],["C",18],[")",17]],"c":[["Element",2,"C.Element"],["C",1,"Collection",1233]],"g":[["Element",0,0],["C",0,1]],"d":"Replaces the specified subrange of elements with the given `CircularBuffer`.\n\n- Parameter subrange: The subrange of the collection to replace. The bounds of the range must be valid indices\n                      of the `CircularBuffer`.\n\n- Parameter newElements: The new elements to add to the `CircularBuffer`.\n\n*O(n)* where _n_ is the length of the new elements collection if the subrange equals to _n_\n\n*O(m)* where _m_ is the combined length of the collection and _newElements_"},{"p":["CircularBuffer","reserveCapacity(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reserveCapacity",7],["(",17],["_",1],[" ",17],["minimumCapacity",2],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["reserveCapacity",7],["(",17],["Int",18],[")",17]],"g":[["Element",0,0]],"d":"Prepares the `CircularBuffer` to store the specified number of elements."},{"p":["CircularBuffer","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[") -> ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"g":[["Element",0,0]],"d":"Returns the position immediately after the given index.\n\nThe successor of an index must be well defined. For an index `i` into a\ncollection `c`, calling `c.index(after: i)` returns the same index every\ntime.\n\n- Parameter i: A valid index of the collection. `i` must be less than\n  `endIndex`.\n- Returns: The index value immediately after `i`."},{"p":["CircularBuffer","index(before:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[") -> ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94]],"s":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"g":[["Element",0,0]],"d":"Returns the index before `index`."},{"p":["CircularBuffer","index(_:offsetBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,1227],[") -> ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94]],"s":[["func",12],[" ",17],["index",7],["(",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[") -> ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"g":[["Element",0,0]],"d":"Returns the index offset by `distance` from `index`.\n\nThe following example obtains an index advanced four positions from a\nstring's starting index and then prints the character at that position.\n\n    let s = \"Swift\"\n    let i = s.index(s.startIndex, offsetBy: 4)\n    print(s[i])\n    // Prints \"t\"\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection.\n\n- Parameters:\n  - i: A valid index of the collection.\n  - distance: The distance to offset `i`. `distance` must not be negative\n    unless the collection conforms to the `BidirectionalCollection`\n    protocol.\n- Returns: An index offset by `distance` from the index `i`. If\n  `distance` is positive, this is the same value as the result of\n  `distance` calls to `index(after:)`. If `distance` is negative, this\n  is the same value as the result of `abs(distance)` calls to\n  `index(before:)`.\n\n- Complexity: O(1) if the collection conforms to\n  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute\n  value of `distance`."},{"p":["CircularBuffer","append(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["append",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Element",18],[")",17]],"s":[["func",12],[" ",17],["append",7],["(",17],["Element",18],[")",17]],"g":[["Element",0,0]],"d":"Append an element to the end of the ring buffer.\n\nAmortized *O(1)*"},{"p":["CircularBuffer","modify(_:_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["modify",7],["<",17],["Result",0],[">(",17],["_",1],[" ",17],["index",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[", ",17],["_",1],[" ",17],["modifyFunc",2],[": (",17],["inout",12],[" ",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Result",18],[") ",17],["rethrows",12],[" -> ",17],["Result",18]],"s":[["func",12],[" ",17],["modify",7],["<",17],["Result",0],[">(",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[", (",17],["inout",12],[" ",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Result",18],[") ",17],["rethrows",12],[" -> ",17],["Result",18]],"g":[["Element",0,0],["Result",0,1]],"d":"Modify the element at `index`.\n\nThis function exists to provide a method of modifying the element in its underlying backing storage, instead\nof copying it out, modifying it, and copying it back in. This emulates the behaviour of the `_modify` accessor\nthat is part of the generalized accessors work. That accessor is currently underscored and not safe to use, so\nthis is the next best thing.\n\nNote that this function is not guaranteed to be fast. In particular, as it is both generic and accepts a closure\nit is possible that it will be slower than using the get/modify/set path that occurs with the subscript. If you\nare interested in using this function for performance you *must* test and verify that the optimisation applies\ncorrectly in your situation.\n\n- parameters:\n    - index: The index of the object that should be modified. If this index is invalid this function will trap.\n    - modifyFunc: The function to apply to the modified object."},{"p":["CircularBuffer","remove(at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["remove",7],["(",17],["at",1],[" ",17],["position",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[") -> ",17],["Element",18]],"s":[["func",12],[" ",17],["remove",7],["(",17],["at",1],[": ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Element",18]],"g":[["Element",0,0]],"d":"Removes & returns the item at `position` from the buffer\n\n- Parameter position: The index of the item to be removed from the buffer.\n\n*O(1)* if the position is `headIdx` or `tailIdx`.\notherwise\n*O(n)* where *n* is the number of elements between `position` and `tailIdx`."},{"p":["CircularBuffer","popLast()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["popLast",7],["() -> ",17],["Element",18],["?",17]],"s":[["func",12],[" ",17],["popLast",7],["() -> ",17],["Element",18],["?",17]],"g":[["Element",0,0]],"d":"Removes and returns the last element of the `CircularBuffer`.\n\nCalling this method may invalidate all saved indices of this\n`CircularBuffer`. Do not rely on a previously stored index value after\naltering a `CircularBuffer` with any operation that can change its length.\n\n- Returns: The last element of the `CircularBuffer` if the `CircularBuffer` is not\n           empty; otherwise, `nil`.\n\n- Complexity: O(1)"},{"p":["CircularBuffer","prepend(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["prepend",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Element",18],[")",17]],"s":[["func",12],[" ",17],["prepend",7],["(",17],["Element",18],[")",17]],"g":[["Element",0,0]],"d":"Prepend an element to the front of the ring buffer.\n\nAmortized *O(1)*"},{"p":["CircularBuffer","distance(from:to:)"],"f":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[" ",17],["start",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[", ",17],["to",1],[" ",17],["end",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[": ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[", ",17],["to",1],[": ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Int",18]],"g":[["Element",0,0]],"d":"Returns the distance between two indices.\n\nUnless the collection conforms to the `BidirectionalCollection` protocol,\n`start` must be less than or equal to `end`.\n\n- Parameters:\n  - start: A valid index of the collection.\n  - end: Another valid index of the collection. If `end` is equal to\n    `start`, the result is zero.\n- Returns: The distance between `start` and `end`. The result can be\n  negative only if the collection conforms to the\n  `BidirectionalCollection` protocol.\n\n- Complexity: O(1) if the collection conforms to\n  `RandomAccessCollection`; otherwise, O(*k*), where *k* is the\n  resulting distance."},{"p":["CircularBuffer","popFirst()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["popFirst",7],["() -> ",17],["Element",18],["?",17]],"s":[["func",12],[" ",17],["popFirst",7],["() -> ",17],["Element",18],["?",17]],"g":[["Element",0,0]],"d":"Removes and returns the first element of the `CircularBuffer`.\n\nCalling this method may invalidate all saved indices of this\n`CircularBuffer`. Do not rely on a previously stored index value after\naltering a `CircularBuffer` with any operation that can change its length.\n\n- Returns: The first element of the `CircularBuffer` if the `CircularBuffer` is not\n           empty; otherwise, `nil`.\n\n- Complexity: O(1)"},{"p":["CircularBuffer","removeAll(keepingCapacity:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[": ",17],["Bool",18,1224],[" = false)",17]],"s":[["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[": ",17],["Bool",18],[")",17]],"g":[["Element",0,0]],"d":"Removes all members from the circular buffer whist keeping the capacity."},{"p":["CircularBuffer","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,1385],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["Element",1,"Hashable",1112]],"c":[["Element",1,"Hashable",1112]],"g":[["Element",0,0]]},{"p":["EventLoopGroup","makeIterator()"],"f":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["EventLoopIterator",18,101]],"s":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["EventLoopIterator",18]],"d":"Returns an `EventLoopIterator` over the `EventLoop`s in this `EventLoopGroup`.\n\n- returns: `EventLoopIterator`"},{"p":["EventLoopGroup","shutdownGracefully(queue:_:)"],"f":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18,1111],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],["?) -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["queue",1],[": ",17],["DispatchQueue",18],[", (",17],["Error",18],["?) -> ",17],["Void",18],[")",17]],"d":"Shuts down the eventloop gracefully. This function is clearly an outlier in that it uses a completion\ncallback instead of an EventLoopFuture. The reason for that is that NIO's EventLoopFutures will call back on an event loop.\nThe virtue of this function is to shut the event loop down. To work around that we call back on a DispatchQueue\ninstead."},{"p":["EventLoopGroup","any()"],"f":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18,28]],"s":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18]],"d":"Returns any `EventLoop` from the `EventLoopGroup`, a common choice is the current `EventLoop`.\n\n- warning: You cannot rely on the returned `EventLoop` being the current one, not all `EventLoopGroup`s support\n           choosing the current one. Use this method only if you are truly happy with _any_ `EventLoop` of this\n           `EventLoopGroup` instance.\n\n- note: You will only receive the current `EventLoop` here iff the current `EventLoop` belongs to the\n        `EventLoopGroup` you call `any()` on.\n\nThis method is useful having access to an `EventLoopGroup` without the knowledge of which `EventLoop` would be\nthe best one to select to create a new `EventLoopFuture`. This commonly happens in libraries where the user\ncannot indicate what `EventLoop` they would like their futures on.\n\nTypically, it is faster to kick off a new operation on the _current_ `EventLoop` because that minimised thread\nswitches. Hence, if situations where you don't need precise knowledge of what `EventLoop` some code is running\non, use `any()` to indicate this.\n\nThe rule of thumb is: If you are trying to do _load balancing_, use `next()`. If you just want to create a new\nfuture or kick off some operation, use `any()`."},{"p":["EventLoopGroup","next()"],"f":[["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18,28]],"s":[["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18]],"d":"Returns the next `EventLoop` to use, this is useful for load balancing.\n\nThe algorithm that is used to select the next `EventLoop` is specific to each `EventLoopGroup`. A common choice\nis _round robin_.\n\nPlease note that you should only be using `next()` if you want to load balance over all `EventLoop`s of the\n`EventLoopGroup`. If the actual `EventLoop` does not matter much, `any()` should be preferred because it can\ntry to return you the _current_ `EventLoop` which usually is faster because the number of thread switches can\nbe reduced.\n\nThe rule of thumb is: If you are trying to do _load balancing_, use `next()`. If you just want to create a new\nfuture or kick off some operation, use `any()`."},{"p":["EventLoopGroup","shutdownGracefully()"],"f":[["func",12],[" ",17],["shutdownGracefully",7],["() ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["shutdownGracefully",7],["() ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Shuts down the event loop gracefully."},{"p":["EventLoopGroup","shutdownGracefully(_:)"],"f":[["func",12],[" ",17],["shutdownGracefully",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],["?) -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["shutdownGracefully",7],["((",17],["Error",18],["?) -> ",17],["Void",18],[")",17]]},{"p":["EventLoopGroup","syncShutdownGracefully()"],"f":[["func",12],[" ",17],["syncShutdownGracefully",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["syncShutdownGracefully",7],["() ",17],["throws",12]]},{"p":["EventLoopGroup","any()"],"f":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18,28]],"s":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18]],"d":"The default implementation of `any()` just returns the `next()` EventLoop but it's highly recommended to\noverride this and return the current `EventLoop` if possible."},{"p":["FileDescriptor","withUnsafeFileDescriptor(_:)"],"f":[["func",12],[" ",17],["withUnsafeFileDescriptor",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["CInt",18,1378],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["throws",12],[" -> ",17],["T",18]],"s":[["func",12],[" ",17],["withUnsafeFileDescriptor",7],["<",17],["T",0],[">((",17],["CInt",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["throws",12],[" -> ",17],["T",18]],"g":[["T",0,1]],"d":"Will be called with the file descriptor if still open, if not it will\nthrow an `IOError`.\n\nThe ownership of the file descriptor must not escape the `body` as it's completely managed by the\nimplementation of the `FileDescriptor` protocol.\n\n- parameters:\n    - body: The closure to execute if the `FileDescriptor` is still open.\n- throws: If either the `FileDescriptor` was closed before or the closure throws by itself."},{"p":["FileDescriptor","close()"],"f":[["func",12],[" ",17],["close",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["close",7],["() ",17],["throws",12]],"d":"Close this `FileDescriptor`."},{"p":["ChannelPipeline","fireChannelRegistered()"],"f":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]]},{"p":["ChannelPipeline","fireChannelReadComplete()"],"f":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]]},{"p":["ChannelPipeline","fireChannelUnregistered()"],"f":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]]},{"p":["ChannelPipeline","fireChannelWritabilityChanged()"],"f":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]]},{"p":["ChannelPipeline","fireChannelRead(_:)"],"f":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[")",17]],"s":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["NIOAny",18],[")",17]]},{"p":["ChannelPipeline","fireChannelActive()"],"f":[["func",12],[" ",17],["fireChannelActive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelActive",7],["()",17]]},{"p":["ChannelPipeline","fireChannelInactive()"],"f":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]]},{"p":["ChannelPipeline","addHandler(_:name:position:)"],"f":[["func",12],[" ",17],["addHandler",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["ChannelHandler",18,8],[", ",17],["name",1],[": ",17],["String",18,1165],["? = nil, ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["addHandler",7],["(",17],["ChannelHandler",18],[", ",17],["name",1],[": ",17],["String",18],["?, ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Add a `ChannelHandler` to the `ChannelPipeline`.\n\n- parameters:\n    - name: the name to use for the `ChannelHandler` when it's added. If none is specified it will generate a name.\n    - handler: the `ChannelHandler` to add\n    - position: The position in the `ChannelPipeline` to add `handler`. Defaults to `.last`.\n- returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was added."},{"p":["ChannelPipeline","addHandler(_:name:position:)"],"f":[["func",12],[" ",17],["addHandler",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["ChannelHandler",18,8],[", ",17],["name",1],[": ",17],["String",18,1165],["? = nil, ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["addHandler",7],["(",17],["ChannelHandler",18],[", ",17],["name",1],[": ",17],["String",18],["?, ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","addHandlers(_:position:)"],"f":[["func",12],[" ",17],["addHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": ",17],["ChannelHandler",18,8],["..., ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["addHandlers",7],["(",17],["ChannelHandler",18],["..., ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Adds the provided channel handlers to the pipeline in the order given, taking account\nof the behaviour of `ChannelHandler.add(first:)`.\n\n- parameters:\n    - handlers: One or more `ChannelHandler`s to be added.\n    - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.\n\n- returns: A future that will be completed when all of the supplied `ChannelHandler`s were added."},{"p":["ChannelPipeline","addHandlers(_:position:)"],"f":[["func",12],[" ",17],["addHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": [",17],["ChannelHandler",18,8],["], ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["addHandlers",7],["([",17],["ChannelHandler",18],["], ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Adds the provided channel handlers to the pipeline in the order given, taking account\nof the behaviour of `ChannelHandler.add(first:)`.\n\n- parameters:\n    - handlers: The array of `ChannelHandler`s to be added.\n    - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`.\n\n- returns: A future that will be completed when all of the supplied `ChannelHandler`s were added."},{"p":["ChannelPipeline","addHandlers(_:position:)"],"f":[["func",12],[" ",17],["addHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": ",17],["ChannelHandler",18,8],["..., ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["addHandlers",7],["(",17],["ChannelHandler",18],["..., ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","addHandlers(_:position:)"],"f":[["func",12],[" ",17],["addHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": [",17],["ChannelHandler",18,8],["], ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["addHandlers",7],["([",17],["ChannelHandler",18],["], ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","removeHandler(name:promise:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["name",1],[": ",17],["String",18,1165],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["name",1],[": ",17],["String",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Remove a `ChannelHandler` from the `ChannelPipeline`.\n\n- parameters:\n    - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.\n    - promise: An `EventLoopPromise` that will complete when the `ChannelHandler` is removed."},{"p":["ChannelPipeline","removeHandler(name:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["name",1],[": ",17],["String",18,1165],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["name",1],[": ",17],["String",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Remove a `ChannelHandler` from the `ChannelPipeline`.\n\n- parameters:\n    - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.\n- returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed."},{"p":["ChannelPipeline","removeHandler(name:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["name",1],[": ",17],["String",18,1165],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["name",1],[": ",17],["String",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","removeHandler(context:promise:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Remove a `ChannelHandler` from the `ChannelPipeline`.\n\n- parameters:\n    - context: the `ChannelHandlerContext` that belongs to `ChannelHandler` that should be removed.\n    - promise: An `EventLoopPromise` that will complete when the `ChannelHandler` is removed."},{"p":["ChannelPipeline","removeHandler(context:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Remove a `ChannelHandler` from the `ChannelPipeline`.\n\n- parameters:\n    - context: the `ChannelHandlerContext` that belongs to `ChannelHandler` that should be removed.\n- returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed."},{"p":["ChannelPipeline","removeHandler(context:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","removeHandler(_:promise:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["RemovableChannelHandler",18,22],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["RemovableChannelHandler",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Remove a `ChannelHandler` from the `ChannelPipeline`.\n\n- parameters:\n    - handler: the `ChannelHandler` to remove.\n    - promise: An `EventLoopPromise` that will complete when the `ChannelHandler` is removed."},{"p":["ChannelPipeline","removeHandler(_:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["RemovableChannelHandler",18,22],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["RemovableChannelHandler",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Remove a `ChannelHandler` from the `ChannelPipeline`.\n\n- parameters:\n    - handler: the `ChannelHandler` to remove.\n- returns: the `EventLoopFuture` which will be notified once the `ChannelHandler` was removed."},{"p":["ChannelPipeline","removeHandler(_:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["RemovableChannelHandler",18,22],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["RemovableChannelHandler",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","writeAndFlush(_:promise:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["ChannelPipeline","fireErrorCaught(_:)"],"f":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["_",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["Error",18],[")",17]]},{"p":["ChannelPipeline","SynchronousOperations","fireChannelRegistered()"],"f":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]],"d":"Fires `channelRegistered` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireChannelReadComplete()"],"f":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]],"d":"Fires `channelReadComplete` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireChannelUnregistered()"],"f":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]],"d":"Fires `channelUnregistered` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireChannelWritabilityChanged()"],"f":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]],"d":"Fires `channelWritabilityChanged` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireChannelRead(_:)"],"f":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[")",17]],"s":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["NIOAny",18],[")",17]],"d":"Fires `channelRead` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireChannelActive()"],"f":[["func",12],[" ",17],["fireChannelActive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelActive",7],["()",17]],"d":"Fires `channelActive` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireChannelInactive()"],"f":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]],"d":"Fires `channelInactive` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","addHandler(_:name:position:)"],"f":[["func",12],[" ",17],["addHandler",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["ChannelHandler",18,8],[", ",17],["name",1],[": ",17],["String",18,1165],["? = nil, ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) ",17],["throws",12]],"s":[["func",12],[" ",17],["addHandler",7],["(",17],["ChannelHandler",18],[", ",17],["name",1],[": ",17],["String",18],["?, ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") ",17],["throws",12]],"d":"Add a handler to the pipeline.\n\n- Important: This *must* be called on the event loop.\n- Parameters:\n  - handler: The handler to add.\n  - name: The name to use for the `ChannelHandler` when it's added. If no name is specified the one will be generated.\n  - position: The position in the `ChannelPipeline` to add `handler`. Defaults to `.last`."},{"p":["ChannelPipeline","SynchronousOperations","addHandlers(_:position:)"],"f":[["func",12],[" ",17],["addHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": ",17],["ChannelHandler",18,8],["..., ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) ",17],["throws",12]],"s":[["func",12],[" ",17],["addHandlers",7],["(",17],["ChannelHandler",18],["..., ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") ",17],["throws",12]],"d":"Add one or more handlers to the pipeline.\n\n- Important: This *must* be called on the event loop.\n- Parameters:\n  - handlers: The handlers to add.\n  - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`."},{"p":["ChannelPipeline","SynchronousOperations","addHandlers(_:position:)"],"f":[["func",12],[" ",17],["addHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": [",17],["ChannelHandler",18,8],["], ",17],["position",1],[": ",17],["ChannelPipeline",18,120],[".",17],["Position",18,47],[" = .last) ",17],["throws",12]],"s":[["func",12],[" ",17],["addHandlers",7],["([",17],["ChannelHandler",18],["], ",17],["position",1],[": ",17],["ChannelPipeline",18],[".",17],["Position",18],[") ",17],["throws",12]],"d":"Add an array of handlers to the pipeline.\n\n- Important: This *must* be called on the event loop.\n- Parameters:\n  - handlers: The handlers to add.\n  - position: The position in the `ChannelPipeline` to add `handlers`. Defaults to `.last`."},{"p":["ChannelPipeline","SynchronousOperations","writeAndFlush(_:promise:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires `writeAndFlush` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireErrorCaught(_:)"],"f":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["_",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["Error",18],[")",17]],"d":"Fires `errorCaught` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","triggerUserOutboundEvent(_:promise:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires `triggerUserOutboundEvent` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","fireUserInboundEventTriggered(_:)"],"f":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[")",17]],"s":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["Any",12],[")",17]],"d":"Fires `userInboundEventTriggered` from the head to the tail.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","bind(to:promise:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires `bind` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","read()"],"f":[["func",12],[" ",17],["read",7],["()",17]],"s":[["func",12],[" ",17],["read",7],["()",17]],"d":"Fires `read` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","close(mode:promise:)"],"f":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18,57],[" = .all, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires `close` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","flush()"],"f":[["func",12],[" ",17],["flush",7],["()",17]],"s":[["func",12],[" ",17],["flush",7],["()",17]],"d":"Fires `flush` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","write(_:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires `write` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","connect(to:promise:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires `connect` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","SynchronousOperations","context(handlerType:)"],"f":[["func",12],[" ",17],["context",7],["<",17],["Handler",0],[">(",17],["handlerType",1],[": ",17],["Handler",18],[".Type) ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18,128],[" ",17],["where",12],[" ",17],["Handler",18],[" : ",17],["ChannelHandler",18,8]],"s":[["func",12],[" ",17],["context",7],["<",17],["Handler",0],[">(",17],["handlerType",1],[": ",17],["Handler",18],[".Type) ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18]],"c":[["Handler",1,"ChannelHandler",8]],"g":[["Handler",0,0]],"d":"Returns the `ChannelHandlerContext` for the handler of given type, if one exists.\n\n- Important: This *must* be called on the event loop.\n- Parameter name: The name of the handler whose context is being fetched.\n- Returns: The `ChannelHandlerContext` associated with the handler."},{"p":["ChannelPipeline","SynchronousOperations","context(name:)"],"f":[["func",12],[" ",17],["context",7],["(",17],["name",1],[": ",17],["String",18,1165],[") ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18,128]],"s":[["func",12],[" ",17],["context",7],["(",17],["name",1],[": ",17],["String",18],[") ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18]],"d":"Returns the `ChannelHandlerContext` for the handler with the given name, if one exists.\n\n- Important: This *must* be called on the event loop.\n- Parameter name: The name of the handler whose context is being fetched.\n- Returns: The `ChannelHandlerContext` associated with the handler."},{"p":["ChannelPipeline","SynchronousOperations","context(handler:)"],"f":[["func",12],[" ",17],["context",7],["(",17],["handler",1],[": ",17],["ChannelHandler",18,8],[") ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18,128]],"s":[["func",12],[" ",17],["context",7],["(",17],["handler",1],[": ",17],["ChannelHandler",18],[") ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18]],"d":"Returns the `ChannelHandlerContext` for the given handler instance if it is in\nthe `ChannelPipeline`, if it exists.\n\n- Important: This *must* be called on the event loop.\n- Parameter handler: The handler belonging to the context to fetch.\n- Returns: The `ChannelHandlerContext` associated with the handler."},{"p":["ChannelPipeline","SynchronousOperations","handler(type:)"],"f":[["func",12],[" ",17],["handler",7],["<",17],["Handler",0],[">(",17],["type",1],[" ",17],["_",2],[": ",17],["Handler",18],[".Type) ",17],["throws",12],[" -> ",17],["Handler",18],[" ",17],["where",12],[" ",17],["Handler",18],[" : ",17],["ChannelHandler",18,8]],"s":[["func",12],[" ",17],["handler",7],["<",17],["Handler",0],[">(",17],["type",1],[": ",17],["Handler",18],[".Type) ",17],["throws",12],[" -> ",17],["Handler",18]],"c":[["Handler",1,"ChannelHandler",8]],"g":[["Handler",0,0]],"d":"Returns the `ChannelHandler` of the given type from the `ChannelPipeline`, if it exists.\n\n- Important: This *must* be called on the event loop.\n- Returns: A `ChannelHandler` of the given type if one exists in the `ChannelPipeline`."},{"p":["ChannelPipeline","SynchronousOperations","register(promise:)"],"f":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Fires `register` from the tail to the head.\n\nThis method should typically only be called by `Channel` implementations directly."},{"p":["ChannelPipeline","triggerUserOutboundEvent(_:promise:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["ChannelPipeline","fireUserInboundEventTriggered(_:)"],"f":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[")",17]],"s":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["Any",12],[")",17]]},{"p":["ChannelPipeline","bind(to:promise:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["ChannelPipeline","read()"],"f":[["func",12],[" ",17],["read",7],["()",17]],"s":[["func",12],[" ",17],["read",7],["()",17]]},{"p":["ChannelPipeline","close(mode:promise:)"],"f":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18,57],[" = .all, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["ChannelPipeline","flush()"],"f":[["func",12],[" ",17],["flush",7],["()",17]],"s":[["func",12],[" ",17],["flush",7],["()",17]]},{"p":["ChannelPipeline","write(_:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["ChannelPipeline","connect(to:promise:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["ChannelPipeline","context(handlerType:)"],"f":[["func",12],[" ",17],["context",7],["<",17],["Handler",0],[">(",17],["handlerType",1],[": ",17],["Handler",18],[".Type) ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18,128],[" ",17],["where",12],[" ",17],["Handler",18],[" : ",17],["ChannelHandler",18,8]],"s":[["func",12],[" ",17],["context",7],["<",17],["Handler",0],[">(",17],["handlerType",1],[": ",17],["Handler",18],[".Type) ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"c":[["Handler",1,"ChannelHandler",8]],"g":[["Handler",0,0]]},{"p":["ChannelPipeline","context(handlerType:)"],"f":[["func",12],[" ",17],["context",7],["<",17],["Handler",0],[">(",17],["handlerType",1],[": ",17],["Handler",18],[".Type) -> ",17],["EventLoopFuture",18,121],["<",17],["ChannelHandlerContext",18,128],["> ",17],["where",12],[" ",17],["Handler",18],[" : ",17],["ChannelHandler",18,8]],"s":[["func",12],[" ",17],["context",7],["<",17],["Handler",0],[">(",17],["handlerType",1],[": ",17],["Handler",18],[".Type) -> ",17],["EventLoopFuture",18],["<",17],["ChannelHandlerContext",18],[">",17]],"c":[["Handler",1,"ChannelHandler",8]],"g":[["Handler",0,0]],"d":"Returns the `ChannelHandlerContext` that belongs to a `ChannelHandler` of the given type.\n\nIf multiple channel handlers of the same type are present in the pipeline, returns the context\nbelonging to the first such handler.\n\n- parameters:\n    - handlerType: The type of the handler to search for.\n- returns: the `EventLoopFuture` which will be notified once the the operation completes."},{"p":["ChannelPipeline","context(name:)"],"f":[["func",12],[" ",17],["context",7],["(",17],["name",1],[": ",17],["String",18,1165],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18,128]],"s":[["func",12],[" ",17],["context",7],["(",17],["name",1],[": ",17],["String",18],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","context(name:)"],"f":[["func",12],[" ",17],["context",7],["(",17],["name",1],[": ",17],["String",18,1165],[") -> ",17],["EventLoopFuture",18,121],["<",17],["ChannelHandlerContext",18,128],[">",17]],"s":[["func",12],[" ",17],["context",7],["(",17],["name",1],[": ",17],["String",18],[") -> ",17],["EventLoopFuture",18],["<",17],["ChannelHandlerContext",18],[">",17]],"d":"Returns the `ChannelHandlerContext` that belongs to a `ChannelHandler`.\n\n- parameters:\n    - name: the name that was used to add the `ChannelHandler` to the `ChannelPipeline` before.\n- returns: the `EventLoopFuture` which will be notified once the the operation completes."},{"p":["ChannelPipeline","context(handler:)"],"f":[["func",12],[" ",17],["context",7],["(",17],["handler",1],[": ",17],["ChannelHandler",18,8],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18,128]],"s":[["func",12],[" ",17],["context",7],["(",17],["handler",1],[": ",17],["ChannelHandler",18],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["ChannelHandlerContext",18]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}}},{"p":["ChannelPipeline","context(handler:)"],"f":[["func",12],[" ",17],["context",7],["(",17],["handler",1],[": ",17],["ChannelHandler",18,8],[") -> ",17],["EventLoopFuture",18,121],["<",17],["ChannelHandlerContext",18,128],[">",17]],"s":[["func",12],[" ",17],["context",7],["(",17],["handler",1],[": ",17],["ChannelHandler",18],[") -> ",17],["EventLoopFuture",18],["<",17],["ChannelHandlerContext",18],[">",17]],"d":"Returns the `ChannelHandlerContext` that belongs to a `ChannelHandler`.\n\n- parameters:\n    - handler: the `ChannelHandler` for which the `ChannelHandlerContext` should be returned\n- returns: the `EventLoopFuture` which will be notified once the the operation completes."},{"p":["ChannelPipeline","handler(type:)"],"f":[["func",12],[" ",17],["handler",7],["<",17],["Handler",0],[">(",17],["type",1],[" ",17],["_",2],[": ",17],["Handler",18],[".Type) -> ",17],["EventLoopFuture",18,121],["<",17],["Handler",18],["> ",17],["where",12],[" ",17],["Handler",18],[" : ",17],["ChannelHandler",18,8]],"s":[["func",12],[" ",17],["handler",7],["<",17],["Handler",0],[">(",17],["type",1],[": ",17],["Handler",18],[".Type) -> ",17],["EventLoopFuture",18],["<",17],["Handler",18],[">",17]],"c":[["Handler",1,"ChannelHandler",8]],"g":[["Handler",0,0]],"d":"Returns the first `ChannelHandler` of the given type.\n\n- parameters:\n    - type: the type of `ChannelHandler` to return."},{"p":["ChannelPipeline","register(promise:)"],"f":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["EventLoopFuture","flatMapWithEventLoop(_:)"],"f":[["func",12],[" ",17],["flatMapWithEventLoop",7],["<",17],["NewValue",0],[">(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[", ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["flatMapWithEventLoop",7],["<",17],["NewValue",0],[">((",17],["Value",18],[", ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"g":[["Value",0,0],["NewValue",0,1]],"d":"When the current `EventLoopFuture<Value>` is fulfilled, run the provided callback,\nwhich will provide a new `EventLoopFuture` alongside the `EventLoop` associated with this future.\n\nThis allows you to dynamically dispatch new asynchronous tasks as phases in a\nlonger series of processing steps. Note that you can use the results of the\ncurrent `EventLoopFuture<Value>` when determining how to dispatch the next operation.\n\nThis works well when you have APIs that already know how to return `EventLoopFuture`s.\nYou can do something with the result of one and just return the next future:\n\n```\nlet d1 = networkRequest(args).future()\nlet d2 = d1.flatMapWithEventLoop { t, eventLoop -> EventLoopFuture<NewValue> in\n    eventLoop.makeSucceededFuture(t + 1)\n}\nd2.whenSuccess { u in\n    NSLog(\"Result of second request: \\(u)\")\n}\n```\n\nNote: In a sense, the `EventLoopFuture<NewValue>` is returned before it's created.\n\n- parameters:\n    - callback: Function that will receive the value of this `EventLoopFuture` and return\n        a new `EventLoopFuture`.\n- returns: A future that will receive the eventual value."},{"p":["EventLoopFuture","flatMapErrorWithEventLoop(_:)"],"f":[["func",12],[" ",17],["flatMapErrorWithEventLoop",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[", ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["flatMapErrorWithEventLoop",7],["((",17],["Error",18],[", ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0]],"d":"When the current `EventLoopFuture<Value>` is in an error state, run the provided callback, which\nmay recover from the error by returning an `EventLoopFuture<NewValue>`. The callback is intended to potentially\nrecover from the error by returning a new `EventLoopFuture` that will eventually contain the recovered\nresult.\n\nIf the callback cannot recover it should return a failed `EventLoopFuture`.\n\n- parameters:\n    - callback: Function that will receive the error value of this `EventLoopFuture` and return\n        a new value lifted into a new `EventLoopFuture`.\n- returns: A future that will receive the recovered value."},{"p":["EventLoopFuture","foldWithEventLoop(_:with:)"],"f":[["func",12],[" ",17],["foldWithEventLoop",7],["<",17],["OtherValue",0],[">(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["OtherValue",18],[">], ",17],["with",1],[" ",17],["combiningFunction",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[", ",17],["OtherValue",18],[", ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["foldWithEventLoop",7],["<",17],["OtherValue",0],[">([",17],["EventLoopFuture",18],["<",17],["OtherValue",18],[">], ",17],["with",1],[": (",17],["Value",18],[", ",17],["OtherValue",18],[", ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0],["OtherValue",0,1]],"d":"Returns a new `EventLoopFuture` that fires only when this `EventLoopFuture` and\nall the provided `futures` complete. It then provides the result of folding the value of this\n`EventLoopFuture` with the values of all the provided `futures`.\n\nThis function is suited when you have APIs that already know how to return `EventLoopFuture`s.\n\nThe returned `EventLoopFuture` will fail as soon as the a failure is encountered in any of the\n`futures` (or in this one). However, the failure will not occur until all preceding\n`EventLoopFutures` have completed. At the point the failure is encountered, all subsequent\n`EventLoopFuture` objects will no longer be waited for. This function therefore fails fast: once\na failure is encountered, it will immediately fail the overall EventLoopFuture.\n\n- parameters:\n    - futures: An array of `EventLoopFuture<NewValue>` to wait for.\n    - with: A function that will be used to fold the values of two `EventLoopFuture`s and return a new value wrapped in an `EventLoopFuture`.\n- returns: A new `EventLoopFuture` with the folded value whose callbacks run on `self.eventLoop`."},{"p":["EventLoopFuture","whenFailure(_:)"],"f":[["func",12],[" ",17],["whenFailure",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["whenFailure",7],["((",17],["Error",18],[") -> ",17],["Void",18],[")",17]],"g":[["Value",0,0]],"d":"Adds an observer callback to this `EventLoopFuture` that is called when the\n`EventLoopFuture` has a failure result.\n\nAn observer callback cannot return a value, meaning that this function cannot be chained\nfrom. If you are attempting to create a computation pipeline, consider `recover` or `flatMapError`.\nIf you find yourself passing the results from this `EventLoopFuture` to a new `EventLoopPromise`\nin the body of this function, consider using `cascade` instead.\n\n- parameters:\n    - callback: The callback that is called with the failed result of the `EventLoopFuture`."},{"p":["EventLoopFuture","whenSuccess(_:)"],"f":[["func",12],[" ",17],["whenSuccess",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["whenSuccess",7],["((",17],["Value",18],[") -> ",17],["Void",18],[")",17]],"g":[["Value",0,0]],"d":"Adds an observer callback to this `EventLoopFuture` that is called when the\n`EventLoopFuture` has a success result.\n\nAn observer callback cannot return a value, meaning that this function cannot be chained\nfrom. If you are attempting to create a computation pipeline, consider `map` or `flatMap`.\nIf you find yourself passing the results from this `EventLoopFuture` to a new `EventLoopPromise`\nin the body of this function, consider using `cascade` instead.\n\n- parameters:\n    - callback: The callback that is called with the successful result of the `EventLoopFuture`."},{"p":["EventLoopFuture","flatMapError(file:line:_:)"],"f":[["func",12],[" ",17],["flatMapError",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["flatMapError",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", (",17],["Error",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0]]},{"p":["EventLoopFuture","flatMapError(_:)"],"f":[["func",12],[" ",17],["flatMapError",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["flatMapError",7],["((",17],["Error",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0]],"d":"When the current `EventLoopFuture<Value>` is in an error state, run the provided callback, which\nmay recover from the error by returning an `EventLoopFuture<NewValue>`. The callback is intended to potentially\nrecover from the error by returning a new `EventLoopFuture` that will eventually contain the recovered\nresult.\n\nIf the callback cannot recover it should return a failed `EventLoopFuture`.\n\n- parameters:\n    - callback: Function that will receive the error value of this `EventLoopFuture` and return\n        a new value lifted into a new `EventLoopFuture`.\n- returns: A future that will receive the recovered value."},{"p":["EventLoopFuture","whenComplete(_:)"],"f":[["func",12],[" ",17],["whenComplete",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Result",18,1386],["<",17],["Value",18],[", ",17],["Error",18,1380],[">) -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["whenComplete",7],["((",17],["Result",18],["<",17],["Value",18],[", ",17],["Error",18],[">) -> ",17],["Void",18],[")",17]],"g":[["Value",0,0]],"d":"Adds an observer callback to this `EventLoopFuture` that is called when the\n`EventLoopFuture` has any result.\n\n- parameters:\n    - callback: The callback that is called when the `EventLoopFuture` is fulfilled."},{"p":["EventLoopFuture","flatMapResult(file:line:_:)"],"f":[["func",12],[" ",17],["flatMapResult",7],["<",17],["NewValue",0],[", ",17],["SomeError",0],[">(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["body",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> ",17],["Result",18,1386],["<",17],["NewValue",18],[", ",17],["SomeError",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],["> ",17],["where",12],[" ",17],["SomeError",18],[" : ",17],["Error",18,1380]],"s":[["func",12],[" ",17],["flatMapResult",7],["<",17],["NewValue",0],[", ",17],["SomeError",0],[">(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", (",17],["Value",18],[") -> ",17],["Result",18],["<",17],["NewValue",18],[", ",17],["SomeError",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"c":[["SomeError",1,"Error",1380]],"g":[["Value",0,0],["NewValue",0,1],["SomeError",1,1]]},{"p":["EventLoopFuture","flatMapResult(_:)"],"f":[["func",12],[" ",17],["flatMapResult",7],["<",17],["NewValue",0],[", ",17],["SomeError",0],[">(",17],["_",1],[" ",17],["body",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> ",17],["Result",18,1386],["<",17],["NewValue",18],[", ",17],["SomeError",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],["> ",17],["where",12],[" ",17],["SomeError",18],[" : ",17],["Error",18,1380]],"s":[["func",12],[" ",17],["flatMapResult",7],["<",17],["NewValue",0],[", ",17],["SomeError",0],[">((",17],["Value",18],[") -> ",17],["Result",18],["<",17],["NewValue",18],[", ",17],["SomeError",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"c":[["SomeError",1,"Error",1380]],"g":[["Value",0,0],["NewValue",0,1],["SomeError",1,1]],"d":"When the current `EventLoopFuture<Value>` is fulfilled, run the provided callback, which\nperforms a synchronous computation and returns either a new value (of type `NewValue`) or\nan error depending on the `Result` returned by the closure.\n\nOperations performed in `flatMapResult` should not block, or they will block the entire\nevent loop. `flatMapResult` is intended for use when you have a data-driven function that\nperforms a simple data transformation that can potentially error.\n\n\n- parameters:\n    - body: Function that will receive the value of this `EventLoopFuture` and return\n        a new value or error lifted into a new `EventLoopFuture`.\n- returns: A future that will receive the eventual value."},{"p":["EventLoopFuture","cascadeFailure(to:)"],"f":[["func",12],[" ",17],["cascadeFailure",7],["<",17],["NewValue",0],[">(",17],["to",1],[" ",17],["promise",2],[": ",17],["EventLoopPromise",18,96],["<",17],["NewValue",18],[">?)",17]],"s":[["func",12],[" ",17],["cascadeFailure",7],["<",17],["NewValue",0],[">(",17],["to",1],[": ",17],["EventLoopPromise",18],["<",17],["NewValue",18],[">?)",17]],"g":[["Value",0,0],["NewValue",0,1]],"d":"Fails the given `EventLoopPromise` with the error from this `EventLoopFuture` if encountered.\n\nThis is an alternative variant of `cascade` that allows you to potentially return early failures in\nerror cases, while passing the user `EventLoopPromise` onwards.\n\n- Parameter to: The `EventLoopPromise` that should fail with the error of this `EventLoopFuture`."},{"p":["EventLoopFuture","cascadeSuccess(to:)"],"f":[["func",12],[" ",17],["cascadeSuccess",7],["(",17],["to",1],[" ",17],["promise",2],[": ",17],["EventLoopPromise",18,96],["<",17],["Value",18],[">?)",17]],"s":[["func",12],[" ",17],["cascadeSuccess",7],["(",17],["to",1],[": ",17],["EventLoopPromise",18],["<",17],["Value",18],[">?)",17]],"g":[["Value",0,0]],"d":"Fulfills the given `EventLoopPromise` only when this `EventLoopFuture` succeeds.\n\nIf you are doing work that fulfills a type that doesn't match the expected `EventLoopPromise` value, add an\nintermediate `map`.\n\nFor example:\n```\nlet boolPromise = eventLoop.makePromise(of: Bool.self)\ndoWorkReturningInt().map({ $0 >= 0 }).cascade(to: boolPromise)\n```\n\n- Parameter to: The `EventLoopPromise` to fulfill when a successful result is available."},{"p":["EventLoopFuture","flatMapBlocking(onto:_:)"],"f":[["func",12],[" ",17],["flatMapBlocking",7],["<",17],["NewValue",0],[">(",17],["onto",1],[" ",17],["queue",2],[": ",17],["DispatchQueue",18,1111],[", ",17],["_",1],[" ",17],["callbackMayBlock",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["flatMapBlocking",7],["<",17],["NewValue",0],[">(",17],["onto",1],[": ",17],["DispatchQueue",18],[", (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"g":[["Value",0,0],["NewValue",0,1]],"d":"Chain an `EventLoopFuture<NewValue>` providing the result of a IO / task that may block. For example:\n\n    promise.futureResult.flatMapBlocking(onto: DispatchQueue.global()) { value in Int\n        blockingTask(value)\n    }\n\n- parameters:\n    - onto: the `DispatchQueue` on which the blocking IO / task specified by `callbackMayBlock` is scheduled.\n    - callbackMayBlock: Function that will receive the value of this `EventLoopFuture` and return\n        a new `EventLoopFuture`."},{"p":["EventLoopFuture","flatMapThrowing(file:line:_:)"],"f":[["func",12],[" ",17],["flatMapThrowing",7],["<",17],["NewValue",0],[">(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["flatMapThrowing",7],["<",17],["NewValue",0],[">(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0],["NewValue",0,1]]},{"p":["EventLoopFuture","flatMapThrowing(_:)"],"f":[["func",12],[" ",17],["flatMapThrowing",7],["<",17],["NewValue",0],[">(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["flatMapThrowing",7],["<",17],["NewValue",0],[">((",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"g":[["Value",0,0],["NewValue",0,1]],"d":"When the current `EventLoopFuture<Value>` is fulfilled, run the provided callback, which\nperforms a synchronous computation and returns a new value of type `NewValue`. The provided\ncallback may optionally `throw`.\n\nOperations performed in `flatMapThrowing` should not block, or they will block the entire\nevent loop. `flatMapThrowing` is intended for use when you have a data-driven function that\nperforms a simple data transformation that can potentially error.\n\nIf your callback function throws, the returned `EventLoopFuture` will error.\n\n- parameters:\n    - callback: Function that will receive the value of this `EventLoopFuture` and return\n        a new value lifted into a new `EventLoopFuture`.\n- returns: A future that will receive the eventual value."},{"p":["EventLoopFuture","whenFailureBlocking(onto:_:)"],"f":[["func",12],[" ",17],["whenFailureBlocking",7],["(",17],["onto",1],[" ",17],["queue",2],[": ",17],["DispatchQueue",18,1111],[", ",17],["_",1],[" ",17],["callbackMayBlock",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["whenFailureBlocking",7],["(",17],["onto",1],[": ",17],["DispatchQueue",18],[", (",17],["Error",18],[") -> ",17],["Void",18],[")",17]],"g":[["Value",0,0]],"d":"Adds an observer callback to this `EventLoopFuture` that is called when the\n`EventLoopFuture` has a failure result. The observer callback is permitted to block.\n\nAn observer callback cannot return a value, meaning that this function cannot be chained\nfrom. If you are attempting to create a computation pipeline, consider `recover` or `flatMapError`.\nIf you find yourself passing the results from this `EventLoopFuture` to a new `EventLoopPromise`\nin the body of this function, consider using `cascade` instead.\n\n- parameters:\n    - onto: the `DispatchQueue` on which the blocking IO / task specified by `callbackMayBlock` is scheduled.\n    - callbackMayBlock: The callback that is called with the failed result of the `EventLoopFuture`."},{"p":["EventLoopFuture","whenSuccessBlocking(onto:_:)"],"f":[["func",12],[" ",17],["whenSuccessBlocking",7],["(",17],["onto",1],[" ",17],["queue",2],[": ",17],["DispatchQueue",18,1111],[", ",17],["_",1],[" ",17],["callbackMayBlock",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["whenSuccessBlocking",7],["(",17],["onto",1],[": ",17],["DispatchQueue",18],[", (",17],["Value",18],[") -> ",17],["Void",18],[")",17]],"g":[["Value",0,0]],"d":"Adds an observer callback to this `EventLoopFuture` that is called when the\n`EventLoopFuture` has a success result. The observer callback is permitted to block.\n\nAn observer callback cannot return a value, meaning that this function cannot be chained\nfrom. If you are attempting to create a computation pipeline, consider `map` or `flatMap`.\nIf you find yourself passing the results from this `EventLoopFuture` to a new `EventLoopPromise`\nin the body of this function, consider using `cascade` instead.\n\n- parameters:\n    - onto: the `DispatchQueue` on which the blocking IO / task specified by `callbackMayBlock` is scheduled.\n    - callbackMayBlock: The callback that is called with the successful result of the `EventLoopFuture`."},{"p":["EventLoopFuture","flatMapErrorThrowing(file:line:_:)"],"f":[["func",12],[" ",17],["flatMapErrorThrowing",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") ",17],["throws",12],[" -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["flatMapErrorThrowing",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", (",17],["Error",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0]]},{"p":["EventLoopFuture","flatMapErrorThrowing(_:)"],"f":[["func",12],[" ",17],["flatMapErrorThrowing",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") ",17],["throws",12],[" -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["flatMapErrorThrowing",7],["((",17],["Error",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0]],"d":"When the current `EventLoopFuture<Value>` is in an error state, run the provided callback, which\nmay recover from the error and returns a new value of type `Value`. The provided callback may optionally `throw`,\nin which case the `EventLoopFuture` will be in a failed state with the new thrown error.\n\nOperations performed in `flatMapErrorThrowing` should not block, or they will block the entire\nevent loop. `flatMapErrorThrowing` is intended for use when you have the ability to synchronously\nrecover from errors.\n\nIf your callback function throws, the returned `EventLoopFuture` will error.\n\n- parameters:\n    - callback: Function that will receive the error value of this `EventLoopFuture` and return\n        a new value lifted into a new `EventLoopFuture`.\n- returns: A future that will receive the eventual value or a rethrown error."},{"p":["EventLoopFuture","whenCompleteBlocking(onto:_:)"],"f":[["func",12],[" ",17],["whenCompleteBlocking",7],["(",17],["onto",1],[" ",17],["queue",2],[": ",17],["DispatchQueue",18,1111],[", ",17],["_",1],[" ",17],["callbackMayBlock",2],[": ",17],["@escaping",12],[" (",17],["Result",18,1386],["<",17],["Value",18],[", ",17],["Error",18,1380],[">) -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["whenCompleteBlocking",7],["(",17],["onto",1],[": ",17],["DispatchQueue",18],[", (",17],["Result",18],["<",17],["Value",18],[", ",17],["Error",18],[">) -> ",17],["Void",18],[")",17]],"g":[["Value",0,0]],"d":"Adds an observer callback to this `EventLoopFuture` that is called when the\n`EventLoopFuture` has any result. The observer callback is permitted to block.\n\n- parameters:\n    - onto: the `DispatchQueue` on which the blocking IO / task specified by `callbackMayBlock` is scheduled.\n    - callbackMayBlock: The callback that is called when the `EventLoopFuture` is fulfilled."},{"p":["EventLoopFuture","and(value:file:line:)"],"f":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["value",1],[": ",17],["OtherValue",18],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"s":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["value",1],[": ",17],["OtherValue",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0],["OtherValue",0,1]]},{"p":["EventLoopFuture","and(value:)"],"f":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["value",1],[": ",17],["OtherValue",18],[") -> ",17],["EventLoopFuture",18,121],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"s":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["value",1],[": ",17],["OtherValue",18],[") -> ",17],["EventLoopFuture",18],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"g":[["Value",0,0],["OtherValue",0,1]],"d":"Return a new EventLoopFuture that contains this \"and\" another value.\nThis is just syntactic sugar for `future.and(loop.makeSucceedFuture(value))`."},{"p":["EventLoopFuture","and(_:file:line:)"],"f":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["EventLoopFuture",18,121],["<",17],["OtherValue",18],[">, ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"s":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["EventLoopFuture",18],["<",17],["OtherValue",18],[">, ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0],["OtherValue",0,1]]},{"p":["EventLoopFuture","and(_:)"],"f":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["EventLoopFuture",18,121],["<",17],["OtherValue",18],[">) -> ",17],["EventLoopFuture",18,121],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"s":[["func",12],[" ",17],["and",7],["<",17],["OtherValue",0],[">(",17],["EventLoopFuture",18],["<",17],["OtherValue",18],[">) -> ",17],["EventLoopFuture",18],["<(",17],["Value",18],[", ",17],["OtherValue",18],[")>",17]],"g":[["Value",0,0],["OtherValue",0,1]],"d":"Return a new `EventLoopFuture` that succeeds when this \"and\" another\nprovided `EventLoopFuture` both succeed. It then provides the pair\nof results. If either one fails, the combined `EventLoopFuture` will fail with\nthe first error encountered."},{"p":["EventLoopFuture","get()"],"f":[["func",12],[" ",17],["get",7],["() ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["Value",18]],"s":[["func",12],[" ",17],["get",7],["() ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["Value",18]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"g":[["Value",0,0]],"d":"Get the value/error from an `EventLoopFuture` in an `async` context.\n\nThis function can be used to bridge an `EventLoopFuture` into the `async` world. Ie. if you're in an `async`\nfunction and want to get the result of this future."},{"p":["EventLoopFuture","hop(to:)"],"f":[["func",12],[" ",17],["hop",7],["(",17],["to",1],[" ",17],["target",2],[": ",17],["EventLoop",18,28],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["hop",7],["(",17],["to",1],[": ",17],["EventLoop",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0]],"d":"Returns an `EventLoopFuture` that fires when this future completes, but executes its callbacks on the\ntarget event loop instead of the original one.\n\nIt is common to want to \"hop\" event loops when you arrange some work: for example, you're closing one channel\nfrom another, and want to hop back when the close completes. This method lets you spell that requirement\nsuccinctly. It also contains an optimisation for the case when the loop you're hopping *from* is the same as\nthe one you're hopping *to*, allowing you to avoid doing allocations in that case.\n\n- parameters:\n    - to: The `EventLoop` that the returned `EventLoopFuture` will run on.\n- returns: An `EventLoopFuture` whose callbacks run on `target` instead of the original loop."},{"p":["EventLoopFuture","map(file:line:_:)"],"f":[["func",12],[" ",17],["map",7],["<",17],["NewValue",0],[">(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> (",17],["NewValue",18],[")) -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["map",7],["<",17],["NewValue",0],[">(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", (",17],["Value",18],[") -> (",17],["NewValue",18],[")) -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0],["NewValue",0,1]]},{"p":["EventLoopFuture","map(_:)"],"f":[["func",12],[" ",17],["map",7],["<",17],["NewValue",0],[">(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> (",17],["NewValue",18],[")) -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["map",7],["<",17],["NewValue",0],[">((",17],["Value",18],[") -> (",17],["NewValue",18],[")) -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"g":[["Value",0,0],["NewValue",0,1]],"d":"When the current `EventLoopFuture<Value>` is fulfilled, run the provided callback, which\nperforms a synchronous computation and returns a new value of type `NewValue`.\n\nOperations performed in `map` should not block, or they will block the entire event\nloop. `map` is intended for use when you have a data-driven function that performs\na simple data transformation that cannot error.\n\nIf you have a data-driven function that can throw, you should use `flatMapThrowing`\ninstead.\n\n```\nlet future1 = eventually()\nlet future2 = future1.map { T -> U in\n    ... stuff ...\n    return u\n}\nlet future3 = future2.map { U -> V in\n    ... stuff ...\n    return v\n}\n```\n\n- parameters:\n    - callback: Function that will receive the value of this `EventLoopFuture` and return\n        a new value lifted into a new `EventLoopFuture`.\n- returns: A future that will receive the eventual value."},{"p":["EventLoopFuture","fold(_:with:)"],"f":[["func",12],[" ",17],["fold",7],["<",17],["OtherValue",0],[">(",17],["_",1],[" ",17],["futures",2],[": [",17],["EventLoopFuture",18,121],["<",17],["OtherValue",18],[">], ",17],["with",1],[" ",17],["combiningFunction",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[", ",17],["OtherValue",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["fold",7],["<",17],["OtherValue",0],[">([",17],["EventLoopFuture",18],["<",17],["OtherValue",18],[">], ",17],["with",1],[": (",17],["Value",18],[", ",17],["OtherValue",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0],["OtherValue",0,1]],"d":"Returns a new `EventLoopFuture` that fires only when this `EventLoopFuture` and\nall the provided `futures` complete. It then provides the result of folding the value of this\n`EventLoopFuture` with the values of all the provided `futures`.\n\nThis function is suited when you have APIs that already know how to return `EventLoopFuture`s.\n\nThe returned `EventLoopFuture` will fail as soon as the a failure is encountered in any of the\n`futures` (or in this one). However, the failure will not occur until all preceding\n`EventLoopFutures` have completed. At the point the failure is encountered, all subsequent\n`EventLoopFuture` objects will no longer be waited for. This function therefore fails fast: once\na failure is encountered, it will immediately fail the overall EventLoopFuture.\n\n- parameters:\n    - futures: An array of `EventLoopFuture<NewValue>` to wait for.\n    - with: A function that will be used to fold the values of two `EventLoopFuture`s and return a new value wrapped in an `EventLoopFuture`.\n- returns: A new `EventLoopFuture` with the folded value whose callbacks run on `self.eventLoop`."},{"p":["EventLoopFuture","wait(file:line:)"],"f":[["func",12],[" ",17],["wait",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") ",17],["throws",12],[" -> ",17],["Value",18]],"s":[["func",12],[" ",17],["wait",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") ",17],["throws",12],[" -> ",17],["Value",18]],"g":[["Value",0,0]],"d":"Wait for the resolution of this `EventLoopFuture` by blocking the current thread until it\nresolves.\n\nIf the `EventLoopFuture` resolves with a value, that value is returned from `wait()`. If\nthe `EventLoopFuture` resolves with an error, that error will be thrown instead.\n`wait()` will block whatever thread it is called on, so it must not be called on event loop\nthreads: it is primarily useful for testing, or for building interfaces between blocking\nand non-blocking code.\n\n- returns: The value of the `EventLoopFuture` when it completes.\n- throws: The error value of the `EventLoopFuture` if it errors."},{"p":["EventLoopFuture","always(_:)"],"f":[["func",12],[" ",17],["always",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Result",18,1386],["<",17],["Value",18],[", ",17],["Error",18,1380],[">) -> ",17],["Void",18,1379],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["always",7],["((",17],["Result",18],["<",17],["Value",18],[", ",17],["Error",18],[">) -> ",17],["Void",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0]],"d":"Adds an observer callback to this `EventLoopFuture` that is called when the\n`EventLoopFuture` has any result.\n\n- parameters:\n    - callback: the callback that is called when the `EventLoopFuture` is fulfilled.   \n- returns: the current `EventLoopFuture`"},{"p":["EventLoopFuture","unwrap(orElse:)"],"f":[["func",12],[" ",17],["unwrap",7],["<",17],["NewValue",0],[">(",17],["orElse",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" () -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],["> ",17],["where",12],[" ",17],["Value",18],[" == ",17],["NewValue",18],["?",17]],"s":[["func",12],[" ",17],["unwrap",7],["<",17],["NewValue",0],[">(",17],["orElse",1],[": () -> ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"c":[["Value",2,"NewValue?",1339]],"g":[["Value",0,0],["NewValue",0,1]],"d":"Unwrap an `EventLoopFuture` where its type parameter is an `Optional`.\n\nUnwraps a future returning a new `EventLoopFuture` with either: the value returned by the closure passed in\nthe `orElse` parameter when the future resolved with value Optional.none, or the same value otherwise. For example:\n```\nvar x = 2\npromise.futureResult.unwrap(orElse: { x * 2 }).wait()\n```\n\n- parameters:\n    - orElse: a closure that returns the value of the returned `EventLoopFuture` when then resolved future's value\n        is `Optional.some()`.\n- returns: an new `EventLoopFuture` with new type parameter `NewValue` and with the value returned by the closure\n    passed in the `orElse` parameter."},{"p":["EventLoopFuture","unwrap(orError:)"],"f":[["func",12],[" ",17],["unwrap",7],["<",17],["NewValue",0],[">(",17],["orError",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],["> ",17],["where",12],[" ",17],["Value",18],[" == ",17],["NewValue",18],["?",17]],"s":[["func",12],[" ",17],["unwrap",7],["<",17],["NewValue",0],[">(",17],["orError",1],[": ",17],["Error",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"c":[["Value",2,"NewValue?",1339]],"g":[["Value",0,0],["NewValue",0,1]],"d":"Unwrap an `EventLoopFuture` where its type parameter is an `Optional`.\n\nUnwrap a future returning a new `EventLoopFuture`. When the resolved future's value is `Optional.some(...)`\nthe new future is created with the identical value. Otherwise the `Error` passed in the `orError` parameter\nis thrown. For example:\n```\ndo {\n    try promise.futureResult.unwrap(orError: ErrorToThrow).wait()\n} catch ErrorToThrow {\n    ...\n}\n```\n\n- parameters:\n    - orError: the `Error` that is thrown when then resolved future's value is `Optional.none`.\n- returns: an new `EventLoopFuture` with new type parameter `NewValue` and the same value as the resolved\n    future.\n- throws: the `Error` passed in the `orError` parameter when the resolved future's value is `Optional.none`."},{"p":["EventLoopFuture","unwrap(orReplace:)"],"f":[["func",12],[" ",17],["unwrap",7],["<",17],["NewValue",0],[">(",17],["orReplace",1],[" ",17],["replacement",2],[": ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],["> ",17],["where",12],[" ",17],["Value",18],[" == ",17],["NewValue",18],["?",17]],"s":[["func",12],[" ",17],["unwrap",7],["<",17],["NewValue",0],[">(",17],["orReplace",1],[": ",17],["NewValue",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"c":[["Value",2,"NewValue?",1339]],"g":[["Value",0,0],["NewValue",0,1]],"d":"Unwrap an `EventLoopFuture` where its type parameter is an `Optional`.\n\nUnwraps a future returning a new `EventLoopFuture` with either: the value passed in the `orReplace`\nparameter when the future resolved with value Optional.none, or the same value otherwise. For example:\n```\npromise.futureResult.unwrap(orReplace: 42).wait()\n```\n\n- parameters:\n    - orReplace: the value of the returned `EventLoopFuture` when then resolved future's value is `Optional.some()`.\n- returns: an new `EventLoopFuture` with new type parameter `NewValue` and the value passed in the `orReplace` parameter."},{"p":["EventLoopFuture","cascade(to:)"],"f":[["func",12],[" ",17],["cascade",7],["(",17],["to",1],[" ",17],["promise",2],[": ",17],["EventLoopPromise",18,96],["<",17],["Value",18],[">?)",17]],"s":[["func",12],[" ",17],["cascade",7],["(",17],["to",1],[": ",17],["EventLoopPromise",18],["<",17],["Value",18],[">?)",17]],"g":[["Value",0,0]],"d":"Fulfills the given `EventLoopPromise` with the results from this `EventLoopFuture`.\n\nThis is useful when allowing users to provide promises for you to fulfill, but\nwhen you are calling functions that return their own promises. They allow you to\ntidy up your computational pipelines.\n\nFor example:\n```\ndoWork().flatMap {\n    doMoreWork($0)\n}.flatMap {\n    doYetMoreWork($0)\n}.flatMapError {\n    maybeRecoverFromError($0)\n}.map {\n    transformData($0)\n}.cascade(to: userPromise)\n```\n\n- Parameter to: The `EventLoopPromise` to fulfill with the results of this future.\n- SeeAlso: `EventLoopPromise.completeWith(_:)`"},{"p":["EventLoopFuture","flatMap(file:line:_:)"],"f":[["func",12],[" ",17],["flatMap",7],["<",17],["NewValue",0],[">(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["flatMap",7],["<",17],["NewValue",0],[">(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", (",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0],["NewValue",0,1]]},{"p":["EventLoopFuture","flatMap(_:)"],"f":[["func",12],[" ",17],["flatMap",7],["<",17],["NewValue",0],[">(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["NewValue",18],[">",17]],"s":[["func",12],[" ",17],["flatMap",7],["<",17],["NewValue",0],[">((",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["NewValue",18],[">",17]],"g":[["Value",0,0],["NewValue",0,1]],"d":"When the current `EventLoopFuture<Value>` is fulfilled, run the provided callback,\nwhich will provide a new `EventLoopFuture`.\n\nThis allows you to dynamically dispatch new asynchronous tasks as phases in a\nlonger series of processing steps. Note that you can use the results of the\ncurrent `EventLoopFuture<Value>` when determining how to dispatch the next operation.\n\nThis works well when you have APIs that already know how to return `EventLoopFuture`s.\nYou can do something with the result of one and just return the next future:\n\n```\nlet d1 = networkRequest(args).future()\nlet d2 = d1.flatMap { t -> EventLoopFuture<NewValue> in\n    . . . something with t . . .\n    return netWorkRequest(args)\n}\nd2.whenSuccess { u in\n    NSLog(\"Result of second request: \\(u)\")\n}\n```\n\nNote: In a sense, the `EventLoopFuture<NewValue>` is returned before it's created.\n\n- parameters:\n    - callback: Function that will receive the value of this `EventLoopFuture` and return\n        a new `EventLoopFuture`.\n- returns: A future that will receive the eventual value."},{"p":["EventLoopFuture","recover(file:line:_:)"],"f":[["func",12],[" ",17],["recover",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["recover",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", (",17],["Error",18],[") -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Value",0,0]]},{"p":["EventLoopFuture","recover(_:)"],"f":[["func",12],[" ",17],["recover",7],["(",17],["_",1],[" ",17],["callback",2],[": ",17],["@escaping",12],[" (",17],["Error",18,1380],[") -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["recover",7],["((",17],["Error",18],[") -> ",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,0]],"d":"When the current `EventLoopFuture<Value>` is in an error state, run the provided callback, which\ncan recover from the error and return a new value of type `Value`. The provided callback may not `throw`,\nso this function should be used when the error is always recoverable.\n\nOperations performed in `recover` should not block, or they will block the entire\nevent loop. `recover` is intended for use when you have the ability to synchronously\nrecover from errors.\n\n- parameters:\n    - callback: Function that will receive the error value of this `EventLoopFuture` and return\n        a new value lifted into a new `EventLoopFuture`.\n- returns: A future that will receive the recovered value."},{"p":["EventLoopPromise","completeWith(_:)"],"f":[["func",12],[" ",17],["completeWith",7],["(",17],["_",1],[" ",17],["future",2],[": ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">)",17]],"s":[["func",12],[" ",17],["completeWith",7],["(",17],["EventLoopFuture",18],["<",17],["Value",18],[">)",17]],"g":[["Value",0,0]],"d":"Complete the promise with the passed in `EventLoopFuture<Value>`.\n\nThis method is equivalent to invoking `future.cascade(to: promise)`,\nbut sometimes may read better than its cascade counterpart.\n\n- parameters:\n    - future: The future whose value will be used to succeed or fail this promise.\n- seealso: `EventLoopFuture.cascade(to:)`"},{"p":["EventLoopPromise","completeWith(_:)"],"f":[["func",12],[" ",17],["completeWith",7],["(",17],["_",1],[" ",17],["result",2],[": ",17],["Result",18,1386],["<",17],["Value",18],[", ",17],["Error",18,1380],[">)",17]],"s":[["func",12],[" ",17],["completeWith",7],["(",17],["Result",18],["<",17],["Value",18],[", ",17],["Error",18],[">)",17]],"g":[["Value",0,0]],"d":"Complete the promise with the passed in `Result<Value, Error>`.\n\nThis method is equivalent to invoking:\n```\nswitch result {\ncase .success(let value):\n    promise.succeed(value)\ncase .failure(let error):\n    promise.fail(error)\n}\n```\n\n- parameters:\n    - result: The result which will be used to succeed or fail this promise."},{"p":["EventLoopPromise","completeWithTask(_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["completeWithTask",7],["(",17],["_",1],[" ",17],["body",2],[": ",17],["@escaping",12],[" () ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["Value",18],[") -> ",17],["Task",18,1225],["<",17],["Void",18,1379],[", ",17],["Never",18,1383],[">",17]],"s":[["func",12],[" ",17],["completeWithTask",7],["(() ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["Value",18],[") -> ",17],["Task",18],["<",17],["Void",18],[", ",17],["Never",18],[">",17]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"g":[["Value",0,0]],"d":"Complete a future with the result (or error) of the `async` function `body`.\n\nThis function can be used to bridge the `async` world into an `EventLoopPromise`.\n\n- parameters:\n  - body: The `async` function to run.\n- returns: A `Task` which was created to `await` the `body`."},{"p":["EventLoopPromise","fail(_:)"],"f":[["func",12],[" ",17],["fail",7],["(",17],["_",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["fail",7],["(",17],["Error",18],[")",17]],"g":[["Value",0,0]],"d":"Deliver an error to the associated `EventLoopFuture<Value>` object.\n\n- parameters:\n     - error: The error from the operation."},{"p":["EventLoopPromise","succeed(_:)"],"f":[["func",12],[" ",17],["succeed",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Value",18],[")",17]],"s":[["func",12],[" ",17],["succeed",7],["(",17],["Value",18],[")",17]],"g":[["Value",0,0]],"d":"Deliver a successful result to the associated `EventLoopFuture<Value>` object.\n\n- parameters:\n    - value: The successful result of the operation."},{"p":["IdleStateHandler","channelRead(context:data:)"],"f":[["func",12],[" ",17],["channelRead",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["data",1],[": ",17],["NIOAny",18,115],[")",17]],"s":[["func",12],[" ",17],["channelRead",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["data",1],[": ",17],["NIOAny",18],[")",17]]},{"p":["IdleStateHandler","handlerAdded(context:)"],"f":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["IdleStateHandler","channelActive(context:)"],"f":[["func",12],[" ",17],["channelActive",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["channelActive",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["IdleStateHandler","handlerRemoved(context:)"],"f":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["IdleStateHandler","channelReadComplete(context:)"],"f":[["func",12],[" ",17],["channelReadComplete",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["channelReadComplete",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["IdleStateHandler","write(context:data:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["data",1],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["data",1],[": ",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["MulticastChannel","leaveGroup(_:device:promise:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18,98],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Request that the `MulticastChannel` leave the multicast group given by `group` on the device\ngiven by `device`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - device: The device on which to leave the given group, or `nil` to allow the kernel to choose.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","leaveGroup(_:promise:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Request that the `MulticastChannel` leave the multicast group given by `group`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","leaveGroup(_:interface:promise:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18,124],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"a":{"a":{"d":true,"r":"leaveGroup(_:device:promise:)"}},"d":"Request that the `MulticastChannel` leave the multicast group given by `group` on the interface\ngiven by `interface`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - interface: The interface on which to leave the given group, or `nil` to allow the kernel to choose.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","joinGroup(_:device:promise:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18,98],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Request that the `MulticastChannel` join the multicast group given by `group` on the device\ngiven by `device`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - device: The device on which to join the given group, or `nil` to allow the kernel to choose.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","joinGroup(_:promise:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Request that the `MulticastChannel` join the multicast group given by `group`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","joinGroup(_:interface:promise:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18,124],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"a":{"a":{"d":true,"r":"joinGroup(_:device:promise:)"}},"d":"Request that the `MulticastChannel` join the multicast group given by `group` on the interface\ngiven by `interface`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - interface: The interface on which to join the given group, or `nil` to allow the kernel to choose.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","leaveGroup(_:device:promise:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18,98],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Request that the `MulticastChannel` leave the multicast group given by `group` on the device\ngiven by `device`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - device: The device on which to leave the given group, or `nil` to allow the kernel to choose.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","leaveGroup(_:device:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18,98],["?) -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18],["?) -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]]},{"p":["MulticastChannel","leaveGroup(_:promise:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["MulticastChannel","leaveGroup(_:interface:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18,124],["?) -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18],["?) -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"a":{"a":{"d":true,"r":"leaveGroup(_:device:)"}}},{"p":["MulticastChannel","leaveGroup(_:)"],"f":[["func",12],[" ",17],["leaveGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["leaveGroup",7],["(",17],["SocketAddress",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]]},{"p":["MulticastChannel","joinGroup(_:device:promise:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18,98],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18],["?, ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Request that the `MulticastChannel` join the multicast group given by `group` on the device\ngiven by `device`.\n\n- parameters:\n    - group: The IP address corresponding to the relevant multicast group.\n    - device: The device on which to join the given group, or `nil` to allow the kernel to choose.\n    - promise: The `EventLoopPromise` that will be notified once the operation is complete, or\n        `nil` if you are not interested in the result of the operation."},{"p":["MulticastChannel","joinGroup(_:device:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18,98],["?) -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[", ",17],["device",1],[": ",17],["NIONetworkDevice",18],["?) -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]]},{"p":["MulticastChannel","joinGroup(_:promise:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["MulticastChannel","joinGroup(_:interface:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18,124],["?) -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[", ",17],["interface",1],[": ",17],["NIONetworkInterface",18],["?) -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"a":{"a":{"d":true,"r":"joinGroup(_:device:)"}}},{"p":["MulticastChannel","joinGroup(_:)"],"f":[["func",12],[" ",17],["joinGroup",7],["(",17],["_",1],[" ",17],["group",2],[": ",17],["SocketAddress",18,43],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["joinGroup",7],["(",17],["SocketAddress",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]]},{"p":["NIOInsecureNoTLS","enableTLS(_:)"],"f":[["func",12],[" ",17],["enableTLS",7],["(",17],["_",1],[" ",17],["bootstrap",2],[": ",17],["Bootstrap",18],[") -> ",17],["Bootstrap",18]],"s":[["func",12],[" ",17],["enableTLS",7],["(",17],["Bootstrap",18],[") -> ",17],["Bootstrap",18]],"c":[["Bootstrap",1,"NIOClientTCPBootstrapProtocol",24]],"g":[["Bootstrap",0,0]]},{"p":["NIONetworkDevice","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,1385],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]]},{"p":["EventLoopIterator","next()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18,28],["?",17]],"s":[["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18],["?",17]],"d":"Advances to the next `EventLoop` and returns it, or `nil` if no next element exists.\n\n- returns: The next `EventLoop` if a next element exists; otherwise, `nil`."},{"p":["BackPressureHandler","handlerRemoved(context:)"],"f":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["BackPressureHandler","channelWritabilityChanged(context:)"],"f":[["func",12],[" ",17],["channelWritabilityChanged",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["channelWritabilityChanged",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["BackPressureHandler","read(context:)"],"f":[["func",12],[" ",17],["read",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["read",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["ByteBufferAllocator","buffer(dispatchData:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["dispatchData",1],[": ",17],["DispatchData",18,1110],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["dispatchData",1],[": ",17],["DispatchData",18],[") -> ",17],["ByteBuffer",18]],"d":"Create a fresh `ByteBuffer` containing the bytes contained in the given `DispatchData`.\n\nThis will allocate a new `ByteBuffer` with enough space to fit the bytes of the `DispatchData` and potentially\nsome extra space.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["ByteBufferAllocator","buffer(staticString:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["staticString",1],[" ",17],["string",2],[": ",17],["StaticString",18,1359],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["staticString",1],[": ",17],["StaticString",18],[") -> ",17],["ByteBuffer",18]],"d":"Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["ByteBufferAllocator","buffer(bytes:)"],"f":[["func",12],[" ",17],["buffer",7],["<",17],["Bytes",0],[">(",17],["bytes",1],[": ",17],["Bytes",18],[") -> ",17],["ByteBuffer",18,58],[" ",17],["where",12],[" ",17],["Bytes",18],[" : ",17],["Sequence",18,1166],[", ",17],["Bytes",18],[".",17],["Element",18],[" == ",17],["UInt8",18,1384]],"s":[["func",12],[" ",17],["buffer",7],["<",17],["Bytes",0],[">(",17],["bytes",1],[": ",17],["Bytes",18],[") -> ",17],["ByteBuffer",18]],"c":[["Bytes",1,"Sequence",1166],["Bytes.Element",2,"UInt8",1384]],"g":[["Bytes",0,0]],"d":"Create a fresh `ByteBuffer` containing the `bytes`.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `bytes` and potentially some extra space.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["ByteBufferAllocator","buffer(string:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["string",1],[": ",17],["String",18,1165],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["string",1],[": ",17],["String",18],[") -> ",17],["ByteBuffer",18]],"d":"Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["ByteBufferAllocator","buffer(integer:endianness:as:)"],"f":[["func",12],[" ",17],["buffer",7],["<",17],["I",0],[">(",17],["integer",1],[": ",17],["I",18],[", ",17],["endianness",1],[": ",17],["Endianness",18,38],[" = .big, ",17],["as",1],[": ",17],["I",18],[".Type = I.self) -> ",17],["ByteBuffer",18,58],[" ",17],["where",12],[" ",17],["I",18],[" : ",17],["FixedWidthInteger",18,1361]],"s":[["func",12],[" ",17],["buffer",7],["<",17],["I",0],[">(",17],["integer",1],[": ",17],["I",18],[", ",17],["endianness",1],[": ",17],["Endianness",18],[", ",17],["as",1],[": ",17],["I",18],[".Type) -> ",17],["ByteBuffer",18]],"c":[["I",1,"FixedWidthInteger",1361]],"g":[["I",0,0]],"d":"Create a fresh `ByteBuffer` containing the bytes of the byte representation in the given `endianness` of\n`integer`.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `integer` and potentially some extra space.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["ByteBufferAllocator","buffer(capacity:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["capacity",1],[": ",17],["Int",18,1227],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["capacity",1],[": ",17],["Int",18],[") -> ",17],["ByteBuffer",18]],"d":"Request a freshly allocated `ByteBuffer` of size `capacity` or larger.\n\n- note: The passed `capacity` is the `ByteBuffer`'s initial capacity, it will grow automatically if necessary.\n\n- note: If `capacity` is `0`, this function will not allocate. If you want to trigger an allocation immediately,\n        also call `.clear()`.\n\n- parameters:\n    - capacity: The initial capacity of the returned `ByteBuffer`."},{"p":["ByteBufferAllocator","buffer(repeating:count:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["repeating",1],[" ",17],["byte",2],[": ",17],["UInt8",18,1384],[", ",17],["count",1],[": ",17],["Int",18,1227],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["repeating",1],[": ",17],["UInt8",18],[", ",17],["count",1],[": ",17],["Int",18],[") -> ",17],["ByteBuffer",18]],"d":"Create a fresh `ByteBuffer` containing `count` repetitions of `byte`.\n\nThis will allocate a new `ByteBuffer` with at least `count` bytes.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["ByteBufferAllocator","buffer(substring:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["substring",1],[" ",17],["string",2],[": ",17],["Substring",18,1340],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["substring",1],[": ",17],["Substring",18],[") -> ",17],["ByteBuffer",18]],"d":"Create a fresh `ByteBuffer` containing the bytes of the `string` encoded as UTF-8.\n\nThis will allocate a new `ByteBuffer` with enough space to fit `string` and potentially some extra space.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["ByteBufferAllocator","buffer(buffer:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[") -> ",17],["ByteBuffer",18]],"d":"Create a fresh `ByteBuffer` containing the readable bytes of `buffer`.\n\nThis may allocate a new `ByteBuffer` with enough space to fit `buffer` and potentially some extra space.\n\n- note: Use this method only if you deliberately want to reallocate a potentially smaller `ByteBuffer` than the\n        one you already have. Given that `ByteBuffer` is a value type, defensive copies are not necessary. If\n        you have a `ByteBuffer` but would like the `readerIndex` to start at `0`, consider `readSlice` instead.\n\n- returns: The `ByteBuffer` containing the written bytes."},{"p":["AcceptBackoffHandler","errorCaught(context:error:)"],"f":[["func",12],[" ",17],["errorCaught",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["error",1],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["errorCaught",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["error",1],[": ",17],["Error",18],[")",17]]},{"p":["AcceptBackoffHandler","handlerRemoved(context:)"],"f":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["AcceptBackoffHandler","channelInactive(context:)"],"f":[["func",12],[" ",17],["channelInactive",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["channelInactive",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["AcceptBackoffHandler","read(context:)"],"f":[["func",12],[" ",17],["read",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["read",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["ByteToMessageDecoder","decodeLast(context:buffer:seenEOF:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[", ",17],["seenEOF",1],[": ",17],["Bool",18,1224],[") ",17],["throws",12],[" -> ",17],["DecodingState",18,42]],"s":[["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[", ",17],["seenEOF",1],[": ",17],["Bool",18],[") ",17],["throws",12],[" -> ",17],["DecodingState",18]],"d":"Decode from a `ByteBuffer` when no more data is incoming and the `ByteToMessageDecoder` is about to leave\nthe pipeline.\n\nThis method is called in a loop only once, when the `ChannelHandlerContext` goes inactive (i.e. when `channelInactive` is fired or\nthe `ByteToMessageDecoder` is removed from the pipeline).\n\nLike with `decode`, this method will be called in a loop until either `DecodingState.needMoreData` is returned from the method\nor until the input `ByteBuffer` has no more readable bytes. If `DecodingState.continue` is returned and the `ByteBuffer`\ncontains more readable bytes, this method will immediately be invoked again.\n\n- parameters:\n    - context: The `ChannelHandlerContext` which this `ByteToMessageDecoder` belongs to.\n    - buffer: The `ByteBuffer` from which we decode.\n    - seenEOF: `true` if EOF has been seen. Usually if this is `false` the handler has been removed.\n- returns: `DecodingState.continue` if we should continue calling this method or `DecodingState.needMoreData` if it should be called\n           again when more data is present in the `ByteBuffer`."},{"p":["ByteToMessageDecoder","decoderAdded(context:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decoderAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["decoderAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"d":"Called when this `ByteToMessageDecoder` is added to the `ChannelPipeline`.\n\n- parameters:\n    - context: The `ChannelHandlerContext` which this `ByteToMessageDecoder` belongs to."},{"p":["ByteToMessageDecoder","decoderRemoved(context:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decoderRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["decoderRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"d":"Called once this `ByteToMessageDecoder` is removed from the `ChannelPipeline`.\n\n- parameters:\n    - context: The `ChannelHandlerContext` which this `ByteToMessageDecoder` belongs to."},{"p":["ByteToMessageDecoder","shouldReclaimBytes(buffer:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["shouldReclaimBytes",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[") -> ",17],["Bool",18,1224]],"s":[["func",12],[" ",17],["shouldReclaimBytes",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[") -> ",17],["Bool",18]],"d":"Determine if the read bytes in the given `ByteBuffer` should be reclaimed and their associated memory freed.\nBe aware that reclaiming memory may involve memory copies and so is not free.\n\n- parameters:\n    - buffer: The `ByteBuffer` to check\n- return: `true` if memory should be reclaimed, `false` otherwise."},{"p":["ByteToMessageDecoder","decode(context:buffer:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decode",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["throws",12],[" -> ",17],["DecodingState",18,42]],"s":[["func",12],[" ",17],["decode",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["throws",12],[" -> ",17],["DecodingState",18]],"d":"Decode from a `ByteBuffer`.\n\nThis method will be called in a loop until either the input `ByteBuffer` has nothing to read left or\n`DecodingState.needMoreData` is returned. If `DecodingState.continue` is returned and the `ByteBuffer`\ncontains more readable bytes, this method will immediately be invoked again, unless `decodeLast` needs\nto be invoked instead.\n\n- parameters:\n    - context: The `ChannelHandlerContext` which this `ByteToMessageDecoder` belongs to.\n    - buffer: The `ByteBuffer` from which we decode.\n- returns: `DecodingState.continue` if we should continue calling this method or `DecodingState.needMoreData` if it should be called\n           again once more data is present in the `ByteBuffer`."},{"p":["ByteToMessageDecoder","decodeLast(context:buffer:seenEOF:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[", ",17],["seenEOF",1],[": ",17],["Bool",18,1224],[") ",17],["throws",12],[" -> ",17],["DecodingState",18,42]],"s":[["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[", ",17],["seenEOF",1],[": ",17],["Bool",18],[") ",17],["throws",12],[" -> ",17],["DecodingState",18]]},{"p":["ByteToMessageDecoder","decoderAdded(context:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decoderAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["decoderAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["ByteToMessageDecoder","decoderRemoved(context:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decoderRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["decoderRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]]},{"p":["ByteToMessageDecoder","wrapInboundOut(_:)"],"f":[["func",12],[" ",17],["wrapInboundOut",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Self",18],[".",17],["InboundOut",18],[") -> ",17],["NIOAny",18,115]],"s":[["func",12],[" ",17],["wrapInboundOut",7],["(",17],["Self",18],[".",17],["InboundOut",18],[") -> ",17],["NIOAny",18]]},{"p":["ByteToMessageDecoder","shouldReclaimBytes(buffer:)"],"f":[["func",12],[" ",17],["shouldReclaimBytes",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[") -> ",17],["Bool",18,1224]],"s":[["func",12],[" ",17],["shouldReclaimBytes",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[") -> ",17],["Bool",18]],"d":"Default implementation to detect once bytes should be reclaimed."},{"p":["ByteToMessageHandler","removeHandler(context:removalToken:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18,128],[".",17],["RemovalToken",18,106],[")",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18],[".",17],["RemovalToken",18],[")",17]],"e":[["Decoder",1,"ByteToMessageDecoder",13]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]]},{"p":["ByteToMessageHandler","channelRead(context:data:)"],"f":[["func",12],[" ",17],["channelRead",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["data",1],[": ",17],["NIOAny",18,115],[")",17]],"s":[["func",12],[" ",17],["channelRead",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["data",1],[": ",17],["NIOAny",18],[")",17]],"e":[["Decoder",1,"ByteToMessageDecoder",13]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]],"d":"Calls `decode` until there is nothing left to decode."},{"p":["ByteToMessageHandler","handlerAdded(context:)"],"f":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"e":[["Decoder",1,"ByteToMessageDecoder",13]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]]},{"p":["ByteToMessageHandler","handlerRemoved(context:)"],"f":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"e":[["Decoder",1,"ByteToMessageDecoder",13]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]]},{"p":["ByteToMessageHandler","channelInactive(context:)"],"f":[["func",12],[" ",17],["channelInactive",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["channelInactive",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"e":[["Decoder",1,"ByteToMessageDecoder",13]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]],"d":"Call `decodeLast` before forward the event through the pipeline."},{"p":["ByteToMessageHandler","userInboundEventTriggered(context:event:)"],"f":[["func",12],[" ",17],["userInboundEventTriggered",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["event",1],[": ",17],["Any",12],[")",17]],"s":[["func",12],[" ",17],["userInboundEventTriggered",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["event",1],[": ",17],["Any",12],[")",17]],"e":[["Decoder",1,"ByteToMessageDecoder",13]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]]},{"p":["ByteToMessageHandler","write(context:data:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["data",1],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["data",1],[": ",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"e":[["Decoder",1,"WriteObservingByteToMessageDecoder",26]],"c":[["Decoder",1,"WriteObservingByteToMessageDecoder",26]],"g":[["Decoder",0,0]]},{"p":["MarkedCircularBuffer","isMarked(index:)"],"f":[["func",12],[" ",17],["isMarked",7],["(",17],["index",1],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[") -> ",17],["Bool",18,1224]],"s":[["func",12],[" ",17],["isMarked",7],["(",17],["index",1],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Bool",18]],"g":[["Element",0,0]],"d":"Returns true if the buffer is currently marked at the given index."},{"p":["MarkedCircularBuffer","removeFirst()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["() -> ",17],["Element",18]],"s":[["func",12],[" ",17],["removeFirst",7],["() -> ",17],["Element",18]],"g":[["Element",0,0]],"d":"Removes the first element from the buffer."},{"p":["MarkedCircularBuffer","mark()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["mark",7],["()",17]],"s":[["func",12],[" ",17],["mark",7],["()",17]],"g":[["Element",0,0]],"d":"Marks the buffer at the current index, making the last index in the buffer marked."},{"p":["MarkedCircularBuffer","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[") -> ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"g":[["Element",0,0]]},{"p":["MarkedCircularBuffer","index(before:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[") -> ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078]],"s":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"g":[["Element",0,0]]},{"p":["MarkedCircularBuffer","index(_:offsetBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,1227],[") -> ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078]],"s":[["func",12],[" ",17],["index",7],["(",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[") -> ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18]],"g":[["Element",0,0]]},{"p":["MarkedCircularBuffer","append(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["append",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Element",18],[")",17]],"s":[["func",12],[" ",17],["append",7],["(",17],["Element",18],[")",17]],"g":[["Element",0,0]],"d":"Appends an entry to the buffer, expanding it if needed."},{"p":["MarkedCircularBuffer","distance(from:to:)"],"f":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[" ",17],["start",2],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[", ",17],["to",1],[" ",17],["end",2],[": ",17],["MarkedCircularBuffer",18,104],["<",17],["Element",18],[">.",17],["Index",18,1078],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[", ",17],["to",1],[": ",17],["MarkedCircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Int",18]],"g":[["Element",0,0]]},{"p":["MarkedCircularBuffer","popFirst()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["popFirst",7],["() -> ",17],["Element",18],["?",17]],"s":[["func",12],[" ",17],["popFirst",7],["() -> ",17],["Element",18],["?",17]],"g":[["Element",0,0]]},{"p":["MessageToByteEncoder","encode(data:out:)"],"f":[["func",12],[" ",17],["encode",7],["(",17],["data",1],[": ",17],["Self",18],[".",17],["OutboundIn",18],[", ",17],["out",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["throws",12]],"s":[["func",12],[" ",17],["encode",7],["(",17],["data",1],[": ",17],["Self",18],[".",17],["OutboundIn",18],[", ",17],["out",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["throws",12]],"d":"Called once there is data to encode.\n\n- parameters:\n    - data: The data to encode into a `ByteBuffer`.\n    - out: The `ByteBuffer` into which we want to encode."},{"p":["MessageToByteHandler","handlerAdded(context:)"],"f":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerAdded",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"e":[["Encoder",1,"MessageToByteEncoder",14]],"c":[["Encoder",1,"MessageToByteEncoder",14]],"g":[["Encoder",0,0]]},{"p":["MessageToByteHandler","handlerRemoved(context:)"],"f":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[")",17]],"s":[["func",12],[" ",17],["handlerRemoved",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[")",17]],"e":[["Encoder",1,"MessageToByteEncoder",14]],"c":[["Encoder",1,"MessageToByteEncoder",14]],"g":[["Encoder",0,0]]},{"p":["MessageToByteHandler","write(context:data:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["data",1],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["data",1],[": ",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"e":[["Encoder",1,"MessageToByteEncoder",14]],"c":[["Encoder",1,"MessageToByteEncoder",14]],"g":[["Encoder",0,0]]},{"p":["NIOClientTLSProvider","enableTLS(_:)"],"f":[["func",12],[" ",17],["enableTLS",7],["(",17],["_",1],[" ",17],["bootstrap",2],[": ",17],["Self",18],[".",17],["Bootstrap",18],[") -> ",17],["Self",18],[".",17],["Bootstrap",18]],"s":[["func",12],[" ",17],["enableTLS",7],["(",17],["Self",18],[".",17],["Bootstrap",18],[") -> ",17],["Self",18],[".",17],["Bootstrap",18]]},{"p":["SocketOptionProvider","unsafeGetSocketOption(level:name:)"],"f":[["func",12],[" ",17],["unsafeGetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64],[", ",17],["name",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["unsafeGetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18],[", ",17],["name",1],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,1]],"d":"Obtain the value of the socket option for the given level and name.\n\nThis function is not memory-safe: if you set the generic type parameter incorrectly,\nthis function will still execute, and this can cause you to incorrectly interpret memory\nand thereby read uninitialized or invalid memory. If at all possible, please use one of\nthe safe functions defined by this protocol.\n\n- parameters:\n    - level: The socket option level, e.g. `SOL_SOCKET` or `IPPROTO_IP`.\n    - name: The name of the socket option, e.g. `SO_REUSEADDR`.\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","unsafeGetSocketOption(level:name:)"],"f":[["func",12],[" ",17],["unsafeGetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["SocketOptionLevel",18,1063],[", ",17],["name",1],[": ",17],["SocketOptionName",18,1061],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["unsafeGetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["SocketOptionLevel",18],[", ",17],["name",1],[": ",17],["SocketOptionName",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Value",18],[">",17]],"g":[["Value",0,1]],"d":"Obtain the value of the socket option for the given level and name.\n\nThis function is not memory-safe: if you set the generic type parameter incorrectly,\nthis function will still execute, and this can cause you to incorrectly interpret memory\nand thereby read uninitialized or invalid memory. If at all possible, please use one of\nthe safe functions defined by this protocol.\n\n- parameters:\n    - level: The socket option level, e.g. `SOL_SOCKET` or `IPPROTO_IP`.\n    - name: The name of the socket option, e.g. `SO_REUSEADDR`.\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","unsafeSetSocketOption(level:name:value:)"],"f":[["func",12],[" ",17],["unsafeSetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["OptionLevel",18,64],[", ",17],["name",1],[": ",17],["NIOBSDSocket",18,41],[".",17],["Option",18,67],[", ",17],["value",1],[": ",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["unsafeSetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["NIOBSDSocket",18],[".",17],["OptionLevel",18],[", ",17],["name",1],[": ",17],["NIOBSDSocket",18],[".",17],["Option",18],[", ",17],["value",1],[": ",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"g":[["Value",0,1]],"d":"Set a socket option for a given level and name to the specified value.\n\nThis function is not memory-safe: if you set the generic type parameter incorrectly,\nthis function will still execute, and this can cause you to incorrectly interpret memory\nand thereby read uninitialized or invalid memory. If at all possible, please use one of\nthe safe functions defined by this protocol.\n\n- parameters:\n    - level: The socket option level, e.g. `SOL_SOCKET` or `IPPROTO_IP`.\n    - name: The name of the socket option, e.g. `SO_REUSEADDR`.\n    - value: The value to set the socket option to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","unsafeSetSocketOption(level:name:value:)"],"f":[["func",12],[" ",17],["unsafeSetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["SocketOptionLevel",18,1063],[", ",17],["name",1],[": ",17],["SocketOptionName",18,1061],[", ",17],["value",1],[": ",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["unsafeSetSocketOption",7],["<",17],["Value",0],[">(",17],["level",1],[": ",17],["SocketOptionLevel",18],[", ",17],["name",1],[": ",17],["SocketOptionName",18],[", ",17],["value",1],[": ",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"g":[["Value",0,1]],"d":"Set a socket option for a given level and name to the specified value.\n\nThis function is not memory-safe: if you set the generic type parameter incorrectly,\nthis function will still execute, and this can cause you to incorrectly interpret memory\nand thereby read uninitialized or invalid memory. If at all possible, please use one of\nthe safe functions defined by this protocol.\n\n- parameters:\n    - level: The socket option level, e.g. `SOL_SOCKET` or `IPPROTO_IP`.\n    - name: The name of the socket option, e.g. `SO_REUSEADDR`.\n    - value: The value to set the socket option to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","getTCPInfo()"],"f":[["func",12],[" ",17],["getTCPInfo",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["tcp_info",18,1098],[">",17]],"s":[["func",12],[" ",17],["getTCPInfo",7],["() -> ",17],["EventLoopFuture",18],["<",17],["tcp_info",18],[">",17]],"d":"Gets the value of the socket option TCP_INFO.\n\nThis socket option cannot be set.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","getSoLinger()"],"f":[["func",12],[" ",17],["getSoLinger",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["linger",18,1093],[">",17]],"s":[["func",12],[" ",17],["getSoLinger",7],["() -> ",17],["EventLoopFuture",18],["<",17],["linger",18],[">",17]],"d":"Gets the value of the socket option SO_LINGER.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","setSoLinger(_:)"],"f":[["func",12],[" ",17],["setSoLinger",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["linger",18,1093],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["setSoLinger",7],["(",17],["linger",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Sets the socket option SO_LINGER to `value`.\n\n- parameters:\n    - value: The value to set SO_LINGER to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","getIPMulticastIF()"],"f":[["func",12],[" ",17],["getIPMulticastIF",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["in_addr",18,1092],[">",17]],"s":[["func",12],[" ",17],["getIPMulticastIF",7],["() -> ",17],["EventLoopFuture",18],["<",17],["in_addr",18],[">",17]],"d":"Gets the value of the socket option IP_MULTICAST_IF.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","setIPMulticastIF(_:)"],"f":[["func",12],[" ",17],["setIPMulticastIF",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["in_addr",18,1092],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["setIPMulticastIF",7],["(",17],["in_addr",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Sets the socket option IP_MULTICAST_IF to `value`.\n\n- parameters:\n    - value: The value to set IP_MULTICAST_IF to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","getIPMulticastTTL()"],"f":[["func",12],[" ",17],["getIPMulticastTTL",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["CUnsignedChar",18,1360],[">",17]],"s":[["func",12],[" ",17],["getIPMulticastTTL",7],["() -> ",17],["EventLoopFuture",18],["<",17],["CUnsignedChar",18],[">",17]],"d":"Gets the value of the socket option IP_MULTICAST_TTL.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","setIPMulticastTTL(_:)"],"f":[["func",12],[" ",17],["setIPMulticastTTL",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["CUnsignedChar",18,1360],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["setIPMulticastTTL",7],["(",17],["CUnsignedChar",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Sets the socket option IP_MULTICAST_TTL to `value`.\n\n- parameters:\n    - value: The value to set IP_MULTICAST_TTL to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","getIPMulticastLoop()"],"f":[["func",12],[" ",17],["getIPMulticastLoop",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["CUnsignedChar",18,1360],[">",17]],"s":[["func",12],[" ",17],["getIPMulticastLoop",7],["() -> ",17],["EventLoopFuture",18],["<",17],["CUnsignedChar",18],[">",17]],"d":"Gets the value of the socket option IP_MULTICAST_LOOP.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","getIPv6MulticastIF()"],"f":[["func",12],[" ",17],["getIPv6MulticastIF",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["CUnsignedInt",18,1358],[">",17]],"s":[["func",12],[" ",17],["getIPv6MulticastIF",7],["() -> ",17],["EventLoopFuture",18],["<",17],["CUnsignedInt",18],[">",17]],"d":"Gets the value of the socket option IPV6_MULTICAST_IF.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","setIPMulticastLoop(_:)"],"f":[["func",12],[" ",17],["setIPMulticastLoop",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["CUnsignedChar",18,1360],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["setIPMulticastLoop",7],["(",17],["CUnsignedChar",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Sets the socket option IP_MULTICAST_LOOP to `value`.\n\n- parameters:\n    - value: The value to set IP_MULTICAST_LOOP to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","setIPv6MulticastIF(_:)"],"f":[["func",12],[" ",17],["setIPv6MulticastIF",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["CUnsignedInt",18,1358],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["setIPv6MulticastIF",7],["(",17],["CUnsignedInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Sets the socket option IPV6_MULTICAST_IF to `value`.\n\n- parameters:\n    - value: The value to set IPV6_MULTICAST_IF to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","getIPv6MulticastHops()"],"f":[["func",12],[" ",17],["getIPv6MulticastHops",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["CInt",18,1378],[">",17]],"s":[["func",12],[" ",17],["getIPv6MulticastHops",7],["() -> ",17],["EventLoopFuture",18],["<",17],["CInt",18],[">",17]],"d":"Gets the value of the socket option IPV6_MULTICAST_HOPS.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","getIPv6MulticastLoop()"],"f":[["func",12],[" ",17],["getIPv6MulticastLoop",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["CUnsignedInt",18,1358],[">",17]],"s":[["func",12],[" ",17],["getIPv6MulticastLoop",7],["() -> ",17],["EventLoopFuture",18],["<",17],["CUnsignedInt",18],[">",17]],"d":"Gets the value of the socket option IPV6_MULTICAST_LOOP.\n\n- returns: An `EventLoopFuture` containing the value of the socket option, or\n    any error that occurred while retrieving the socket option."},{"p":["SocketOptionProvider","setIPv6MulticastHops(_:)"],"f":[["func",12],[" ",17],["setIPv6MulticastHops",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["CInt",18,1378],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["setIPv6MulticastHops",7],["(",17],["CInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Sets the socket option IPV6_MULTICAST_HOPS to `value`.\n\n- parameters:\n    - value: The value to set IPV6_MULTICAST_HOPS to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["SocketOptionProvider","setIPv6MulticastLoop(_:)"],"f":[["func",12],[" ",17],["setIPv6MulticastLoop",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["CUnsignedInt",18,1358],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["setIPv6MulticastLoop",7],["(",17],["CUnsignedInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Sets the socket option IPV6_MULTICAST_LOOP to `value`.\n\n- parameters:\n    - value: The value to set IPV6_MULTICAST_LOOP to.\n- returns: An `EventLoopFuture` that fires when the option has been set,\n    or if an error has occurred."},{"p":["ChannelHandlerContext","fireChannelRegistered()"],"f":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]],"d":"Send a `channelRegistered` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.\n\n- note: For correct operation it is very important to forward any `channelRegistered` event using this method at the right point in time, that is usually when received."},{"p":["ChannelHandlerContext","fireChannelReadComplete()"],"f":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]],"d":"Signal to the next `ChannelHandler` that a read burst has finished."},{"p":["ChannelHandlerContext","fireChannelUnregistered()"],"f":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]],"d":"Send a `channelUnregistered` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.\n\n- note: For correct operation it is very important to forward any `channelUnregistered` event using this method at the right point in time, that is usually when received."},{"p":["ChannelHandlerContext","fireChannelWritabilityChanged()"],"f":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]],"d":"Send a `writabilityChanged` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.\n\n- note: For correct operation it is very important to forward any `writabilityChanged` event using this method at the right point in time, that is usually when received."},{"p":["ChannelHandlerContext","fireChannelRead(_:)"],"f":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[")",17]],"s":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["NIOAny",18],[")",17]],"d":"Send data to the next inbound `ChannelHandler`. The data should be of type `ChannelInboundHandler.InboundOut`."},{"p":["ChannelHandlerContext","fireChannelActive()"],"f":[["func",12],[" ",17],["fireChannelActive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelActive",7],["()",17]],"d":"Send a `channelActive` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.\n\n- note: For correct operation it is very important to forward any `channelActive` event using this method at the right point in time, that is often when received."},{"p":["ChannelHandlerContext","fireChannelInactive()"],"f":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]],"d":"Send a `channelInactive` event to the next (inbound) `ChannelHandler` in the `ChannelPipeline`.\n\n- note: For correct operation it is very important to forward any `channelInactive` event using this method at the right point in time, that is often when received."},{"p":["ChannelHandlerContext","leavePipeline(removalToken:)"],"f":[["func",12],[" ",17],["leavePipeline",7],["(",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18,128],[".",17],["RemovalToken",18,106],[")",17]],"s":[["func",12],[" ",17],["leavePipeline",7],["(",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18],[".",17],["RemovalToken",18],[")",17]],"d":"Synchronously remove the `ChannelHandler` with the given `ChannelHandlerContext`.\n\n- note: This function must only be used from a `RemovableChannelHandler` to remove itself. Calling this method\n        on any other `ChannelHandlerContext` leads to undefined behaviour.\n\n- parameters:\n   - removalToken: The removal token received from `RemovableChannelHandler.removeHandler`"},{"p":["ChannelHandlerContext","writeAndFlush(_:promise:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Send a `write` event followed by a `flush` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\nWhen the `write` event reaches the `HeadChannelHandler` the data will be enqueued to be written when the `flush`\nalso reaches the `HeadChannelHandler`.\n\n- parameters:\n    - data: The data to write, should be of type `ChannelOutboundHandler.OutboundOut`.\n    - promise: The promise fulfilled when the previously written data been written and flushed or if that failed."},{"p":["ChannelHandlerContext","fireErrorCaught(_:)"],"f":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["_",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["Error",18],[")",17]],"d":"Send an error to the next inbound `ChannelHandler`."},{"p":["ChannelHandlerContext","triggerUserOutboundEvent(_:promise:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Send a user event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\n\n- parameters:\n    - event: The user event to send.\n    - promise: The promise fulfilled when the user event has been sent or failed if it couldn't be sent."},{"p":["ChannelHandlerContext","fireUserInboundEventTriggered(_:)"],"f":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[")",17]],"s":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["Any",12],[")",17]],"d":"Send a user event to the next inbound `ChannelHandler`."},{"p":["ChannelHandlerContext","bind(to:promise:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Send a `bind` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\nWhen the `bind` event reaches the `HeadChannelHandler` a `ServerSocketChannel` will be bound.\n\n- parameters:\n    - address: The address to bind to.\n    - promise: The promise fulfilled when the socket is bound or failed if it cannot be bound."},{"p":["ChannelHandlerContext","read()"],"f":[["func",12],[" ",17],["read",7],["()",17]],"s":[["func",12],[" ",17],["read",7],["()",17]],"d":"Send a `read` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\nWhen the `read` event reaches the `HeadChannelHandler` the interest to read data will be signalled to the\n`Selector`. This will subsequently -- when data becomes readable -- cause `channelRead` events containing the\ndata being sent through the `ChannelPipeline`."},{"p":["ChannelHandlerContext","close(mode:promise:)"],"f":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18,57],[" = .all, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Send a `close` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\nWhen the `close` event reaches the `HeadChannelHandler` the socket will be closed.\n\n- parameters:\n    - mode: The `CloseMode` to use.\n    - promise: The promise fulfilled when the `Channel` has been closed or failed if it the closing failed."},{"p":["ChannelHandlerContext","flush()"],"f":[["func",12],[" ",17],["flush",7],["()",17]],"s":[["func",12],[" ",17],["flush",7],["()",17]],"d":"Send a `flush` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\nWhen the `flush` event reaches the `HeadChannelHandler` the data previously enqueued will be attempted to be\nwritten to the socket.\n\n- parameters:\n    - promise: The promise fulfilled when the previously written data been flushed or failed if it cannot be flushed."},{"p":["ChannelHandlerContext","write(_:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Send a `write` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\nWhen the `write` event reaches the `HeadChannelHandler` the data will be enqueued to be written on the next\n`flush` event.\n\n- parameters:\n    - data: The data to write, should be of type `ChannelOutboundHandler.OutboundOut`.\n    - promise: The promise fulfilled when the data has been written or failed if it cannot be written."},{"p":["ChannelHandlerContext","connect(to:promise:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Send a `connect` event to the next outbound `ChannelHandler` in the `ChannelPipeline`.\nWhen the `connect` event reaches the `HeadChannelHandler` a `SocketChannel` will be connected.\n\n- parameters:\n    - address: The address to connect to.\n    - promise: The promise fulfilled when the socket is connected or failed if it cannot be connected."},{"p":["ChannelHandlerContext","register(promise:)"],"f":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Send a `register` event to the next (outbound) `ChannelHandler` in the `ChannelPipeline`.\n\n- note: For correct operation it is very important to forward any `register` event using this method at the right point in time, that is usually when received."},{"p":["ChannelInboundHandler","wrapInboundOut(_:)"],"f":[["func",12],[" ",17],["wrapInboundOut",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Self",18],[".",17],["InboundOut",18],[") -> ",17],["NIOAny",18,115]],"s":[["func",12],[" ",17],["wrapInboundOut",7],["(",17],["Self",18],[".",17],["InboundOut",18],[") -> ",17],["NIOAny",18]],"d":"Wrap the provided `InboundOut` that will be passed to the next `ChannelInboundHandler` by calling `ChannelHandlerContext.fireChannelRead`."},{"p":["ChannelInboundHandler","unwrapInboundIn(_:)"],"f":[["func",12],[" ",17],["unwrapInboundIn",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["NIOAny",18,115],[") -> ",17],["Self",18],[".",17],["InboundIn",18]],"s":[["func",12],[" ",17],["unwrapInboundIn",7],["(",17],["NIOAny",18],[") -> ",17],["Self",18],[".",17],["InboundIn",18]],"d":"Unwrap the provided `NIOAny` that was passed to `channelRead`."},{"p":["ChannelInboundHandler","wrapInboundOut(_:)"],"f":[["func",12],[" ",17],["wrapInboundOut",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Self",18],[".",17],["InboundOut",18],[") -> ",17],["NIOAny",18,115]],"s":[["func",12],[" ",17],["wrapInboundOut",7],["(",17],["Self",18],[".",17],["InboundOut",18],[") -> ",17],["NIOAny",18]]},{"p":["ChannelInboundHandler","unwrapInboundIn(_:)"],"f":[["func",12],[" ",17],["unwrapInboundIn",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["NIOAny",18,115],[") -> ",17],["Self",18],[".",17],["InboundIn",18]],"s":[["func",12],[" ",17],["unwrapInboundIn",7],["(",17],["NIOAny",18],[") -> ",17],["Self",18],[".",17],["InboundIn",18]]},{"p":["ChannelInboundInvoker","fireChannelRegistered()"],"f":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelRegistered",7],["()",17]],"d":"Called once a `Channel` was registered to its `EventLoop` and so IO will be processed."},{"p":["ChannelInboundInvoker","fireChannelReadComplete()"],"f":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelReadComplete",7],["()",17]],"d":"Called once there is no more data to read immediately on a `Channel`. Any new data received will be handled later."},{"p":["ChannelInboundInvoker","fireChannelUnregistered()"],"f":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelUnregistered",7],["()",17]],"d":"Called once a `Channel` was unregistered from its `EventLoop` which means no IO will be handled for a `Channel` anymore."},{"p":["ChannelInboundInvoker","fireChannelWritabilityChanged()"],"f":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelWritabilityChanged",7],["()",17]],"d":"Called when a `Channel`'s writable state changes.\n\nThe writability state of a Channel depends on watermarks that can be set via `Channel.setOption` and how much data\nis still waiting to be transferred to the remote peer.\nYou should take care to enforce some kind of backpressure if the channel becomes unwritable which means `Channel.isWritable`\nwill return `false` to ensure you do not consume too much memory due to queued writes. What exactly you should do here depends on the\nprotocol and other semantics. But for example you may want to stop writing to the `Channel` until `Channel.writable` becomes\n`true` again or stop reading at all."},{"p":["ChannelInboundInvoker","fireChannelRead(_:)"],"f":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[")",17]],"s":[["func",12],[" ",17],["fireChannelRead",7],["(",17],["NIOAny",18],[")",17]],"d":"Called once there is some data read for a `Channel` that needs processing.\n\n- parameters:\n    - data: the data that was read and is ready to be processed."},{"p":["ChannelInboundInvoker","fireChannelActive()"],"f":[["func",12],[" ",17],["fireChannelActive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelActive",7],["()",17]],"d":"Called once a `Channel` becomes active.\n\nWhat active means depends on the `Channel` implementation and semantics.\nFor example for TCP it means the `Channel` is connected to the remote peer."},{"p":["ChannelInboundInvoker","fireChannelInactive()"],"f":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]],"s":[["func",12],[" ",17],["fireChannelInactive",7],["()",17]],"d":"Called once a `Channel` becomes inactive.\n\nWhat inactive means depends on the `Channel` implementation and semantics.\nFor example for TCP it means the `Channel` was disconnected from the remote peer and closed."},{"p":["ChannelInboundInvoker","fireUserInboundEventTriggered(_:)"],"f":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[")",17]],"s":[["func",12],[" ",17],["fireUserInboundEventTriggered",7],["(",17],["Any",12],[")",17]],"d":"Trigger a custom user inbound event which will flow through the `ChannelPipeline`.\n\n- parameters:\n    - event: the event itself."},{"p":["ChannelInboundInvoker","fireErrorCaught(_:)"],"f":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["_",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["fireErrorCaught",7],["(",17],["Error",18],[")",17]],"d":"Called when an inbound operation `Error` was caught.\n\nBe aware that for inbound operations this method is called while for outbound operations defined in `ChannelOutboundInvoker`\nthe `EventLoopFuture` or `EventLoopPromise` will be notified.\n\n- parameters:\n    - error: the error we encountered."},{"p":["NIOClientTCPBootstrap","channelOption(_:value:)"],"f":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["NIOClientTCPBootstrap",18,107],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["NIOClientTCPBootstrap",18]],"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,0]],"d":"Specifies a `ChannelOption` to be applied to the `SocketChannel`.\n\n- parameters:\n    - option: The option to be applied.\n    - value: The value for the option."},{"p":["NIOClientTCPBootstrap","connectTimeout(_:)"],"f":[["func",12],[" ",17],["connectTimeout",7],["(",17],["_",1],[" ",17],["timeout",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["NIOClientTCPBootstrap",18,107]],"s":[["func",12],[" ",17],["connectTimeout",7],["(",17],["TimeAmount",18],[") -> ",17],["NIOClientTCPBootstrap",18]],"d":"- parameters:\n    - timeout: The timeout that will apply to the connection attempt."},{"p":["NIOClientTCPBootstrap","channelInitializer(_:)"],"f":[["func",12],[" ",17],["channelInitializer",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["@escaping",12],[" (",17],["Channel",18,27],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">) -> ",17],["NIOClientTCPBootstrap",18,107]],"s":[["func",12],[" ",17],["channelInitializer",7],["((",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["NIOClientTCPBootstrap",18]],"d":"Initialize the connected `SocketChannel` with `initializer`. The most common task in initializer is to add\n`ChannelHandler`s to the `ChannelPipeline`.\n\nThe connected `Channel` will operate on `ByteBuffer` as inbound and `IOData` as outbound messages.\n\n- warning: The `handler` closure may be invoked _multiple times_ so it's usually the right choice to instantiate\n           `ChannelHandler`s within `handler`. The reason `handler` may be invoked multiple times is that to\n           successfully set up a connection multiple connections might be setup in the process. Assuming a\n           hostname that resolves to both IPv4 and IPv6 addresses, NIO will follow\n           [_Happy Eyeballs_](https://en.wikipedia.org/wiki/Happy_Eyeballs) and race both an IPv4 and an IPv6\n           connection. It is possible that both connections get fully established before the IPv4 connection\n           will be closed again because the IPv6 connection 'won the race'. Therefore the `channelInitializer`\n           might be called multiple times and it's important not to share stateful `ChannelHandler`s in more\n           than one `Channel`.\n\n- parameters:\n    - handler: A closure that initializes the provided `Channel`."},{"p":["NIOClientTCPBootstrap","channelConvenienceOptions(_:)"],"f":[["func",12],[" ",17],["channelConvenienceOptions",7],["(",17],["_",1],[" ",17],["options",2],[": ",17],["ChannelOptions",18,75],[".",17],["TCPConvenienceOptions",18,76],[") -> ",17],["NIOClientTCPBootstrap",18,107]],"s":[["func",12],[" ",17],["channelConvenienceOptions",7],["(",17],["ChannelOptions",18],[".",17],["TCPConvenienceOptions",18],[") -> ",17],["NIOClientTCPBootstrap",18]],"d":"Specifies some `TCPConvenienceOption`s to be applied to the channel.\nThese are preferred over regular channel options as they are easier to use and restrict\noptions to those which a normal user would consider.\n- Parameter options: Set of convenience options to apply.\n- Returns: The updated bootstrap (`self` being mutated)"},{"p":["NIOClientTCPBootstrap","connect(unixDomainSocketPath:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,1165],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Channel",18,27],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `unixDomainSocket` path to connect to for the UDS `Channel` that will be established.\n\n- parameters:\n    - unixDomainSocketPath: The _Unix domain socket_ path to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected."},{"p":["NIOClientTCPBootstrap","connect(to:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Channel",18,27],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `address` to connect to for the TCP `Channel` that will be established.\n\n- parameters:\n    - address: The address to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected."},{"p":["NIOClientTCPBootstrap","connect(host:port:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["host",1],[": ",17],["String",18,1165],[", ",17],["port",1],[": ",17],["Int",18,1227],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Channel",18,27],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `host` and `port` to connect to for the TCP `Channel` that will be established.\n\n- parameters:\n    - host: The host to connect to.\n    - port: The port to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected."},{"p":["NIOClientTCPBootstrap","enableTLS()"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["enableTLS",7],["() -> ",17],["NIOClientTCPBootstrap",18,107]],"s":[["func",12],[" ",17],["enableTLS",7],["() -> ",17],["NIOClientTCPBootstrap",18]]},{"p":["ChannelOutboundHandler","unwrapOutboundIn(_:)"],"f":[["func",12],[" ",17],["unwrapOutboundIn",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["NIOAny",18,115],[") -> ",17],["Self",18],[".",17],["OutboundIn",18]],"s":[["func",12],[" ",17],["unwrapOutboundIn",7],["(",17],["NIOAny",18],[") -> ",17],["Self",18],[".",17],["OutboundIn",18]],"d":"Unwrap the provided `NIOAny` that was passed to `write`."},{"p":["ChannelOutboundHandler","unwrapOutboundIn(_:)"],"f":[["func",12],[" ",17],["unwrapOutboundIn",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["NIOAny",18,115],[") -> ",17],["Self",18],[".",17],["OutboundIn",18]],"s":[["func",12],[" ",17],["unwrapOutboundIn",7],["(",17],["NIOAny",18],[") -> ",17],["Self",18],[".",17],["OutboundIn",18]]},{"p":["ChannelOutboundInvoker","triggerUserOutboundEvent(_:promise:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Trigger a custom user outbound event which will flow through the `ChannelPipeline`.\n\n- parameters:\n    - promise: the `EventLoopPromise` that will be notified once the operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["ChannelOutboundInvoker","writeAndFlush(_:promise:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Shortcut for calling `write` and `flush`.\n\n- parameters:\n    - data: the data to write\n    - promise: the `EventLoopPromise` that will be notified once the `write` operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["ChannelOutboundInvoker","bind(to:promise:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Bind to a `SocketAddress`.\n- parameters:\n    - to: the `SocketAddress` to which we should bind the `Channel`.\n    - promise: the `EventLoopPromise` that will be notified once the operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["ChannelOutboundInvoker","read()"],"f":[["func",12],[" ",17],["read",7],["()",17]],"s":[["func",12],[" ",17],["read",7],["()",17]],"d":"Signal that we want to read from the `Channel` once there is data ready.\n\nIf `ChannelOptions.autoRead` is set for a `Channel` (which is the default) this method is automatically invoked by the transport implementation,\notherwise it's the user's responsibility to call this method manually once new data should be read and processed.\n"},{"p":["ChannelOutboundInvoker","close(mode:promise:)"],"f":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18,57],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Close the `Channel` and so the connection if one exists.\n\n- parameters:\n    - mode: the `CloseMode` that is used\n    - promise: the `EventLoopPromise` that will be notified once the operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["ChannelOutboundInvoker","flush()"],"f":[["func",12],[" ",17],["flush",7],["()",17]],"s":[["func",12],[" ",17],["flush",7],["()",17]],"d":"Flush data that was previously written via `write` to the remote peer."},{"p":["ChannelOutboundInvoker","write(_:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Write data to the remote peer.\n\nBe aware that to be sure that data is really written to the remote peer you need to call `flush` or use `writeAndFlush`.\nCalling `write` multiple times and then `flush` may allow the `Channel` to `write` multiple data objects to the remote peer with one syscall.\n\n- parameters:\n    - data: the data to write\n    - promise: the `EventLoopPromise` that will be notified once the operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["ChannelOutboundInvoker","connect(to:promise:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Connect to a `SocketAddress`.\n- parameters:\n    - to: the `SocketAddress` to which we should connect the `Channel`.\n    - promise: the `EventLoopPromise` that will be notified once the operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["ChannelOutboundInvoker","register(promise:)"],"f":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"d":"Register on an `EventLoop` and so have all its IO handled.\n\n- parameters:\n    - promise: the `EventLoopPromise` that will be notified once the operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["ChannelOutboundInvoker","triggerUserOutboundEvent(_:file:line:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["Any",12],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Trigger a custom user outbound event which will flow through the `ChannelPipeline`.\n\n- parameters:\n    - event: the event itself.\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","triggerUserOutboundEvent(_:file:line:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["Any",12],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Trigger a custom user outbound event which will flow through the `ChannelPipeline`.\n\n- parameters:\n    - event: the event itself.\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","writeAndFlush(_:file:line:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["NIOAny",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Shortcut for calling `write` and `flush`.\n\n- parameters:\n    - data: the data to write\n- returns: the future which will be notified once the `write` operation completes."},{"p":["ChannelOutboundInvoker","writeAndFlush(_:file:line:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["NIOAny",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Shortcut for calling `write` and `flush`.\n\n- parameters:\n    - data: the data to write\n- returns: the future which will be notified once the `write` operation completes."},{"p":["ChannelOutboundInvoker","bind(to:file:line:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Bind to a `SocketAddress`.\n- parameters:\n    - to: the `SocketAddress` to which we should bind the `Channel`.\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","bind(to:file:line:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Bind to a `SocketAddress`.\n- parameters:\n    - to: the `SocketAddress` to which we should bind the `Channel`.\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","close(mode:file:line:)"],"f":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18,57],[" = .all, ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Close the `Channel` and so the connection if one exists.\n\n- parameters:\n    - mode: the `CloseMode` that is used\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","close(mode:file:line:)"],"f":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18,57],[" = .all, ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Close the `Channel` and so the connection if one exists.\n\n- parameters:\n    - mode: the `CloseMode` that is used\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","write(_:file:line:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["NIOAny",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Write data to the remote peer.\n\nBe aware that to be sure that data is really written to the remote peer you need to call `flush` or use `writeAndFlush`.\nCalling `write` multiple times and then `flush` may allow the `Channel` to `write` multiple data objects to the remote peer with one syscall.\n\n- parameters:\n    - data: the data to write\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","connect(to:file:line:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Connect to a `SocketAddress`.\n- parameters:\n    - to: the `SocketAddress` to which we should connect the `Channel`.\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","connect(to:file:line:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Connect to a `SocketAddress`.\n- parameters:\n    - to: the `SocketAddress` to which we should connect the `Channel`.\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","register(file:line:)"],"f":[["func",12],[" ",17],["register",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["register",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Register on an `EventLoop` and so have all its IO handled.\n\n- returns: the future which will be notified once the operation completes."},{"p":["ChannelOutboundInvoker","register(file:line:)"],"f":[["func",12],[" ",17],["register",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["register",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"d":"Register on an `EventLoop` and so have all its IO handled.\n\n- returns: the future which will be notified once the operation completes."},{"p":["NIOCloseOnErrorHandler","errorCaught(context:error:)"],"f":[["func",12],[" ",17],["errorCaught",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["error",1],[": ",17],["Error",18,1380],[")",17]],"s":[["func",12],[" ",17],["errorCaught",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["error",1],[": ",17],["Error",18],[")",17]]},{"p":["RecvByteBufferAllocator","buffer(allocator:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,103],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[") -> ",17],["ByteBuffer",18]],"d":"Allocates a new `ByteBuffer` that will be used to read bytes from a `Channel`."},{"p":["RecvByteBufferAllocator","record(actualReadBytes:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["record",7],["(",17],["actualReadBytes",1],[": ",17],["Int",18,1227],[") -> ",17],["Bool",18,1224]],"s":[["func",12],[" ",17],["record",7],["(",17],["actualReadBytes",1],[": ",17],["Int",18],[") -> ",17],["Bool",18]],"d":"Records the actual number of bytes that were read by the last socket call.\n\n- parameters:\n    - actualReadBytes: The number of bytes that were used by the previous allocated `ByteBuffer`\n- returns: `true` if the next call to `buffer` may return a bigger buffer then the last call to `buffer`."},{"p":["RemovableChannelHandler","removeHandler(context:removalToken:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18,128],[".",17],["RemovalToken",18,106],[")",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18],[".",17],["RemovalToken",18],[")",17]],"d":"Ask the receiving `RemovableChannelHandler` to remove itself from the `ChannelPipeline` as soon as possible.\nThe receiving `RemovableChannelHandler` may elect to remove itself sometime after this method call, rather than\nimmediately, but if it does so it must take the necessary precautions to handle events arriving between the\ninvocation of this method and the call to `ChannelHandlerContext.removeHandler` that triggers the actual\nremoval.\n\n- note: Like the other `ChannelHandler` methods, this method should not be invoked by the user directly. To\n        remove a `RemovableChannelHandler` from the `ChannelPipeline`, use `ChannelPipeline.remove`.\n\n- parameters:\n   - context: The `ChannelHandlerContext` of the `RemovableChannelHandler` to be removed from the `ChannelPipeline`.\n   - removalToken: The removal token to hand to `ChannelHandlerContext.removeHandler` to trigger the actual\n                   removal from the `ChannelPipeline`."},{"p":["RemovableChannelHandler","removeHandler(context:removalToken:)"],"f":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18,128],[".",17],["RemovalToken",18,106],[")",17]],"s":[["func",12],[" ",17],["removeHandler",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["removalToken",1],[": ",17],["ChannelHandlerContext",18],[".",17],["RemovalToken",18],[")",17]]},{"p":["NIOSynchronousChannelOptions","getOption(_:)"],"f":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[") ",17],["throws",12],[" -> ",17],["Option",18],[".",17],["Value",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["Option",18],[") ",17],["throws",12],[" -> ",17],["Option",18],[".",17],["Value",18]],"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,1]],"d":"Get the value of `option` for this `Channel`.\n\n- Important: Must be called on the `EventLoop` the `Channel` is running on."},{"p":["NIOSynchronousChannelOptions","setOption(_:value:)"],"f":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") ",17],["throws",12],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") ",17],["throws",12]],"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,1]],"d":"Set `option` to `value` on this `Channel`.\n\n- Important: Must be called on the `EventLoop` the `Channel` is running on."},{"p":["NIOClientTCPBootstrapProtocol","channelOption(_:value:)"],"f":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["channelOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["Self",18]],"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,1]],"d":"Specifies a `ChannelOption` to be applied to the `SocketChannel`.\n\n- parameters:\n    - option: The option to be applied.\n    - value: The value for the option."},{"p":["NIOClientTCPBootstrapProtocol","connectTimeout(_:)"],"f":[["func",12],[" ",17],["connectTimeout",7],["(",17],["_",1],[" ",17],["timeout",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["Self",18]],"s":[["func",12],[" ",17],["connectTimeout",7],["(",17],["TimeAmount",18],[") -> ",17],["Self",18]],"d":"- parameters:\n    - timeout: The timeout that will apply to the connection attempt."},{"p":["NIOClientTCPBootstrapProtocol","protocolHandlers(_:)"],"f":[["func",12],[" ",17],["protocolHandlers",7],["(",17],["_",1],[" ",17],["handlers",2],[": ",17],["@escaping",12],[" () -> [",17],["ChannelHandler",18,8],["]) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["protocolHandlers",7],["(() -> [",17],["ChannelHandler",18],["]) -> ",17],["Self",18]],"d":"Sets the protocol handlers that will be added to the front of the `ChannelPipeline` right after the\n`channelInitializer` has been called.\n\nPer bootstrap, you can only set the `protocolHandlers` once. Typically, `protocolHandlers` are used for the TLS\nimplementation. Most notably, `NIOClientTCPBootstrap`, NIO's \"universal bootstrap\" abstraction, uses\n`protocolHandlers` to add the required `ChannelHandler`s for many TLS implementations."},{"p":["NIOClientTCPBootstrapProtocol","channelInitializer(_:)"],"f":[["func",12],[" ",17],["channelInitializer",7],["(",17],["_",1],[" ",17],["handler",2],[": ",17],["@escaping",12],[" (",17],["Channel",18,27],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">) -> ",17],["Self",18]],"s":[["func",12],[" ",17],["channelInitializer",7],["((",17],["Channel",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["Self",18]],"d":"Initialize the connected `SocketChannel` with `initializer`. The most common task in initializer is to add\n`ChannelHandler`s to the `ChannelPipeline`.\n\nThe connected `Channel` will operate on `ByteBuffer` as inbound and `IOData` as outbound messages.\n\n- warning: The `handler` closure may be invoked _multiple times_ so it's usually the right choice to instantiate\n           `ChannelHandler`s within `handler`. The reason `handler` may be invoked multiple times is that to\n           successfully set up a connection multiple connections might be setup in the process. Assuming a\n           hostname that resolves to both IPv4 and IPv6 addresses, NIO will follow\n           [_Happy Eyeballs_](https://en.wikipedia.org/wiki/Happy_Eyeballs) and race both an IPv4 and an IPv6\n           connection. It is possible that both connections get fully established before the IPv4 connection\n           will be closed again because the IPv6 connection 'won the race'. Therefore the `channelInitializer`\n           might be called multiple times and it's important not to share stateful `ChannelHandler`s in more\n           than one `Channel`.\n\n- parameters:\n    - handler: A closure that initializes the provided `Channel`."},{"p":["NIOClientTCPBootstrapProtocol","connect(unixDomainSocketPath:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18,1165],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Channel",18,27],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["unixDomainSocketPath",1],[": ",17],["String",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `unixDomainSocket` path to connect to for the UDS `Channel` that will be established.\n\n- parameters:\n    - unixDomainSocketPath: The _Unix domain socket_ path to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected."},{"p":["NIOClientTCPBootstrapProtocol","connect(to:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Channel",18,27],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `address` to connect to for the TCP `Channel` that will be established.\n\n- parameters:\n    - address: The address to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected."},{"p":["NIOClientTCPBootstrapProtocol","connect(host:port:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["host",1],[": ",17],["String",18,1165],[", ",17],["port",1],[": ",17],["Int",18,1227],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Channel",18,27],[">",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["host",1],[": ",17],["String",18],[", ",17],["port",1],[": ",17],["Int",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Channel",18],[">",17]],"d":"Specify the `host` and `port` to connect to for the TCP `Channel` that will be established.\n\n- parameters:\n    - host: The host to connect to.\n    - port: The port to connect to.\n- returns: An `EventLoopFuture<Channel>` to deliver the `Channel` when connected."},{"p":["AdaptiveRecvByteBufferAllocator","buffer(allocator:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,103],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[") -> ",17],["ByteBuffer",18]]},{"p":["AdaptiveRecvByteBufferAllocator","record(actualReadBytes:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["record",7],["(",17],["actualReadBytes",1],[": ",17],["Int",18,1227],[") -> ",17],["Bool",18,1224]],"s":[["func",12],[" ",17],["record",7],["(",17],["actualReadBytes",1],[": ",17],["Int",18],[") -> ",17],["Bool",18]]},{"p":["FixedSizeRecvByteBufferAllocator","buffer(allocator:)"],"f":[["func",12],[" ",17],["buffer",7],["(",17],["allocator",1],[": ",17],["ByteBufferAllocator",18,103],[") -> ",17],["ByteBuffer",18,58]],"s":[["func",12],[" ",17],["buffer",7],["(",17],["allocator",1],[": ",17],["ByteBufferAllocator",18],[") -> ",17],["ByteBuffer",18]]},{"p":["FixedSizeRecvByteBufferAllocator","record(actualReadBytes:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["record",7],["(",17],["actualReadBytes",1],[": ",17],["Int",18,1227],[") -> ",17],["Bool",18,1224]],"s":[["func",12],[" ",17],["record",7],["(",17],["actualReadBytes",1],[": ",17],["Int",18],[") -> ",17],["Bool",18]]},{"p":["NIOSingleStepByteToMessageDecoder","decodeLast(buffer:seenEOF:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decodeLast",7],["(",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[", ",17],["seenEOF",1],[": ",17],["Bool",18,1224],[") ",17],["throws",12],[" -> ",17],["Self",18],[".",17],["InboundOut",18],["?",17]],"s":[["func",12],[" ",17],["decodeLast",7],["(",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[", ",17],["seenEOF",1],[": ",17],["Bool",18],[") ",17],["throws",12],[" -> ",17],["Self",18],[".",17],["InboundOut",18],["?",17]],"d":"Decode from a `ByteBuffer` when no more data is incoming.\n\nLike with `decode`, this method will be called in a loop until either `nil` is returned from the method or until the input `ByteBuffer`\nhas no more readable bytes. If non-`nil` is returned and the `ByteBuffer` contains more readable bytes, this method will immediately\nbe invoked again.\n\nOnce `nil` is returned, neither `decode` nor `decodeLast` will be called again. If there are no bytes left, `decodeLast` will be called\nonce with an empty buffer.\n\n- parameters:\n    - buffer: The `ByteBuffer` from which we decode.\n    - seenEOF: `true` if EOF has been seen.\n- returns: A message if one can be decoded or `nil` if no more messages can be produced."},{"p":["NIOSingleStepByteToMessageDecoder","decode(buffer:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decode",7],["(",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["throws",12],[" -> ",17],["Self",18],[".",17],["InboundOut",18],["?",17]],"s":[["func",12],[" ",17],["decode",7],["(",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["throws",12],[" -> ",17],["Self",18],[".",17],["InboundOut",18],["?",17]],"d":"Decode from a `ByteBuffer`.\n\nThis method will be called in a loop until either the input `ByteBuffer` has nothing to read left or `nil` is returned. If non-`nil` is\nreturned and the `ByteBuffer` contains more readable bytes, this method will immediately be invoked again, unless `decodeLast` needs\nto be invoked instead.\n\n- parameters:\n    - buffer: The `ByteBuffer` from which we decode.\n- returns: A message if one can be decoded or `nil` if it should be called again once more data is present in the `ByteBuffer`."},{"p":["NIOSingleStepByteToMessageDecoder","decodeLast(context:buffer:seenEOF:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[", ",17],["seenEOF",1],[": ",17],["Bool",18,1224],[") ",17],["throws",12],[" -> ",17],["DecodingState",18,42]],"s":[["func",12],[" ",17],["decodeLast",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[", ",17],["seenEOF",1],[": ",17],["Bool",18],[") ",17],["throws",12],[" -> ",17],["DecodingState",18]]},{"p":["NIOSingleStepByteToMessageDecoder","decode(context:buffer:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["decode",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18,128],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") ",17],["throws",12],[" -> ",17],["DecodingState",18,42]],"s":[["func",12],[" ",17],["decode",7],["(",17],["context",1],[": ",17],["ChannelHandlerContext",18],[", ",17],["buffer",1],[": ",17],["inout",12],[" ",17],["ByteBuffer",18],[") ",17],["throws",12],[" -> ",17],["DecodingState",18]]},{"p":["WriteObservingByteToMessageDecoder","write(data:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["write",7],["(",17],["data",1],[": ",17],["Self",18],[".",17],["OutboundIn",18],[")",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["data",1],[": ",17],["Self",18],[".",17],["OutboundIn",18],[")",17]],"d":"`write` is called for every incoming `write` incoming to the corresponding `ByteToMessageHandler`.\n\n- parameters:\n   - data: The data that was written."},{"p":["NIOSingleStepByteToMessageProcessor","finishProcessing(seenEOF:_:)"],"f":[["func",12],[" ",17],["finishProcessing",7],["(",17],["seenEOF",1],[": ",17],["Bool",18,1224],[", ",17],["_",1],[" ",17],["messageReceiver",2],[": (",17],["Decoder",18],[".",17],["InboundOut",18],[") ",17],["throws",12],[" -> ",17],["Void",18,1379],[") ",17],["throws",12]],"s":[["func",12],[" ",17],["finishProcessing",7],["(",17],["seenEOF",1],[": ",17],["Bool",18],[", (",17],["Decoder",18],[".",17],["InboundOut",18],[") ",17],["throws",12],[" -> ",17],["Void",18],[") ",17],["throws",12]],"e":[["Decoder",1,"NIOSingleStepByteToMessageDecoder",25]],"c":[["Decoder",1,"NIOSingleStepByteToMessageDecoder",25]],"g":[["Decoder",0,0]],"d":"Call when there is no data left in the stream. Calls `Decoder`.`decodeLast` one or more times. If there is no data left\n`decodeLast` will be called one time with an empty `ByteBuffer`.\n\n- parameters:\n    - seenEOF: Whether an EOF was seen on the stream.\n    - messageReceiver: A closure called for each message produced by the `Decoder`."},{"p":["NIOSingleStepByteToMessageProcessor","process(buffer:_:)"],"f":[["func",12],[" ",17],["process",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[", ",17],["_",1],[" ",17],["messageReceiver",2],[": (",17],["Decoder",18],[".",17],["InboundOut",18],[") ",17],["throws",12],[" -> ",17],["Void",18,1379],[") ",17],["throws",12]],"s":[["func",12],[" ",17],["process",7],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[", (",17],["Decoder",18],[".",17],["InboundOut",18],[") ",17],["throws",12],[" -> ",17],["Void",18],[") ",17],["throws",12]],"e":[["Decoder",1,"NIOSingleStepByteToMessageDecoder",25]],"c":[["Decoder",1,"NIOSingleStepByteToMessageDecoder",25]],"g":[["Decoder",0,0]],"d":"Feed data into the `NIOSingleStepByteToMessageProcessor`\n\n- parameters:\n    - buffer: The `ByteBuffer` containing the next data in the stream\n    - messageReceiver: A closure called for each message produced by the `Decoder`"},{"p":["IOData","moveReaderIndex(forwardBy:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["moveReaderIndex",7],["(",17],["forwardBy",1],[": ",17],["Int",18,1227],[")",17]],"s":[["func",12],[" ",17],["moveReaderIndex",7],["(",17],["forwardBy",1],[": ",17],["Int",18],[")",17]],"d":"Move the readerIndex forward by `offset`."},{"p":["Channel","getOption(_:)"],"f":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Option",18],[".",17],["Value",18],["> ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["Option",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Option",18],[".",17],["Value",18],[">",17]],"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,1]],"d":"Get the value of `option` for this `Channel`."},{"p":["Channel","setOption(_:value:)"],"f":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],["> ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,1]],"d":"Set `option` to `value` on this `Channel`."},{"p":["Channel","writeAndFlush(_:promise:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","writeAndFlush(_:promise:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["any",2],[": ",17],["T",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["<",17],["T",0],[">(",17],["T",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"g":[["T",0,1]],"d":"Write and flush data into the `Channel`, automatically wrapping with `NIOAny`.\n\n- seealso: `ChannelOutboundInvoker.writeAndFlush`."},{"p":["Channel","writeAndFlush(_:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["any",2],[": ",17],["T",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["writeAndFlush",7],["<",17],["T",0],[">(",17],["T",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"g":[["T",0,1]],"d":"Write and flush data into the `Channel`, automatically wrapping with `NIOAny`.\n\n- seealso: `ChannelOutboundInvoker.writeAndFlush`."},{"p":["Channel","writeAndFlush(_:)"],"f":[["func",12],[" ",17],["writeAndFlush",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["any",2],[": ",17],["T",18],[") ",17],["async",12],[" ",17],["throws",12]],"s":[["func",12],[" ",17],["writeAndFlush",7],["<",17],["T",0],[">(",17],["T",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"g":[["T",0,1]],"d":"Shortcut for calling `write` and `flush`.\n\n- parameters:\n    - data: the data to write\n    - promise: the `EventLoopPromise` that will be notified once the `write` operation completes,\n               or `nil` if not interested in the outcome of the operation."},{"p":["Channel","triggerUserOutboundEvent(_:promise:)"],"f":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["_",1],[" ",17],["event",2],[": ",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["triggerUserOutboundEvent",7],["(",17],["Any",12],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","registerAlreadyConfigured0(promise:)"],"f":[["func",12],[" ",17],["registerAlreadyConfigured0",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["registerAlreadyConfigured0",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","bind(to:promise:)"],"f":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["bind",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","read()"],"f":[["func",12],[" ",17],["read",7],["()",17]],"s":[["func",12],[" ",17],["read",7],["()",17]]},{"p":["Channel","close(mode:promise:)"],"f":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18,57],[" = .all, ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["close",7],["(",17],["mode",1],[": ",17],["CloseMode",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","flush()"],"f":[["func",12],[" ",17],["flush",7],["()",17]],"s":[["func",12],[" ",17],["flush",7],["()",17]]},{"p":["Channel","write(_:promise:)"],"f":[["func",12],[" ",17],["write",7],["(",17],["_",1],[" ",17],["data",2],[": ",17],["NIOAny",18,115],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["(",17],["NIOAny",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","write(_:promise:)"],"f":[["func",12],[" ",17],["write",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["any",2],[": ",17],["T",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["write",7],["<",17],["T",0],[">(",17],["T",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]],"g":[["T",0,1]],"d":"Write data into the `Channel`, automatically wrapping with `NIOAny`.\n\n- seealso: `ChannelOutboundInvoker.write`."},{"p":["Channel","write(_:)"],"f":[["func",12],[" ",17],["write",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["any",2],[": ",17],["T",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["write",7],["<",17],["T",0],[">(",17],["T",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"g":[["T",0,1]],"d":"Write data into the `Channel`, automatically wrapping with `NIOAny`.\n\n- seealso: `ChannelOutboundInvoker.write`."},{"p":["Channel","connect(to:promise:)"],"f":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[" ",17],["address",2],[": ",17],["SocketAddress",18,43],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["connect",7],["(",17],["to",1],[": ",17],["SocketAddress",18],[", ",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","register(promise:)"],"f":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">?)",17]],"s":[["func",12],[" ",17],["register",7],["(",17],["promise",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?)",17]]},{"p":["Channel","getOption(_:)"],"f":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["Option",18],[".",17],["Value",18],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["getOption",7],["<",17],["Option",0],[">(",17],["Option",18],[") ",17],["async",12],[" ",17],["throws",12],[" -> ",17],["Option",18],[".",17],["Value",18]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,1]],"d":"Get the value of `option` for this `Channel`."},{"p":["Channel","setOption(_:value:)"],"f":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["_",1],[" ",17],["option",2],[": ",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") ",17],["async",12],[" ",17],["throws",12],[" ",17],["where",12],[" ",17],["Option",18],[" : ",17],["ChannelOption",18,7]],"s":[["func",12],[" ",17],["setOption",7],["<",17],["Option",0],[">(",17],["Option",18],[", ",17],["value",1],[": ",17],["Option",18],[".",17],["Value",18],[") ",17],["async",12],[" ",17],["throws",12]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"c":[["Option",1,"ChannelOption",7]],"g":[["Option",0,1]],"d":"Set `option` to `value` on this `Channel`."},{"p":["EventLoop","preconditionInEventLoop(file:line:)"],"f":[["func",12],[" ",17],["preconditionInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[", ",17],["line",1],[": ",17],["UInt",18,1343],[")",17]],"s":[["func",12],[" ",17],["preconditionInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[")",17]],"d":"Asserts that the current thread is the one tied to this `EventLoop`.\nOtherwise, the process will be abnormally terminated as per the semantics of `preconditionFailure(_:file:line:)`."},{"p":["EventLoop","preconditionNotInEventLoop(file:line:)"],"f":[["func",12],[" ",17],["preconditionNotInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[", ",17],["line",1],[": ",17],["UInt",18,1343],[")",17]],"s":[["func",12],[" ",17],["preconditionNotInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[")",17]],"d":"Asserts that the current thread is _not_ the one tied to this `EventLoop`.\nOtherwise, the process will be abnormally terminated as per the semantics of `preconditionFailure(_:file:line:)`."},{"p":["EventLoop","scheduleTask(in:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["in",1],[": ",17],["TimeAmount",18,62],[", ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18,117],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["in",1],[": ",17],["TimeAmount",18],[", () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Schedule a `task` that is executed by this `EventLoop` after the given amount of time.\n\n- parameters:\n    - task: The synchronous task to run. As with everything that runs on the `EventLoop`, it must not block.\n- returns: A `Scheduled` object which may be used to cancel the task if it has not yet run, or to wait\n           on the completion of the task.\n\n- note: You can only cancel a task before it has started executing.\n- note: The `in` value is clamped to a maximum when running on a Darwin-kernel."},{"p":["EventLoop","scheduleTask(deadline:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["deadline",1],[": ",17],["NIODeadline",18,63],[", ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18,117],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["scheduleTask",7],["<",17],["T",0],[">(",17],["deadline",1],[": ",17],["NIODeadline",18],[", () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["Scheduled",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Schedule a `task` that is executed by this `EventLoop` at the given time.\n\n- parameters:\n    - task: The synchronous task to run. As with everything that runs on the `EventLoop`, it must not block.\n- returns: A `Scheduled` object which may be used to cancel the task if it has not yet run, or to wait\n           on the completion of the task.\n\n- note: You can only cancel a task before it has started executing."},{"p":["EventLoop","makeSucceededVoidFuture()"],"f":[["func",12],[" ",17],["makeSucceededVoidFuture",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["makeSucceededVoidFuture",7],["() -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Return a succeeded `Void` future.\n\nSemantically, this function is equivalent to calling `makeSucceededFuture(())`.\nContrary to `makeSucceededFuture`, `makeSucceededVoidFuture` is a customization point for `EventLoop`s which\nallows `EventLoop`s to cache a pre-succeeded `Void` future to prevent superfluous allocations."},{"p":["EventLoop","submit(_:)"],"f":[["func",12],[" ",17],["submit",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["submit",7],["<",17],["T",0],[">(() ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Submit a given task to be executed by the `EventLoop`. Once the execution is complete the returned `EventLoopFuture` is notified.\n\n- parameters:\n    - task: The closure that will be submitted to the `EventLoop` for execution.\n- returns: `EventLoopFuture` that is notified once the task was executed."},{"p":["EventLoop","execute(_:)"],"f":[["func",12],[" ",17],["execute",7],["(",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () -> ",17],["Void",18,1379],[")",17]],"s":[["func",12],[" ",17],["execute",7],["(() -> ",17],["Void",18],[")",17]],"d":"Submit a given task to be executed by the `EventLoop`"},{"p":["EventLoop","assertNotInEventLoop(file:line:)"],"f":[["func",12],[" ",17],["assertNotInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[")",17]],"s":[["func",12],[" ",17],["assertNotInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[")",17]],"d":"Asserts that the current thread is _not_ the one tied to this `EventLoop`.\nOtherwise, if running in debug mode, the process will be abnormally terminated as per the semantics of\n`preconditionFailure(_:file:line:)`. Never has any effect in release mode.\n\n- note: This is not a customization point so calls to this function can be fully optimized out in release mode."},{"p":["EventLoop","preconditionInEventLoop(file:line:)"],"f":[["func",12],[" ",17],["preconditionInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[")",17]],"s":[["func",12],[" ",17],["preconditionInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[")",17]],"d":"Checks the necessary condition of currently running on the called `EventLoop` for making forward progress."},{"p":["EventLoop","preconditionNotInEventLoop(file:line:)"],"f":[["func",12],[" ",17],["preconditionNotInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[")",17]],"s":[["func",12],[" ",17],["preconditionNotInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[")",17]],"d":"Checks the necessary condition of currently _not_ running on the called `EventLoop` for making forward progress."},{"p":["EventLoop","assertInEventLoop(file:line:)"],"f":[["func",12],[" ",17],["assertInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[")",17]],"s":[["func",12],[" ",17],["assertInEventLoop",7],["(",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[")",17]],"d":"Asserts that the current thread is the one tied to this `EventLoop`.\nOtherwise, if running in debug mode, the process will be abnormally terminated as per the semantics of\n`preconditionFailure(_:file:line:)`. Never has any effect in release mode.\n\n- note: This is not a customization point so calls to this function can be fully optimized out in release mode."},{"p":["EventLoop","flatSubmit(_:)"],"f":[["func",12],[" ",17],["flatSubmit",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["flatSubmit",7],["<",17],["T",0],[">(() -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Submit `task` to be run on this `EventLoop`.\n\nThe returned `EventLoopFuture` will be completed when `task` has finished running. It will be identical to\nthe `EventLoopFuture` returned by `task`.\n\n- parameters:\n    - task: The asynchronous task to run. As with everything that runs on the `EventLoop`, it must not block.\n- returns: An `EventLoopFuture` identical to the `EventLoopFuture` returned from `task`."},{"p":["EventLoop","makePromise(of:file:line:)"],"f":[["func",12],[" ",17],["makePromise",7],["<",17],["T",0],[">(",17],["of",1],[" ",17],["type",2],[": ",17],["T",18],[".Type = T.self, ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopPromise",18,96],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["makePromise",7],["<",17],["T",0],[">(",17],["of",1],[": ",17],["T",18],[".Type, ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopPromise",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Creates and returns a new `EventLoopPromise` that will be notified using this `EventLoop` as execution `NIOThread`."},{"p":["EventLoop","makeIterator()"],"f":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["EventLoopIterator",18,101]],"s":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["EventLoopIterator",18]],"d":"Returns an `EventLoopIterator` over this `EventLoop`.\n\n- returns: `EventLoopIterator`"},{"p":["EventLoop","flatScheduleTask(in:file:line:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["flatScheduleTask",7],["<",17],["T",0],[">(",17],["in",1],[" ",17],["delay",2],[": ",17],["TimeAmount",18,62],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">) -> ",17],["Scheduled",18,117],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["flatScheduleTask",7],["<",17],["T",0],[">(",17],["in",1],[": ",17],["TimeAmount",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", () ",17],["throws",12],[" -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">) -> ",17],["Scheduled",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Schedule a `task` that is executed by this `EventLoop` after the given amount of time.\n\n- parameters:\n    - task: The asynchronous task to run. As everything that runs on the `EventLoop`, it must not block.\n- returns: A `Scheduled` object which may be used to cancel the task if it has not yet run, or to wait\n           on the full execution of the task, including its returned `EventLoopFuture`.\n\n- note: You can only cancel a task before it has started executing."},{"p":["EventLoop","flatScheduleTask(deadline:file:line:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["flatScheduleTask",7],["<",17],["T",0],[">(",17],["deadline",1],[": ",17],["NIODeadline",18,63],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[", ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">) -> ",17],["Scheduled",18,117],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["flatScheduleTask",7],["<",17],["T",0],[">(",17],["deadline",1],[": ",17],["NIODeadline",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[", () ",17],["throws",12],[" -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">) -> ",17],["Scheduled",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Schedule a `task` that is executed by this `EventLoop` at the given time.\n\n- parameters:\n    - task: The asynchronous task to run. As with everything that runs on the `EventLoop`, it must not block.\n- returns: A `Scheduled` object which may be used to cancel the task if it has not yet run, or to wait\n           on the full execution of the task, including its returned `EventLoopFuture`.\n\n- note: You can only cancel a task before it has started executing."},{"p":["EventLoop","makeFailedFuture(_:file:line:)"],"f":[["func",12],[" ",17],["makeFailedFuture",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["makeFailedFuture",7],["<",17],["T",0],[">(",17],["Error",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["T",0,1]]},{"p":["EventLoop","makeFailedFuture(_:)"],"f":[["func",12],[" ",17],["makeFailedFuture",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["error",2],[": ",17],["Error",18,1380],[") -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["makeFailedFuture",7],["<",17],["T",0],[">(",17],["Error",18],[") -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Creates and returns a new `EventLoopFuture` that is already marked as failed. Notifications will be done using this `EventLoop` as execution `NIOThread`.\n\n- parameters:\n    - error: the `Error` that is used by the `EventLoopFuture`.\n- returns: a failed `EventLoopFuture`."},{"p":["EventLoop","makeCompletedFuture(_:)"],"f":[["func",12],[" ",17],["makeCompletedFuture",7],["<",17],["Success",0],[">(",17],["_",1],[" ",17],["result",2],[": ",17],["Result",18,1386],["<",17],["Success",18],[", ",17],["Error",18,1380],[">) -> ",17],["EventLoopFuture",18,121],["<",17],["Success",18],[">",17]],"s":[["func",12],[" ",17],["makeCompletedFuture",7],["<",17],["Success",0],[">(",17],["Result",18],["<",17],["Success",18],[", ",17],["Error",18],[">) -> ",17],["EventLoopFuture",18],["<",17],["Success",18],[">",17]],"g":[["Success",0,1]],"d":"Creates and returns a new `EventLoopFuture` that is marked as succeeded or failed with the value held by `result`.\n\n- Parameters:\n  - result: The value that is used by the `EventLoopFuture`\n- Returns: A completed `EventLoopFuture`."},{"p":["EventLoop","makeSucceededFuture(_:file:line:)"],"f":[["func",12],[" ",17],["makeSucceededFuture",7],["<",17],["Success",0],[">(",17],["_",1],[" ",17],["value",2],[": ",17],["Success",18],[", ",17],["file",1],[": ",17],["StaticString",18,1359],[" = ",17],["#file",12],[", ",17],["line",1],[": ",17],["UInt",18,1343],[" = ",17],["#line",12],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Success",18],[">",17]],"s":[["func",12],[" ",17],["makeSucceededFuture",7],["<",17],["Success",0],[">(",17],["Success",18],[", ",17],["file",1],[": ",17],["StaticString",18],[", ",17],["line",1],[": ",17],["UInt",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Success",18],[">",17]],"a":{"a":{"d":true,"m":"Please don't pass file:line:, there's no point."}},"g":[["Success",0,1]]},{"p":["EventLoop","makeSucceededFuture(_:)"],"f":[["func",12],[" ",17],["makeSucceededFuture",7],["<",17],["Success",0],[">(",17],["_",1],[" ",17],["value",2],[": ",17],["Success",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Success",18],[">",17]],"s":[["func",12],[" ",17],["makeSucceededFuture",7],["<",17],["Success",0],[">(",17],["Success",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Success",18],[">",17]],"g":[["Success",0,1]],"d":"Creates and returns a new `EventLoopFuture` that is already marked as success. Notifications will be done using this `EventLoop` as execution `NIOThread`.\n\n- parameters:\n    - result: the value that is used by the `EventLoopFuture`.\n- returns: a succeeded `EventLoopFuture`."},{"p":["EventLoop","scheduleRepeatedTask(initialDelay:delay:notifying:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["scheduleRepeatedTask",7],["(",17],["initialDelay",1],[": ",17],["TimeAmount",18,62],[", ",17],["delay",1],[": ",17],["TimeAmount",18,62],[", ",17],["notifying",1],[" ",17],["promise",2],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">? = nil, ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" (",17],["RepeatedTask",18,118],[") ",17],["throws",12],[" -> ",17],["Void",18,1379],[") -> ",17],["RepeatedTask",18,118]],"s":[["func",12],[" ",17],["scheduleRepeatedTask",7],["(",17],["initialDelay",1],[": ",17],["TimeAmount",18],[", ",17],["delay",1],[": ",17],["TimeAmount",18],[", ",17],["notifying",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?, (",17],["RepeatedTask",18],[") ",17],["throws",12],[" -> ",17],["Void",18],[") -> ",17],["RepeatedTask",18]],"d":"Schedule a repeated task to be executed by the `EventLoop` with a fixed delay between the end and start of each\ntask.\n\n- parameters:\n    - initialDelay: The delay after which the first task is executed.\n    - delay: The delay between the end of one task and the start of the next.\n    - promise: If non-nil, a promise to fulfill when the task is cancelled and all execution is complete.\n    - task: The closure that will be executed.\n- return: `RepeatedTask`"},{"p":["EventLoop","makeSucceededVoidFuture()"],"f":[["func",12],[" ",17],["makeSucceededVoidFuture",7],["() -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">",17]],"s":[["func",12],[" ",17],["makeSucceededVoidFuture",7],["() -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">",17]],"d":"Default implementation of `makeSucceededVoidFuture`: Return a fresh future (which will allocate)."},{"p":["EventLoop","scheduleRepeatedAsyncTask(initialDelay:delay:notifying:_:)"],"f":[["@discardableResult",3],[" ",17],["func",12],[" ",17],["scheduleRepeatedAsyncTask",7],["(",17],["initialDelay",1],[": ",17],["TimeAmount",18,62],[", ",17],["delay",1],[": ",17],["TimeAmount",18,62],[", ",17],["notifying",1],[" ",17],["promise",2],[": ",17],["EventLoopPromise",18,96],["<",17],["Void",18,1379],[">? = nil, ",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" (",17],["RepeatedTask",18,118],[") -> ",17],["EventLoopFuture",18,121],["<",17],["Void",18,1379],[">) -> ",17],["RepeatedTask",18,118]],"s":[["func",12],[" ",17],["scheduleRepeatedAsyncTask",7],["(",17],["initialDelay",1],[": ",17],["TimeAmount",18],[", ",17],["delay",1],[": ",17],["TimeAmount",18],[", ",17],["notifying",1],[": ",17],["EventLoopPromise",18],["<",17],["Void",18],[">?, (",17],["RepeatedTask",18],[") -> ",17],["EventLoopFuture",18],["<",17],["Void",18],[">) -> ",17],["RepeatedTask",18]],"d":"Schedule a repeated asynchronous task to be executed by the `EventLoop` with a fixed delay between the end and\nstart of each task.\n\n- note: The delay is measured from the completion of one run's returned future to the start of the execution of\n        the next run. For example: If you schedule a task once per second but your task takes two seconds to\n        complete, the time interval between two subsequent runs will actually be three seconds (2s run time plus\n        the 1s delay.)\n\n- parameters:\n    - initialDelay: The delay after which the first task is executed.\n    - delay: The delay between the end of one task and the start of the next.\n    - promise: If non-nil, a promise to fulfill when the task is cancelled and all execution is complete.\n    - task: The closure that will be executed. Task will keep repeating regardless of whether the future\n            gets fulfilled with success or error.\n\n- return: `RepeatedTask`"},{"p":["EventLoop","any()"],"f":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18,28]],"s":[["func",12],[" ",17],["any",7],["() -> ",17],["EventLoop",18]],"d":"An `EventLoop` forms a singular `EventLoopGroup`, returning itself as 'any' `EventLoop`.\n\n- returns: Itself, because an `EventLoop` forms a singular `EventLoopGroup`."},{"p":["EventLoop","next()"],"f":[["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18,28]],"s":[["func",12],[" ",17],["next",7],["() -> ",17],["EventLoop",18]],"d":"An `EventLoop` forms a singular `EventLoopGroup`, returning itself as the 'next' `EventLoop`.\n\n- returns: Itself, because an `EventLoop` forms a singular `EventLoopGroup`."},{"p":["EventLoop","close()"],"f":[["func",12],[" ",17],["close",7],["() ",17],["throws",12]],"s":[["func",12],[" ",17],["close",7],["() ",17],["throws",12]],"d":"Close this `EventLoop`."},{"p":["EventLoop","submit(_:)"],"f":[["func",12],[" ",17],["submit",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["task",2],[": ",17],["@escaping",12],[" () ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["EventLoopFuture",18,121],["<",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["submit",7],["<",17],["T",0],[">(() ",17],["throws",12],[" -> ",17],["T",18],[") -> ",17],["EventLoopFuture",18],["<",17],["T",18],[">",17]],"g":[["T",0,1]],"d":"Submit `task` to be run on this `EventLoop`.\n\nThe returned `EventLoopFuture` will be completed when `task` has finished running. It will be succeeded with\n`task`'s return value or failed if the execution of `task` threw an error.\n\n- parameters:\n    - task: The synchronous task to run. As everything that runs on the `EventLoop`, it must not block.\n- returns: An `EventLoopFuture` containing the result of `task`'s execution."},{"p":["Scheduled","cancel()"],"f":[["func",12],[" ",17],["cancel",7],["()",17]],"s":[["func",12],[" ",17],["cancel",7],["()",17]],"g":[["T",0,0]],"d":"Try to cancel the execution of the scheduled task.\n\nWhether this is successful depends on whether the execution of the task already begun.\n This means that cancellation is not guaranteed."},{"p":["ByteBuffer","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["ByteBuffer",18,58],[", ",17],["rhs",2],[": ",17],["ByteBuffer",18,58],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["ByteBuffer",18],[", ",17],["ByteBuffer",18],[") -> ",17],["Bool",18]],"d":"Compare two `ByteBuffer` values. Two `ByteBuffer` values are considered equal if the readable bytes are equal."},{"p":["FileRegion","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["FileRegion",18,61],[", ",17],["rhs",2],[": ",17],["FileRegion",18,61],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["FileRegion",18],[", ",17],["FileRegion",18],[") -> ",17],["Bool",18]]},{"p":["TimeAmount","<(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["<",7],[" ",17],["(",17],["lhs",2],[": ",17],["TimeAmount",18,62],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["<",7],[" ",17],["(",17],["TimeAmount",18],[", ",17],["TimeAmount",18],[") -> ",17],["Bool",18]]},{"p":["TimeAmount","*(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["*",7],[" ",17],["<",17],["T",0],[">(",17],["lhs",2],[": ",17],["TimeAmount",18,62],[", ",17],["rhs",2],[": ",17],["T",18],[") -> ",17],["TimeAmount",18,62],[" ",17],["where",12],[" ",17],["T",18],[" : ",17],["BinaryInteger",18,1346]],"s":[["static",12],[" ",17],["func",12],[" ",17],["*",7],[" ",17],["<",17],["T",0],[">(",17],["TimeAmount",18],[", ",17],["T",18],[") -> ",17],["TimeAmount",18]],"c":[["T",1,"BinaryInteger",1346]],"g":[["T",0,0]]},{"p":["TimeAmount","*(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["*",7],[" ",17],["<",17],["T",0],[">(",17],["lhs",2],[": ",17],["T",18],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["TimeAmount",18,62],[" ",17],["where",12],[" ",17],["T",18],[" : ",17],["BinaryInteger",18,1346]],"s":[["static",12],[" ",17],["func",12],[" ",17],["*",7],[" ",17],["<",17],["T",0],[">(",17],["T",18],[", ",17],["TimeAmount",18],[") -> ",17],["TimeAmount",18]],"c":[["T",1,"BinaryInteger",1346]],"g":[["T",0,0]]},{"p":["TimeAmount","+(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["+",7],[" ",17],["(",17],["lhs",2],[": ",17],["TimeAmount",18,62],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["+",7],[" ",17],["(",17],["TimeAmount",18],[", ",17],["TimeAmount",18],[") -> ",17],["TimeAmount",18]]},{"p":["TimeAmount","-(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["lhs",2],[": ",17],["TimeAmount",18,62],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["TimeAmount",18],[", ",17],["TimeAmount",18],[") -> ",17],["TimeAmount",18]]},{"p":["TimeAmount","+=(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["+=",7],[" ",17],["(",17],["lhs",2],[": ",17],["inout",12],[" ",17],["TimeAmount",18,62],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[")",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["+=",7],[" ",17],["(",17],["inout",12],[" ",17],["TimeAmount",18],[", ",17],["TimeAmount",18],[")",17]]},{"p":["TimeAmount","-=(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["-=",7],[" ",17],["(",17],["lhs",2],[": ",17],["inout",12],[" ",17],["TimeAmount",18,62],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[")",17]],"s":[["static",12],[" ",17],["func",12],[" ",17],["-=",7],[" ",17],["(",17],["inout",12],[" ",17],["TimeAmount",18],[", ",17],["TimeAmount",18],[")",17]]},{"p":["NIODeadline",">(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],[">",7],[" ",17],["(",17],["lhs",2],[": ",17],["NIODeadline",18,63],[", ",17],["rhs",2],[": ",17],["NIODeadline",18,63],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],[">",7],[" ",17],["(",17],["NIODeadline",18],[", ",17],["NIODeadline",18],[") -> ",17],["Bool",18]]},{"p":["NIODeadline","<(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["<",7],[" ",17],["(",17],["lhs",2],[": ",17],["NIODeadline",18,63],[", ",17],["rhs",2],[": ",17],["NIODeadline",18,63],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["<",7],[" ",17],["(",17],["NIODeadline",18],[", ",17],["NIODeadline",18],[") -> ",17],["Bool",18]]},{"p":["NIODeadline","+(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["+",7],[" ",17],["(",17],["lhs",2],[": ",17],["NIODeadline",18,63],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["NIODeadline",18,63]],"s":[["static",12],[" ",17],["func",12],[" ",17],["+",7],[" ",17],["(",17],["NIODeadline",18],[", ",17],["TimeAmount",18],[") -> ",17],["NIODeadline",18]]},{"p":["NIODeadline","-(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["lhs",2],[": ",17],["NIODeadline",18,63],[", ",17],["rhs",2],[": ",17],["TimeAmount",18,62],[") -> ",17],["NIODeadline",18,63]],"s":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["NIODeadline",18],[", ",17],["TimeAmount",18],[") -> ",17],["NIODeadline",18]]},{"p":["NIODeadline","-(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["lhs",2],[": ",17],["NIODeadline",18,63],[", ",17],["rhs",2],[": ",17],["NIODeadline",18,63],[") -> ",17],["TimeAmount",18,62]],"s":[["static",12],[" ",17],["func",12],[" ",17],["-",7],[" ",17],["(",17],["NIODeadline",18],[", ",17],["NIODeadline",18],[") -> ",17],["TimeAmount",18]]},{"p":["SocketAddress","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["SocketAddress",18,43],[", ",17],["rhs",2],[": ",17],["SocketAddress",18,43],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["SocketAddress",18],[", ",17],["SocketAddress",18],[") -> ",17],["Bool",18]]},{"p":["ByteBufferView","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["ByteBufferView",18,74],[", ",17],["rhs",2],[": ",17],["ByteBufferView",18,74],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["ByteBufferView",18],[", ",17],["ByteBufferView",18],[") -> ",17],["Bool",18]],"d":"required by `Equatable`"},{"p":["CircularBuffer","Index","<(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["<",7],[" ",17],["(",17],["lhs",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[", ",17],["rhs",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["<",7],[" ",17],["(",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[", ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Bool",18]],"g":[["Element",0,0]]},{"p":["CircularBuffer","Index","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[", ",17],["rhs",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[", ",17],["CircularBuffer",18],["<",17],["Element",18],[">.",17],["Index",18],[") -> ",17],["Bool",18]],"g":[["Element",0,0]]},{"p":["CircularBuffer","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">, ",17],["rhs",2],[": ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">) -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["CircularBuffer",18],["<",17],["Element",18],[">, ",17],["CircularBuffer",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Equatable",1161]],"c":[["Element",1,"Equatable",1161]],"g":[["Element",0,0]]},{"p":["EventLoopFuture","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">, ",17],["rhs",2],[": ",17],["EventLoopFuture",18,121],["<",17],["Value",18],[">) -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["EventLoopFuture",18],["<",17],["Value",18],[">, ",17],["EventLoopFuture",18],["<",17],["Value",18],[">) -> ",17],["Bool",18]],"g":[["Value",0,0]]},{"p":["NIONetworkDevice","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["NIONetworkDevice",18,98],[", ",17],["rhs",2],[": ",17],["NIONetworkDevice",18,98],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["NIONetworkDevice",18],[", ",17],["NIONetworkDevice",18],[") -> ",17],["Bool",18]]},{"p":["NIONetworkInterface","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["lhs",2],[": ",17],["NIONetworkInterface",18,124],[", ",17],["rhs",2],[": ",17],["NIONetworkInterface",18,124],[") -> ",17],["Bool",18,1224]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["NIONetworkInterface",18],[", ",17],["NIONetworkInterface",18],[") -> ",17],["Bool",18]],"a":{"a":{"d":true,"r":"NIONetworkDevice"}}},{"p":["TimeAmount","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["Int64",18,1382]],"s":[["typealias",12],[" ",17],["Value",7]],"a":{"a":{"d":true,"m":"This typealias doesn't serve any purpose. Please use Int64 directly."}}},{"p":["NIODeadline","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["UInt64",18,1388]],"s":[["typealias",12],[" ",17],["Value",7]],"a":{"a":{"d":true,"m":"This typealias doesn't serve any purpose, please use UInt64 directly."}}},{"p":["NIOSendable"],"f":[["typealias",12],[" ",17],["NIOSendable",7],[" = ",17],["Sendable",18,1389]],"s":[["typealias",12],[" ",17],["NIOSendable",7]]},{"p":["NIOBSDSocket","OptionLevel","RawValue"],"f":[["typealias",12],[" ",17],["RawValue",7],[" = ",17],["CInt",18,1378]],"s":[["typealias",12],[" ",17],["RawValue",7]]},{"p":["NIOBSDSocket","AddressFamily","RawValue"],"f":[["typealias",12],[" ",17],["RawValue",7],[" = ",17],["CInt",18,1378]],"s":[["typealias",12],[" ",17],["RawValue",7]]},{"p":["NIOBSDSocket","ProtocolFamily","RawValue"],"f":[["typealias",12],[" ",17],["RawValue",7],[" = ",17],["CInt",18,1378]],"s":[["typealias",12],[" ",17],["RawValue",7]]},{"p":["NIOBSDSocket","Handle"],"f":[["typealias",12],[" ",17],["Handle",7],[" = ",17],["CInt",18,1378]],"s":[["typealias",12],[" ",17],["Handle",7]]},{"p":["NIOBSDSocket","Option","RawValue"],"f":[["typealias",12],[" ",17],["RawValue",7],[" = ",17],["CInt",18,1378]],"s":[["typealias",12],[" ",17],["RawValue",7]]},{"p":["SocketOption"],"f":[["typealias",12],[" ",17],["SocketOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["SocketOption",18,78]],"s":[["typealias",12],[" ",17],["SocketOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.SocketOption"}}},{"p":["BacklogOption"],"f":[["typealias",12],[" ",17],["BacklogOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["BacklogOption",18,79]],"s":[["typealias",12],[" ",17],["BacklogOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.BacklogOption"}}},{"p":["AutoReadOption"],"f":[["typealias",12],[" ",17],["AutoReadOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["AutoReadOption",18,80]],"s":[["typealias",12],[" ",17],["AutoReadOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.AutoReadOption"}}},{"p":["ByteBufferView","SubSequence"],"f":[["typealias",12],[" ",17],["SubSequence",7],[" = ",17],["ByteBufferView",18,74]],"s":[["typealias",12],[" ",17],["SubSequence",7]]},{"p":["ByteBufferView","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["Int",18,1227]],"s":[["typealias",12],[" ",17],["Index",7]]},{"p":["ByteBufferView","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = ",17],["UInt8",18,1384]],"s":[["typealias",12],[" ",17],["Element",7]]},{"p":["ChannelOptions","Types","SocketOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = (",17],["SocketOptionValue",18,1064],[")",17]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","BacklogOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["Int32",18,1381]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","AutoReadOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["Bool",18,1224]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","AllocatorOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["ByteBufferAllocator",18,103]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","WriteSpinOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["UInt",18,1343]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","ReceivePacketInfo","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["Bool",18,1224]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","RecvAllocatorOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["RecvByteBufferAllocator",18,21]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","ConnectTimeoutOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["TimeAmount",18,62],["?",17]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","MaxMessagesPerReadOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["UInt",18,1343]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","WriteBufferWaterMarkOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["WriteBufferWaterMark",18,86]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","AllowRemoteHalfClosureOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["Bool",18,1224]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","DatagramVectorReadMessageCountOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["Int",18,1227]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["ChannelOptions","Types","ExplicitCongestionNotificationsOption","Value"],"f":[["typealias",12],[" ",17],["Value",7],[" = ",17],["Bool",18,1224]],"s":[["typealias",12],[" ",17],["Value",7]]},{"p":["CircularBuffer","SubSequence"],"f":[["typealias",12],[" ",17],["SubSequence",7],[" = ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">",17]],"s":[["typealias",12],[" ",17],["SubSequence",7]],"g":[["Element",0,0]]},{"p":["CircularBuffer","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = ",17],["Element",18]],"s":[["typealias",12],[" ",17],["Element",7]],"g":[["Element",0,0]]},{"p":["CircularBuffer","Indices"],"f":[["typealias",12],[" ",17],["Indices",7],[" = ",17],["DefaultIndices",18,1114],["<",17],["CircularBuffer",18,93],["<",17],["Element",18],[">>",17]],"s":[["typealias",12],[" ",17],["Indices",7]],"g":[["Element",0,0]]},{"p":["CircularBuffer","RangeType"],"f":[["typealias",12],[" ",17],["RangeType",7],["<",17],["Bound",0],["> = ",17],["Range",18,1338],["<",17],["Bound",18],["> ",17],["where",12],[" ",17],["Bound",18],[" : ",17],["Strideable",18,1345],[", ",17],["Bound",18],[".",17],["Stride",18],[" : ",17],["SignedInteger",18,1222]],"s":[["typealias",12],[" ",17],["RangeType",7]],"c":[["Bound",1,"Strideable",1345],["Bound.Stride",1,"SignedInteger",1222]],"g":[["Element",0,0],["Bound",0,1]]},{"p":["AllocatorOption"],"f":[["typealias",12],[" ",17],["AllocatorOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["AllocatorOption",18,81]],"s":[["typealias",12],[" ",17],["AllocatorOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.AllocatorOption"}}},{"p":["WriteSpinOption"],"f":[["typealias",12],[" ",17],["WriteSpinOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["WriteSpinOption",18,82]],"s":[["typealias",12],[" ",17],["WriteSpinOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.WriteSpinOption"}}},{"p":["IdleStateHandler","InboundOut"],"f":[["typealias",12],[" ",17],["InboundOut",7],[" = ",17],["NIOAny",18,115]],"s":[["typealias",12],[" ",17],["InboundOut",7]]},{"p":["IdleStateHandler","OutboundIn"],"f":[["typealias",12],[" ",17],["OutboundIn",7],[" = ",17],["NIOAny",18,115]],"s":[["typealias",12],[" ",17],["OutboundIn",7]]},{"p":["IdleStateHandler","OutboundOut"],"f":[["typealias",12],[" ",17],["OutboundOut",7],[" = ",17],["NIOAny",18,115]],"s":[["typealias",12],[" ",17],["OutboundOut",7]]},{"p":["IdleStateHandler","InboundIn"],"f":[["typealias",12],[" ",17],["InboundIn",7],[" = ",17],["NIOAny",18,115]],"s":[["typealias",12],[" ",17],["InboundIn",7]]},{"p":["SocketOptionName"],"f":[["typealias",12],[" ",17],["SocketOptionName",7],[" = ",17],["Int32",18,1381]],"s":[["typealias",12],[" ",17],["SocketOptionName",7]]},{"p":["EventLoopIterator","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = ",17],["EventLoop",18,28]],"s":[["typealias",12],[" ",17],["Element",7]]},{"p":["SocketOptionLevel"],"f":[["typealias",12],[" ",17],["SocketOptionLevel",7],[" = ",17],["Int",18,1227]],"s":[["typealias",12],[" ",17],["SocketOptionLevel",7]]},{"p":["SocketOptionValue"],"f":[["typealias",12],[" ",17],["SocketOptionValue",7],[" = ",17],["Int",18,1227]],"s":[["typealias",12],[" ",17],["SocketOptionValue",7]]},{"p":["BackPressureHandler","InboundOut"],"f":[["typealias",12],[" ",17],["InboundOut",7],[" = ",17],["ByteBuffer",18,58]],"s":[["typealias",12],[" ",17],["InboundOut",7]]},{"p":["BackPressureHandler","OutboundIn"],"f":[["typealias",12],[" ",17],["OutboundIn",7],[" = ",17],["NIOAny",18,115]],"s":[["typealias",12],[" ",17],["OutboundIn",7]]},{"p":["BackPressureHandler","OutboundOut"],"f":[["typealias",12],[" ",17],["OutboundOut",7],[" = ",17],["ByteBuffer",18,58]],"s":[["typealias",12],[" ",17],["OutboundOut",7]]},{"p":["BackPressureHandler","InboundIn"],"f":[["typealias",12],[" ",17],["InboundIn",7],[" = ",17],["ByteBuffer",18,58]],"s":[["typealias",12],[" ",17],["InboundIn",7]]},{"p":["RecvAllocatorOption"],"f":[["typealias",12],[" ",17],["RecvAllocatorOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["RecvAllocatorOption",18,84]],"s":[["typealias",12],[" ",17],["RecvAllocatorOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.RecvAllocatorOption"}}},{"p":["AcceptBackoffHandler","OutboundIn"],"f":[["typealias",12],[" ",17],["OutboundIn",7],[" = ",17],["Channel",18,27]],"s":[["typealias",12],[" ",17],["OutboundIn",7]]},{"p":["AcceptBackoffHandler","InboundIn"],"f":[["typealias",12],[" ",17],["InboundIn",7],[" = ",17],["Channel",18,27]],"s":[["typealias",12],[" ",17],["InboundIn",7]]},{"p":["ByteToMessageHandler","InboundOut"],"f":[["typealias",12],[" ",17],["InboundOut",7],[" = ",17],["Decoder",18],[".",17],["InboundOut",18]],"s":[["typealias",12],[" ",17],["InboundOut",7]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]]},{"p":["ByteToMessageHandler","InboundIn"],"f":[["typealias",12],[" ",17],["InboundIn",7],[" = ",17],["ByteBuffer",18,58]],"s":[["typealias",12],[" ",17],["InboundIn",7]],"c":[["Decoder",1,"ByteToMessageDecoder",13]],"g":[["Decoder",0,0]]},{"p":["ByteToMessageHandler","OutboundIn"],"f":[["typealias",12],[" ",17],["OutboundIn",7],[" = ",17],["Decoder",18],[".",17],["OutboundIn",18]],"s":[["typealias",12],[" ",17],["OutboundIn",7]],"e":[["Decoder",1,"WriteObservingByteToMessageDecoder",26]],"c":[["Decoder",1,"WriteObservingByteToMessageDecoder",26]],"g":[["Decoder",0,0]]},{"p":["ChannelDuplexHandler"],"f":[["typealias",12],[" ",17],["ChannelDuplexHandler",7],[" = ",17],["ChannelInboundHandler",18,17],[" & ",17],["ChannelOutboundHandler",18,19]],"s":[["typealias",12],[" ",17],["ChannelDuplexHandler",7]],"d":"A combination of `ChannelInboundHandler` and `ChannelOutboundHandler`."},{"p":["ConnectTimeoutOption"],"f":[["typealias",12],[" ",17],["ConnectTimeoutOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["ConnectTimeoutOption",18,85]],"s":[["typealias",12],[" ",17],["ConnectTimeoutOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.ConnectTimeoutOption"}}},{"p":["MarkedCircularBuffer","SubSequence"],"f":[["typealias",12],[" ",17],["SubSequence",7],[" = ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">",17]],"s":[["typealias",12],[" ",17],["SubSequence",7]],"g":[["Element",0,0]]},{"p":["MarkedCircularBuffer","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["CircularBuffer",18,93],["<",17],["Element",18],[">.",17],["Index",18,94]],"s":[["typealias",12],[" ",17],["Index",7]],"g":[["Element",0,0]]},{"p":["MarkedCircularBuffer","RangeType"],"f":[["typealias",12],[" ",17],["RangeType",7],["<",17],["Bound",0],["> = ",17],["Range",18,1338],["<",17],["Bound",18],["> ",17],["where",12],[" ",17],["Bound",18],[" : ",17],["Strideable",18,1345],[", ",17],["Bound",18],[".",17],["Stride",18],[" : ",17],["SignedInteger",18,1222]],"s":[["typealias",12],[" ",17],["RangeType",7]],"c":[["Bound",1,"Strideable",1345],["Bound.Stride",1,"SignedInteger",1222]],"g":[["Element",0,0],["Bound",0,1]]},{"p":["MessageToByteHandler","OutboundIn"],"f":[["typealias",12],[" ",17],["OutboundIn",7],[" = ",17],["Encoder",18],[".",17],["OutboundIn",18]],"s":[["typealias",12],[" ",17],["OutboundIn",7]],"c":[["Encoder",1,"MessageToByteEncoder",14]],"g":[["Encoder",0,0]]},{"p":["MessageToByteHandler","OutboundOut"],"f":[["typealias",12],[" ",17],["OutboundOut",7],[" = ",17],["ByteBuffer",18,58]],"s":[["typealias",12],[" ",17],["OutboundOut",7]],"c":[["Encoder",1,"MessageToByteEncoder",14]],"g":[["Encoder",0,0]]},{"p":["WriteBufferWaterMark"],"f":[["typealias",12],[" ",17],["WriteBufferWaterMark",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["WriteBufferWaterMark",18,86]],"s":[["typealias",12],[" ",17],["WriteBufferWaterMark",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.WriteBufferWaterMark"}}},{"p":["NIOCloseOnErrorHandler","InboundIn"],"f":[["typealias",12],[" ",17],["InboundIn",7],[" = ",17],["NIOAny",18,115]],"s":[["typealias",12],[" ",17],["InboundIn",7]]},{"p":["MaxMessagesPerReadOption"],"f":[["typealias",12],[" ",17],["MaxMessagesPerReadOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["MaxMessagesPerReadOption",18,87]],"s":[["typealias",12],[" ",17],["MaxMessagesPerReadOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.MaxMessagesPerReadOption"}}},{"p":["WriteBufferWaterMarkOption"],"f":[["typealias",12],[" ",17],["WriteBufferWaterMarkOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["WriteBufferWaterMarkOption",18,88]],"s":[["typealias",12],[" ",17],["WriteBufferWaterMarkOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.WriteBufferWaterMarkOption"}}},{"p":["AllowRemoteHalfClosureOption"],"f":[["typealias",12],[" ",17],["AllowRemoteHalfClosureOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["AllowRemoteHalfClosureOption",18,89]],"s":[["typealias",12],[" ",17],["AllowRemoteHalfClosureOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.AllowRemoteHalfClosureOption"}}},{"p":["DatagramVectorReadMessageCountOption"],"f":[["typealias",12],[" ",17],["DatagramVectorReadMessageCountOption",7],[" = ",17],["ChannelOptions",18,75],[".",17],["Types",18,44],[".",17],["DatagramVectorReadMessageCountOption",18,90]],"s":[["typealias",12],[" ",17],["DatagramVectorReadMessageCountOption",7]],"a":{"a":{"d":true,"r":"ChannelOptions.Types.DatagramVectorReadMessageCountOption"}}},{"p":["String","init(buffer:)"],"f":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[")",17]],"s":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[")",17]],"d":"Creates a `String` from a given `ByteBuffer`. The entire readable portion of the buffer will be read.\n- parameter buffer: The buffer to read."},{"p":["Array","init(buffer:)"],"f":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18,58],[")",17]],"s":[["init",10],["(",17],["buffer",1],[": ",17],["ByteBuffer",18],[")",17]],"e":[["Element",2,"UInt8",1384]],"c":[["Element",2,"UInt8",1384]],"g":[["Element",0,0]],"d":"Creates a `[UInt8]` from the given buffer. The entire readable portion of the buffer will be read.\n- parameter buffer: The buffer to read."},{"p":["Optional","setOrWriteBuffer(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setOrWriteBuffer",7],["(",17],["_",1],[" ",17],["buffer",2],[": ",17],["inout",12],[" ",17],["ByteBuffer",18,58],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setOrWriteBuffer",7],["(",17],["inout",12],[" ",17],["ByteBuffer",18],[") -> ",17],["Int",18]],"e":[["Wrapped",2,"ByteBuffer",58]],"c":[["Wrapped",2,"ByteBuffer",58]],"g":[["Wrapped",0,0]],"d":"If `nil`, replace `self` with `.some(buffer)`. If non-`nil`, write `buffer`'s readable bytes into the\n`ByteBuffer` starting at `writerIndex`.\n\nThis will move both this `ByteBuffer`'s writer index as well as `buffer`'s reader index by the number of bytes\nreadable in `buffer`.\n\n- parameters:\n    - buffer: The `ByteBuffer` to write.\n- returns: The number of bytes written to this `ByteBuffer` which is equal to the number of bytes read from `buffer`."},{"p":["Optional","setOrWriteImmutableBuffer(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["setOrWriteImmutableBuffer",7],["(",17],["_",1],[" ",17],["buffer",2],[": ",17],["ByteBuffer",18,58],[") -> ",17],["Int",18,1227]],"s":[["func",12],[" ",17],["setOrWriteImmutableBuffer",7],["(",17],["ByteBuffer",18],[") -> ",17],["Int",18]],"e":[["Wrapped",2,"ByteBuffer",58]],"c":[["Wrapped",2,"ByteBuffer",58]],"g":[["Wrapped",0,0]],"d":"If `nil`, replace `self` with `.some(buffer)`. If non-`nil`, write `buffer`'s readable bytes into the\n`ByteBuffer` starting at `writerIndex`.\n\n This method will not modify `buffer`, meaning its `readerIndex` and `writerIndex` stays intact.\n\n- parameters:\n    - buffer: The `ByteBuffer` to write.\n- returns: The number of bytes written to this `ByteBuffer` which is equal to the number of `readableBytes` in\n           `buffer`."}],"edges":{"conformer":[7,1161,[],9,18,[],9,20,[],12,20,[],12,27,[],17,8,[],19,8,[],22,8,[],25,13,[],26,13,[],27,20,[],28,10,[],38,1112,[],38,1161,[],39,1161,[],39,1380,[],39,1389,[],40,1112,[],40,1161,[],42,1112,[],42,1161,[],43,1112,[],43,1161,[],43,1371,[],46,1112,[],46,1161,[],46,1371,[],46,1380,[],46,1389,[],48,1112,[],48,1161,[],49,1380,[],49,1389,[],50,1112,[],50,1161,[],50,1380,[],50,1389,[],51,1380,[],51,1389,[],53,1112,[],53,1161,[],54,1161,[],54,1371,[],57,1112,[],57,1161,[],58,1112,[],58,1161,[],58,1371,[],59,1112,[],59,1161,[],59,1376,[],59,1380,[],59,1389,[],60,1380,[],60,1389,[],61,1161,[],61,1371,[],62,1112,[],62,1134,[],62,1161,[],62,1362,[],63,1112,[],63,1134,[],63,1161,[],63,1371,[],64,1112,[],64,1161,[],64,1216,[],65,1112,[],65,1161,[],65,1216,[],66,1112,[],66,1161,[],66,1216,[],67,1112,[],67,1161,[],67,1216,[],68,1161,[],68,1216,[],68,1347,[],68,1374,[],68,1391,[],70,1112,[],70,1161,[],74,1112,[],74,1115,[],74,1145,[],74,1161,[],74,1166,[],74,1228,[],74,1233,[],74,1292,[],74,1374,[],76,1112,[],76,1161,[],76,1374,[],77,1112,[],77,1161,[],78,7,[],78,1161,[],79,7,[],79,1161,[],80,7,[],80,1161,[],81,7,[],81,1161,[],82,7,[],82,1161,[],83,7,[],83,1161,[],84,7,[],84,1161,[],85,7,[],85,1161,[],87,7,[],87,1161,[],88,7,[],88,1161,[],89,7,[],89,1161,[],90,7,[],90,1161,[],91,7,[],91,1161,[],93,1112,[["Element",1,"Hashable",1112]],93,1115,[],93,1145,[],93,1161,[["Element",1,"Equatable",1161]],93,1166,[],93,1228,[],93,1233,[],93,1292,[],93,1371,[],93,1374,[],94,1134,[],94,1161,[],96,1389,[],97,15,[],98,1112,[],98,1161,[],98,1376,[],99,1112,[["DataType",1,"Hashable",1112]],99,1161,[["DataType",1,"Equatable",1161]],99,1371,[],100,1112,[],100,1161,[],101,1166,[],101,1341,[],102,1112,[],102,1161,[],102,1380,[],102,1389,[],104,1115,[],104,1145,[],104,1166,[],104,1228,[],104,1233,[],104,1371,[],105,1380,[],105,1389,[],108,1380,[],108,1389,[],110,1380,[],110,1389,[],111,21,[],112,1380,[],112,1389,[],113,21,[],114,1380,[],114,1389,[],115,1371,[],116,1371,[],116,1380,[],116,1389,[],119,11,[],119,1371,[],120,9,[],120,18,[],120,20,[],120,1376,[],121,1161,[],121,1389,[],122,8,[],122,17,[],122,19,[],122,22,[],123,8,[],123,17,[],123,19,[],123,22,[],124,1161,[],124,1376,[],125,8,[],125,17,[],125,19,[],125,22,[],126,8,[["Decoder",1,"ByteToMessageDecoder",13]],126,17,[["Decoder",1,"ByteToMessageDecoder",13]],126,19,[["Decoder",1,"WriteObservingByteToMessageDecoder",26]],126,22,[["Decoder",1,"ByteToMessageDecoder",13]],127,8,[],127,19,[],128,9,[],128,18,[],128,20,[],129,8,[],129,17,[]],"feature":[628,123,628,125,628,129,629,129,885,122,885,123,885,125,885,126,885,129,886,122,886,123,886,125,886,126,886,129,905,122,905,123,905,125,905,126,905,127,915,120,915,128,917,120,917,128,919,120,919,128,921,120,921,128,923,120,923,128,924,120,924,128,926,120,926,128,932,122,932,123,932,125,1116,74,1116,93,1116,104,1117,74,1117,93,1117,104,1118,74,1118,93,1118,104,1120,74,1120,93,1121,74,1121,93,1122,74,1122,93,1123,74,1123,93,1123,104,1124,74,1124,93,1124,104,1125,74,1125,93,1125,104,1126,74,1126,93,1126,104,1127,74,1127,93,1127,104,1128,74,1128,93,1128,104,1129,74,1129,93,1129,104,1130,74,1130,93,1130,104,1131,74,1131,93,1131,104,1132,74,1132,93,1132,104,1133,93,1133,104,1137,62,1137,63,1137,94,1138,62,1138,63,1138,94,1139,62,1139,63,1139,94,1140,62,1140,63,1140,94,1141,62,1141,63,1141,94,1142,62,1142,63,1142,94,1143,62,1143,63,1143,94,1144,62,1144,63,1144,94,1147,74,1147,93,1147,104,1148,74,1148,93,1148,104,1149,74,1149,93,1149,104,1150,74,1150,93,1150,104,1151,74,1151,93,1151,104,1152,74,1152,93,1152,104,1153,74,1153,93,1153,104,1154,74,1154,93,1154,104,1155,74,1155,93,1155,104,1156,74,1156,93,1156,104,1157,74,1157,93,1157,104,1158,74,1158,93,1158,104,1159,74,1159,93,1159,104,1163,38,1163,39,1163,40,1163,42,1163,43,1163,46,1163,48,1163,50,1163,53,1163,54,1163,57,1163,58,1163,59,1163,61,1163,62,1163,63,1163,64,1163,65,1163,66,1163,67,1163,68,1163,70,1163,74,1163,76,1163,77,1163,78,1163,79,1163,80,1163,81,1163,82,1163,83,1163,84,1163,85,1163,87,1163,88,1163,89,1163,90,1163,91,1163,93,1163,94,1163,98,1163,99,1163,100,1163,102,1163,121,1163,124,1167,74,1167,93,1167,101,1167,104,1168,74,1168,93,1168,101,1168,104,1169,74,1169,93,1169,101,1169,104,1172,101,1173,74,1173,93,1173,101,1173,104,1174,74,1174,93,1174,101,1174,104,1175,74,1175,93,1175,101,1175,104,1176,74,1176,93,1176,101,1176,104,1177,74,1177,93,1177,101,1177,104,1178,74,1178,93,1178,101,1178,104,1179,74,1179,93,1179,101,1179,104,1180,74,1180,93,1180,101,1180,104,1181,74,1181,93,1181,101,1181,104,1182,74,1182,93,1182,101,1182,104,1183,101,1184,74,1184,93,1184,101,1184,104,1185,74,1185,93,1185,101,1185,104,1186,101,1187,101,1187,104,1188,101,1189,101,1190,74,1190,93,1190,101,1190,104,1191,74,1191,93,1191,101,1191,104,1192,74,1192,93,1192,101,1192,104,1193,74,1193,93,1193,101,1193,104,1194,101,1195,74,1195,93,1195,101,1195,104,1196,74,1196,93,1196,101,1196,104,1197,74,1197,93,1197,101,1197,104,1198,74,1198,93,1198,101,1198,104,1199,101,1200,101,1201,74,1201,93,1201,101,1201,104,1202,74,1202,93,1202,101,1202,104,1203,101,1204,74,1204,93,1204,104,1205,74,1205,93,1205,104,1206,74,1206,93,1206,104,1207,74,1207,93,1207,104,1208,74,1208,93,1208,104,1209,93,1209,104,1210,74,1210,93,1210,104,1211,74,1211,93,1211,104,1212,93,1212,104,1213,93,1213,104,1214,93,1214,104,1220,64,1220,65,1220,66,1220,67,1221,64,1221,65,1221,66,1221,67,1231,74,1231,93,1231,104,1236,74,1236,93,1236,104,1237,74,1237,93,1237,104,1238,74,1238,93,1238,104,1239,74,1239,93,1239,104,1240,74,1240,93,1240,104,1241,74,1241,93,1241,104,1242,74,1242,93,1242,104,1243,74,1243,93,1243,104,1244,74,1244,93,1244,104,1245,74,1245,93,1246,74,1246,93,1247,74,1247,93,1247,104,1248,74,1248,93,1248,104,1249,74,1249,93,1249,104,1250,93,1250,104,1251,74,1251,93,1251,104,1252,93,1252,104,1261,74,1261,93,1262,74,1262,93,1263,74,1263,93,1264,74,1264,93,1264,104,1265,74,1265,93,1265,104,1266,74,1266,93,1266,104,1267,74,1267,93,1267,104,1268,74,1268,93,1268,104,1269,74,1269,93,1269,104,1270,74,1270,93,1270,104,1271,74,1271,93,1271,104,1272,74,1272,93,1272,104,1273,74,1273,93,1273,104,1274,74,1274,93,1274,104,1275,74,1275,93,1275,104,1276,74,1276,93,1276,104,1277,74,1277,93,1277,104,1278,74,1278,93,1278,104,1279,74,1279,93,1279,104,1280,74,1280,93,1280,104,1281,74,1281,93,1281,104,1282,74,1282,93,1282,104,1283,74,1283,93,1283,104,1284,74,1284,93,1284,104,1285,93,1285,104,1286,74,1286,93,1286,104,1287,74,1287,93,1287,104,1288,74,1288,93,1288,104,1289,74,1289,93,1289,104,1298,74,1298,93,1299,74,1299,93,1300,74,1300,93,1301,74,1301,93,1302,74,1302,93,1306,74,1306,93,1307,74,1307,93,1308,74,1308,93,1309,74,1309,93,1310,74,1310,93,1311,74,1311,93,1312,74,1312,93,1313,74,1313,93,1314,74,1314,93,1315,74,1315,93,1316,74,1316,93,1317,74,1317,93,1318,74,1318,93,1319,74,1319,93,1320,74,1320,93,1321,74,1321,93,1322,74,1322,93,1323,74,1323,93,1324,74,1324,93,1325,74,1325,93,1326,74,1326,93,1327,74,1327,93,1328,74,1328,93,1329,74,1329,93,1330,74,1330,93,1331,74,1331,93,1332,74,1332,93,1333,74,1333,93,1334,74,1334,93,1335,74,1335,93,1336,74,1336,93,1348,68,1349,68,1350,68,1351,68,1352,68,1353,68,1354,68,1355,68,1356,68,1357,68,1368,62,1369,62,1370,62,1373,43,1373,46,1373,54,1373,58,1373,61,1373,63,1373,93,1373,99,1373,104,1373,115,1373,116,1373,119,1393,68,1394,68,1395,68,1396,68,1397,68,1398,68,1399,68,1400,68,1401,68,1402,68,1403,68],"member":[0,1226,1,1226,2,1226,3,1226,4,1110,5,1111,44,75,45,44,47,120,48,122,56,116,59,58,60,58,64,41,65,41,66,41,67,41,68,119,69,119,71,43,72,43,73,43,76,75,77,75,78,44,79,44,80,44,81,44,82,44,83,44,84,44,85,44,86,44,87,44,88,44,89,44,90,44,91,44,92,75,94,93,95,120,100,99,102,49,106,128,108,51,131,38,132,38,133,39,134,39,135,39,136,39,137,39,138,39,139,39,140,39,141,39,142,39,143,39,144,39,145,39,146,39,147,39,148,39,149,39,150,40,151,40,152,42,153,42,154,43,155,43,156,43,157,45,158,45,159,46,160,46,161,46,162,46,163,47,164,47,165,47,166,47,167,48,168,48,169,48,170,49,171,49,172,49,173,49,174,50,175,50,176,51,177,51,178,52,179,52,180,53,181,53,182,53,183,53,184,54,185,54,186,56,187,56,188,57,189,57,190,57,191,58,192,58,193,58,194,58,195,58,196,58,197,58,198,58,199,58,200,58,201,61,202,61,203,64,204,65,205,66,206,67,207,119,208,68,209,119,210,119,211,70,212,43,213,43,214,43,215,43,216,43,217,43,218,43,219,43,220,74,221,74,222,74,223,76,224,78,225,78,226,79,227,80,228,81,229,82,230,83,231,84,232,85,233,86,234,87,235,88,236,89,237,90,238,91,239,92,240,93,241,93,242,93,243,120,244,122,245,97,246,98,247,98,248,99,249,99,250,100,251,100,252,101,253,102,254,123,255,103,256,125,257,126,258,126,259,104,260,127,261,105,262,107,263,129,264,108,265,109,266,110,267,111,268,111,269,112,270,113,271,130,272,115,273,116,274,116,275,117,276,74,277,74,278,93,279,93,280,93,281,104,282,104,283,59,284,59,285,60,286,60,287,38,288,62,289,63,290,63,291,64,292,64,293,64,294,64,295,65,296,65,297,65,298,66,299,66,300,66,301,66,302,67,303,67,304,67,305,67,306,67,307,67,308,67,309,67,310,67,311,67,312,67,313,67,314,67,315,67,316,67,317,67,318,67,319,67,320,67,321,67,322,68,323,68,324,69,325,75,326,75,327,75,328,75,329,75,330,77,331,77,332,77,333,75,334,75,335,75,336,75,337,75,338,75,339,75,340,75,341,75,342,75,343,55,344,58,345,58,346,58,347,58,348,58,349,59,350,58,351,58,352,58,353,58,354,61,355,61,356,61,357,61,358,61,359,62,360,63,361,63,362,64,363,65,364,66,365,67,366,119,367,68,368,119,369,70,370,70,371,43,372,71,373,71,374,72,375,72,376,73,377,43,378,43,379,43,380,43,381,43,382,43,383,74,384,74,385,74,386,78,387,78,388,78,389,78,390,86,391,86,392,45,393,93,394,93,395,93,396,93,397,93,398,93,399,93,400,46,401,10,403,120,404,120,405,95,406,120,407,121,408,96,409,122,410,122,411,122,412,98,413,98,414,98,415,98,416,98,417,98,418,98,419,98,420,99,421,99,422,99,423,100,424,100,425,99,426,102,427,124,428,124,429,124,430,124,431,124,432,124,433,124,434,124,435,104,436,104,437,104,438,104,439,104,440,104,441,104,442,104,443,104,445,128,446,128,447,128,448,128,449,128,450,128,451,128,452,107,454,110,455,111,456,111,457,111,458,113,459,54,460,54,461,115,472,116,473,116,474,116,475,116,477,117,478,62,479,62,480,62,481,62,482,62,483,62,484,63,485,63,486,69,487,69,488,43,489,121,490,121,491,121,492,121,493,121,494,121,495,121,496,121,497,121,498,121,499,125,500,55,501,55,502,58,503,58,504,58,505,58,506,58,507,58,508,58,509,58,510,58,511,58,512,58,513,58,514,58,515,58,516,58,517,58,518,58,519,58,520,58,521,58,522,58,523,58,524,58,525,58,526,58,527,58,528,58,529,58,530,58,531,58,532,58,533,58,534,58,535,58,536,58,537,58,538,58,539,58,540,58,541,58,542,58,543,58,544,58,545,58,546,58,547,58,548,58,549,58,550,58,551,58,552,58,553,58,554,58,555,58,556,58,557,58,558,58,559,58,560,58,561,58,562,58,563,58,564,58,565,58,566,58,567,58,568,58,569,58,570,58,571,58,572,58,573,58,574,58,575,58,576,58,577,58,578,58,579,58,580,58,581,58,582,58,583,58,584,58,585,58,586,58,587,58,588,58,589,58,590,58,591,58,592,58,593,58,594,58,595,58,596,61,610,6,611,6,612,6,613,6,614,118,615,119,616,119,617,119,618,119,619,43,620,43,621,74,622,74,623,74,624,74,625,74,630,76,631,76,632,76,633,92,634,92,635,93,636,93,637,93,638,93,639,93,640,93,641,93,642,93,643,93,644,93,645,93,646,93,647,93,648,93,649,93,650,93,651,93,652,93,653,93,658,10,659,10,660,10,664,120,665,120,666,120,667,120,668,120,669,120,670,120,671,120,672,120,673,120,674,120,675,120,676,120,677,120,678,120,679,120,680,120,681,120,682,120,683,120,684,120,685,120,686,120,687,120,688,95,689,95,690,95,691,95,692,95,693,95,694,95,695,95,696,95,697,95,698,95,699,95,700,95,701,95,702,95,703,95,704,95,705,95,706,95,707,95,708,95,709,95,710,95,711,95,712,95,713,120,714,120,715,120,716,120,717,120,718,120,719,120,720,120,721,120,722,120,723,120,724,120,725,120,726,120,727,120,728,120,729,121,730,121,731,121,732,121,733,121,734,121,735,121,736,121,737,121,738,121,739,121,740,121,741,121,742,121,743,121,744,121,745,121,746,121,747,121,748,121,749,121,750,121,751,121,752,121,753,121,754,121,755,121,756,121,757,121,758,121,759,121,760,121,761,121,762,121,763,121,764,121,765,121,766,121,767,121,768,96,769,96,770,96,771,96,772,96,773,122,774,122,775,122,776,122,777,122,778,122,786,12,788,12,789,12,791,12,793,12,794,12,795,97,796,98,797,101,798,123,799,123,800,123,801,103,802,103,803,103,804,103,805,103,806,103,807,103,808,103,809,103,810,125,811,125,812,125,813,125,822,13,824,126,825,126,826,126,827,126,828,126,829,126,830,126,831,104,832,104,833,104,834,104,835,104,836,104,837,104,838,104,839,104,841,127,842,127,843,127,849,16,850,16,851,16,852,16,853,16,854,16,855,16,856,16,857,16,858,16,859,16,860,16,861,16,862,16,863,16,864,128,865,128,866,128,867,128,868,128,869,128,870,128,871,128,872,128,873,128,874,128,875,128,876,128,877,128,878,128,879,128,880,128,881,128,882,128,896,107,897,107,898,107,899,107,900,107,901,107,902,107,903,107,915,20,916,20,917,20,918,20,919,20,920,20,921,20,922,20,923,20,924,20,925,20,926,20,927,20,928,129,942,111,943,111,944,113,945,113,951,130,952,130,953,54,958,27,959,27,961,27,968,27,980,28,983,28,984,28,985,28,987,28,988,28,989,28,990,28,991,28,992,28,993,28,994,28,996,28,999,28,1001,117,1002,58,1003,61,1004,62,1005,62,1006,62,1007,62,1008,62,1009,62,1010,62,1011,63,1012,63,1013,63,1014,63,1015,63,1016,43,1017,74,1018,94,1019,94,1020,93,1021,121,1022,98,1023,124,1024,62,1025,63,1027,64,1028,65,1029,66,1030,41,1031,67,1035,74,1036,74,1037,74,1038,78,1039,79,1040,80,1041,81,1042,82,1043,83,1044,84,1045,85,1046,87,1047,88,1048,89,1049,90,1050,91,1051,93,1052,93,1053,93,1054,93,1057,122,1058,122,1059,122,1060,122,1062,101,1065,123,1066,123,1067,123,1068,123,1070,125,1071,125,1072,126,1073,126,1074,126,1077,104,1078,104,1079,104,1080,127,1081,127,1083,129,1088,1165,1089,1223,1090,1339,1091,1339],"override":[36,30],"requirement":[29,7,30,13,31,14,32,15,33,17,34,17,35,19,36,25,37,26,402,11,444,16,453,20,462,27,463,27,464,27,465,27,466,27,467,27,468,27,469,27,470,27,476,28,597,6,598,6,599,6,600,6,601,6,602,6,603,6,604,6,605,6,606,6,607,6,608,6,609,6,626,8,627,8,654,10,655,10,656,10,657,10,662,11,663,11,779,12,780,12,781,12,782,12,783,12,784,12,814,13,815,13,816,13,817,13,818,13,840,14,844,15,845,16,846,16,847,16,848,16,883,17,884,17,887,18,888,18,889,18,890,18,891,18,892,18,893,18,894,18,895,18,904,19,906,20,907,20,908,20,909,20,910,20,911,20,912,20,913,20,914,20,929,21,930,21,931,22,933,23,934,23,935,24,936,24,937,24,938,24,939,24,940,24,941,24,946,25,947,25,950,26,954,27,955,27,973,28,974,28,975,28,976,28,977,28,978,28,979,28],"defaultImplementation":[471,464,628,626,629,627,661,656,785,779,787,780,790,782,792,783,819,814,820,815,821,816,823,817,885,883,886,884,905,904,932,931,948,814,949,818,956,907,957,907,960,906,962,908,963,909,964,910,965,911,966,912,967,912,969,913,970,914,971,954,972,955,981,973,982,974,986,654,995,977,997,656,998,657,1000,978]},"hints":[94,1253,203,1219,204,1219,205,1219,206,1219,208,1392,220,1375,221,1337,223,1375,240,1375,242,1337,276,1232,277,1291,279,1290,280,1291,281,1290,282,1291,288,1367,344,1372,349,1377,355,1372,360,1372,362,1218,363,1218,364,1218,365,1218,366,1372,367,1218,368,402,377,1372,383,1234,384,1254,385,1260,393,1234,394,1372,395,1254,397,1258,399,1260,400,1372,404,1377,406,453,414,1377,420,1372,429,1377,435,1234,436,1372,439,1254,442,1258,443,1260,451,453,459,1372,461,1372,472,1372,581,1113,616,662,617,663,620,1113,621,1296,623,1170,624,1113,625,1229,628,628,629,629,637,1293,638,1294,639,1295,640,1296,641,1297,642,1255,643,1230,644,1256,645,1303,647,1304,650,1259,652,1305,653,1113,664,887,665,888,666,889,667,890,668,891,669,892,670,893,686,907,687,895,713,906,714,894,715,908,716,909,717,910,718,911,719,912,720,913,728,914,773,1101,774,626,775,1103,776,627,777,1105,778,1108,787,780,792,783,795,844,796,1113,797,1342,798,627,799,1106,800,1107,810,1102,811,627,812,1104,813,1107,819,814,820,815,821,816,824,931,825,1101,826,626,827,627,828,1104,829,1100,830,1108,834,1255,835,1230,836,1256,838,1259,841,626,842,627,843,1108,864,887,865,888,866,889,867,890,868,891,869,892,870,893,872,907,873,895,874,906,875,894,876,908,877,909,878,910,879,911,880,912,881,913,882,914,885,883,886,884,905,904,915,915,917,917,919,919,921,921,923,923,924,924,926,926,928,1102,932,931,942,929,943,930,944,929,945,930,948,814,949,818,956,907,960,906,962,908,963,909,964,910,965,911,966,912,969,913,970,914,1002,1162,1003,1162,1004,1136,1007,1363,1008,1364,1009,1365,1010,1366,1011,1135,1012,1136,1016,1162,1017,1162,1018,1136,1019,1162,1020,1162,1021,1162,1022,1162,1023,1162,1027,1217,1028,1217,1029,1217,1031,1217,1035,1235,1036,1253,1037,1171,1038,29,1039,29,1040,29,1041,29,1042,29,1043,29,1044,29,1045,29,1046,29,1047,29,1048,29,1049,29,1050,29,1051,1235,1052,1171,1053,1257,1057,34,1058,35,1059,1109,1060,33,1062,1171,1065,34,1066,35,1067,1109,1068,33,1070,35,1071,33,1072,34,1073,33,1074,35,1077,1235,1078,1253,1080,35,1081,1109,1083,33,1116,1116,1117,1117,1118,1118,1120,1120,1121,1121,1122,1122,1123,1123,1124,1124,1125,1125,1126,1126,1127,1127,1128,1128,1129,1119,1130,1130,1131,1131,1132,1132,1133,1133,1137,1137,1138,1138,1139,1139,1140,1140,1141,1141,1142,1142,1143,1143,1144,1144,1147,1146,1148,1148,1149,1149,1150,1150,1151,1151,1152,1152,1153,1153,1154,1154,1155,1155,1156,1156,1157,1157,1158,1158,1159,1159,1163,1163,1167,1167,1168,1168,1169,1169,1172,1172,1173,1173,1174,1174,1175,1175,1176,1176,1177,1177,1178,1178,1179,1170,1180,1180,1181,1181,1182,1182,1183,1183,1184,1184,1185,1185,1186,1186,1187,1187,1188,1188,1189,1189,1190,1190,1191,1191,1192,1192,1193,1193,1194,1194,1195,1195,1196,1196,1197,1197,1198,1198,1199,1199,1200,1200,1201,1201,1202,1202,1203,1203,1204,1204,1205,1205,1206,1206,1207,1207,1208,1208,1209,1209,1210,1210,1211,1211,1212,1212,1213,1213,1214,1214,1220,1220,1221,1221,1231,1231,1236,1236,1237,1237,1238,1238,1239,1239,1240,1240,1241,1241,1242,1242,1243,1243,1244,1244,1245,1245,1246,1246,1247,1247,1248,1248,1249,1249,1250,1250,1251,1251,1252,1252,1261,1261,1262,1262,1263,1263,1264,1264,1265,1265,1266,1266,1267,1267,1268,1268,1269,1269,1270,1270,1271,1271,1272,1272,1273,1273,1274,1274,1275,1275,1276,1276,1277,1277,1278,1278,1279,1279,1280,1280,1281,1281,1282,1282,1283,1283,1284,1284,1285,1285,1286,1286,1287,1287,1288,1288,1289,1289,1298,1298,1299,1299,1300,1300,1301,1301,1302,1302,1306,1306,1307,1307,1308,1308,1309,1309,1310,1310,1311,1311,1312,1296,1313,1313,1314,1314,1315,1315,1316,1316,1317,1317,1318,1318,1319,1319,1320,1320,1321,1321,1322,1322,1323,1323,1324,1324,1325,1325,1326,1326,1327,1327,1328,1328,1329,1329,1330,1330,1331,1331,1332,1332,1333,1333,1334,1334,1335,1335,1336,1336,1348,1348,1349,1349,1350,1350,1351,1351,1352,1352,1353,1353,1354,1354,1355,1355,1356,1356,1357,1357,1368,1368,1369,1365,1370,1366,1373,1373,1393,1393,1394,1394,1395,1395,1396,1396,1397,1397,1398,1398,1399,1399,1400,1400,1401,1401,1402,1402,1403,1403],"sourcemap":[{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/AddressedEnvelope.swift","symbols":[19,14,99,20,15,421,21,15,422,23,15,425,25,11,249,30,11,248,37,18,100,39,19,424,40,19,423,42,15,251,47,15,250,55,15,420,65,12,53,67,9,180,69,9,182,71,9,183,73,9,181,76,14,70,77,15,370,78,15,369,80,11,211]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/AsyncAwaitSupport.swift","symbols":[15,17,1026,29,16,753,47,16,658,71,16,770,92,16,959,99,16,972,106,16,971,116,16,927,125,16,920,134,16,925,144,16,918,154,16,922,164,16,916,171,16,672,178,16,685,183,16,679,188,16,682,193,16,725,198,16,723,204,16,721,209,16,676,215,16,675,221,14,105,222,12,261,234,16,2,255,16,3,277,16,0,297,16,1]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/BSDSocketAPI.swift","symbols":[83,12,41,87,21,1030,93,18,65,94,25,1028,95,19,363,96,15,204,110,18,66,111,25,1029,112,19,364,113,15,205,127,18,64,128,25,1027,129,19,362,130,15,203,144,18,67,145,25,1031,146,19,365,147,15,206,162,22,295,166,22,297,170,22,296,177,22,298,181,22,300,185,22,299,192,26,301,202,26,291,211,26,293,223,26,292,234,22,294,241,22,312,245,22,315,249,22,308,253,22,313,257,22,310,264,22,309,268,22,311,272,22,316,276,22,314,280,22,317,285,22,302,292,22,304,299,22,319,315,22,318,319,22,305,323,22,320,327,22,321,331,22,303,335,22,306,342,22,307]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ByteBuffer-aux.swift","symbols":[28,16,586,48,25,592,65,25,529,78,25,525,92,25,513,105,25,568,132,25,594,153,25,565,168,16,591,186,16,563,210,25,508,224,25,567,241,25,516,255,25,514,277,25,528,291,25,524,311,16,517,326,25,527,347,25,570,362,25,571,378,25,576,393,25,577,407,25,578,419,25,505,433,25,506,447,25,511,460,25,510,473,25,504,486,25,502,504,16,585,521,25,593,531,25,503,548,11,199,563,11,195,578,11,198,593,11,192,608,11,193,624,11,196,638,11,197,657,11,194,672,11,191,684,16,804,696,16,808,708,16,802,720,16,803,733,16,805,747,16,807,763,16,809,776,16,801,796,25,1091,812,25,1090]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ByteBuffer-conversions.swift","symbols":[21,11,1089,33,11,1088,45,11,4]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ByteBuffer-core.swift","symbols":[74,14,103,79,22,255,107,16,806,215,14,58,502,26,348,508,26,347,516,15,353,524,15,350,538,25,523,563,25,522,589,25,574,607,25,575,622,25,572,634,25,573,643,16,531,652,25,569,665,16,566,683,16,580,692,16,579,720,16,587,768,44,526,796,15,345,803,15,346,814,25,584,833,25,583,847,25,582,872,15,344,894,15,351,904,25,589,911,25,588,923,25,519,937,25,518,951,25,521,965,25,520,983,25,590,1011,18,59,1020,26,284,1023,26,283,1030,15,349,1040,23,1002,1062,16,581,1084,25,547]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ByteBuffer-int.swift","symbols":[32,25,512,50,16,507,79,25,515,96,25,509,161,12,38,163,22,287,171,9,131,174,9,132]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ByteBuffer-lengthPrefix.swift","symbols":[15,18,60,22,26,285,23,26,286,37,25,532,85,25,530,110,25,564,131,16,562]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ByteBuffer-multi-int.swift","symbols":[19,25,546,55,25,548,85,25,545,127,25,549,163,25,544,211,25,550,253,25,543,307,25,551,355,25,542,415,25,552,469,25,541,535,25,553,595,25,540,667,25,554,733,25,539,811,25,555,883,25,538,967,25,556,1045,25,537,1135,25,557,1219,25,536,1315,25,558,1405,25,535,1507,25,559,1603,25,534,1711,25,560,1813,25,533,1927,25,561]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ByteBuffer-views.swift","symbols":[18,14,74,19,21,1037,20,21,1036,21,21,1035,35,11,222,40,16,622,48,15,383,53,15,385,58,16,625,63,15,384,70,11,277,86,11,276,96,16,623,146,11,221,151,25,621,193,15,352,204,16,595,216,11,200,224,23,1017,242,16,624,252,11,220]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/Channel.swift","symbols":[21,16,6,23,9,599,26,9,600,32,9,609,37,9,602,44,9,603,51,9,608,58,9,607,61,9,606,64,9,604,72,9,605,79,9,601,85,9,597,91,9,598,104,16,27,106,8,470,109,8,463,112,8,469,115,8,465,118,8,466,122,8,467,125,9,955,128,9,954,131,8,462,136,8,468,146,8,464,151,15,471,156,16,23,160,9,934,165,9,933,171,16,962,175,16,969,179,16,966,183,16,965,187,16,956,191,16,963,195,16,964,199,16,970,203,16,961,207,16,960,219,16,968,226,16,967,233,16,958,241,16,957,263,16,610,285,16,611,299,16,612,312,16,613,318,12,39,320,9,137,323,9,138,326,9,141,329,9,133,332,9,136,335,9,135,338,9,134,342,9,149,346,9,143,349,9,142,352,9,140,355,9,147,358,9,146,362,9,145,366,9,144,369,9,148,372,9,139,378,14,114,381,12,40,383,9,150,385,9,151,393,14,109,394,11,265]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ChannelHandler.swift","symbols":[19,16,8,24,9,626,30,9,627,221,16,628,225,16,629,319,16,22,333,9,931,340,16,932]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ChannelHandlers.swift","symbols":[20,19,125,21,21,1071,22,21,1070,29,23,499,37,11,256,43,16,813,61,16,810,74,16,812,83,16,811,111,19,123,112,21,1066,113,21,1068,114,21,1065,115,21,1067,120,11,254,122,16,800,130,16,799,142,16,798,155,19,122,156,21,1060,157,21,1057,158,21,1058,159,21,1059,162,16,48,164,13,169,166,13,168,168,13,167,171,15,410,172,15,411,173,15,409,182,11,244,191,16,774,197,16,776,201,16,775,206,16,773,213,16,777,221,16,778]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ChannelInvoker.swift","symbols":[15,16,20,22,9,914,29,9,908,36,9,913,47,9,912,50,9,911,58,9,907,65,9,909,73,9,910,80,9,906,83,8,453,95,16,926,105,16,919,115,16,924,129,16,923,140,16,917,151,16,921,162,16,915,174,16,18,177,9,887,180,9,889,186,9,892,192,9,893,198,9,891,201,9,888,211,9,890,220,9,895,226,9,894,230,16,9,233,12,57,236,9,190,240,9,189,243,9,188]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ChannelOption.swift","symbols":[15,16,7,17,19,29,20,17,1061,22,21,1063,23,21,1064,30,17,1032,33,17,1055,36,17,1069,39,17,1034,42,17,1056,45,17,1084,48,17,1033,51,17,1087,54,17,1082,57,17,1085,60,17,1076,63,17,1086,66,16,44,71,22,78,72,29,1038,74,23,387,75,23,386,77,23,389,85,23,388,100,23,224,111,19,225,118,22,81,119,29,1041,121,19,228,125,22,84,126,29,1044,128,19,231,133,22,80,134,29,1040,136,19,227,142,22,82,143,29,1042,145,19,229,150,22,87,151,29,1046,153,19,234,157,22,79,158,29,1039,160,19,226,187,22,90,188,29,1049,190,19,237,194,22,91,195,29,1050,196,19,238,200,22,86,205,23,390,211,23,391,220,19,233,233,22,88,234,29,1047,236,19,235,241,22,85,242,29,1045,244,19,232,252,22,89,253,29,1048,255,19,236,259,22,83,260,29,1043,261,19,230,267,14,75,269,26,337,275,22,325,280,22,341,285,22,340,288,22,326,291,22,339,294,22,329,297,22,338,300,22,342,303,22,333,306,22,327,309,22,334,312,22,335,315,22,336,318,22,328,324,18,92,328,15,239,339,29,634,366,20,633]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ChannelPipeline.swift","symbols":[140,19,120,148,15,406,169,16,671,335,16,684,346,16,678,357,16,681,368,16,683,392,16,677,416,16,680,439,16,726,468,16,724,501,16,722,612,16,664,622,16,666,632,16,670,642,16,669,652,16,668,662,16,665,672,16,667,682,16,714,692,16,687,702,16,717,712,16,718,722,16,716,732,16,719,742,16,686,752,16,715,762,16,720,772,16,728,782,16,713,935,11,243,957,16,674,980,16,673,1034,18,95,1043,19,405,1054,20,695,1066,20,697,1077,20,696,1088,20,710,1097,20,709,1107,20,708,1116,20,711,1123,20,688,1131,20,690,1139,20,694,1147,20,693,1155,20,692,1163,20,689,1171,20,691,1179,20,701,1187,20,699,1195,20,704,1203,20,705,1211,20,703,1219,20,706,1227,20,698,1235,20,702,1243,20,707,1251,20,712,1259,20,700,1267,15,403,1274,16,47,1276,13,165,1279,13,163,1282,13,166,1285,13,164,1391,12,50,1393,9,174,1395,9,175,1408,19,128,1413,15,450,1415,15,448,1419,15,449,1423,15,446,1436,15,445,1449,15,451,1453,15,447,1473,16,864,1480,16,866,1487,16,869,1494,16,870,1499,16,868,1504,16,865,1511,16,867,1516,16,873,1521,16,875,1528,16,882,1542,16,876,1556,16,881,1571,16,880,1585,16,879,1598,16,872,1610,16,877,1622,16,878,1635,16,874,1845,18,106,1856,16,871,1874,15,404,1930,16,727]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/CircularBuffer.swift","symbols":[17,14,93,64,18,94,86,27,1019,93,27,1018,114,21,1052,115,21,1053,116,21,1054,117,21,1051,129,16,642,135,16,643,152,11,280,171,15,393,187,15,399,210,16,650,285,16,644,292,11,279,316,11,241,326,11,242,334,25,645,348,25,649,421,11,278,432,15,397,438,15,395,448,15,398,454,25,652,483,25,646,489,15,394,518,25,651,537,25,648,561,25,636,584,25,638,606,25,637,626,25,635,644,25,640,692,25,639,716,25,647,750,15,396,760,25,641,804,23,1020,810,16,653,818,11,240]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/Codec.swift","symbols":[16,12,42,18,9,153,21,9,152,25,12,51,30,9,176,34,9,177,40,18,108,41,15,264,144,16,13,146,19,30,160,18,818,178,18,814,184,18,816,190,18,815,198,18,817,206,16,26,208,19,37,214,18,950,218,25,821,221,25,820,225,16,823,237,16,822,241,25,819,374,19,126,375,21,1073,376,21,1072,463,23,258,472,11,257,609,16,826,621,16,827,637,16,825,673,16,828,681,16,829,692,21,1074,693,16,830,708,16,14,709,19,31,716,9,840,720,16,824,744,19,127,745,21,1081,746,21,1080,768,11,260,774,16,841,781,16,842,786,16,843]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/ConvenienceOptionSupport.swift","symbols":[32,16,899,47,16,45,49,13,158,51,13,157,57,15,392,82,18,77,100,22,332,103,22,330,110,22,331,116,18,76,123,15,223,144,29,632,154,29,630,164,29,631]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/DispatchQueue+WithFuture.swift","symbols":[30,16,5]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/EventLoop+Deprecated.swift","symbols":[17,16,989,23,16,992]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/EventLoop.swift","symbols":[21,14,117,26,11,275,36,16,1001,43,15,477,51,19,118,96,16,614,176,14,101,177,21,1062,181,11,252,188,25,797,219,16,28,221,8,476,224,9,979,231,9,978,242,9,976,254,9,975,258,9,973,262,9,974,269,9,977,308,16,995,328,15,401,336,14,62,338,21,1024,341,15,359,352,23,478,361,23,479,370,23,480,379,23,483,388,23,482,397,23,481,403,23,1004,410,22,288,414,23,1007,418,23,1009,422,23,1008,426,23,1010,430,23,1006,434,23,1005,456,14,63,458,21,1025,468,15,361,472,22,289,473,22,290,480,23,485,484,23,484,490,23,1012,494,23,1011,500,15,360,506,23,1015,512,23,1013,526,23,1014,553,16,1000,576,16,984,590,16,988,611,16,987,624,16,985,634,16,990,644,16,993,659,16,991,671,16,998,678,16,997,683,16,999,697,16,994,726,16,996,738,16,986,748,16,983,760,16,980,768,16,981,774,16,982,780,16,10,794,9,657,815,9,656,821,9,655,826,9,654,838,16,661,844,16,659,848,16,660,878,12,52,881,9,178,885,9,179,889,12,46,891,9,160,894,9,162,897,9,161,900,9,159,904,15,400]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/EventLoopFuture+Deprecated.swift","symbols":[17,16,764,23,16,742,31,16,746,37,16,755,43,16,734,49,16,737,57,16,766,63,16,751,71,16,749]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/EventLoopFuture+WithEventLoop.swift","symbols":[42,16,729,75,16,730,113,16,731]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/EventLoopFuture.swift","symbols":[153,14,96,156,15,408,181,16,772,190,16,771,203,16,768,222,16,769,379,19,121,385,15,407,435,23,1021,472,16,765,508,16,743,541,16,747,586,16,756,611,16,735,646,16,738,677,16,767,725,16,733,745,16,732,760,16,736,790,16,752,832,16,750,862,16,763,885,16,740,897,16,739,918,16,758,961,16,757,1010,23,498,1040,23,497,1081,23,489,1096,23,490,1116,23,493,1130,23,494,1225,23,491,1241,23,492,1265,23,495,1280,23,496,1372,16,754,1393,16,759,1421,16,761,1442,16,762,1466,16,760,1490,16,741,1509,16,745,1527,16,744,1540,16,748]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/FileDescriptor.swift","symbols":[14,16,11,25,9,662,28,8,402,31,9,663]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/FileHandle.swift","symbols":[31,19,119,32,28,368,37,11,207,52,16,618,64,16,615,73,16,617,81,16,616,91,18,68,92,19,367,94,15,208,112,26,322,114,26,323,118,18,69,122,26,324,128,27,486,138,27,487,149,23,209,158,23,210,166,15,366]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/FileRegion.swift","symbols":[33,14,61,36,15,354,42,28,356,52,15,358,62,11,201,71,15,357,76,25,596,88,11,202,100,23,1003,106,15,355]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/IO.swift","symbols":[23,14,116,25,16,56,26,13,187,27,13,186,34,15,474,49,15,475,77,11,273,88,11,274,109,15,472,113,15,473]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/IOData.swift","symbols":[18,12,54,20,9,184,26,9,185,35,15,460,45,25,953,58,15,459]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/Interfaces.swift","symbols":[54,19,124,60,15,432,63,15,433,66,15,434,70,15,428,75,15,431,78,15,430,81,15,427,128,15,429,137,23,1023,166,14,98,170,15,417,181,15,418,192,15,419,204,15,413,217,15,416,228,15,415,239,15,412,276,11,247,289,11,246,451,15,414,460,23,1022,471,16,796]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/MarkedCircularBuffer.swift","symbols":[19,14,104,28,11,259,36,25,837,42,25,832,48,25,839,61,15,440,67,15,442,73,15,439,78,15,436,86,25,833,97,16,831,109,15,438,120,15,437,126,15,441,132,21,1079,133,21,1078,134,21,1077,137,16,834,142,15,435,145,15,443,149,11,282,159,11,281,177,16,836,182,16,838,187,16,835]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/MulticastChannel.swift","symbols":[18,16,12,25,9,783,37,9,784,48,9,782,56,9,780,68,9,781,79,9,779,85,16,792,89,16,794,97,16,793,104,16,791,110,16,787,114,16,789,122,16,788,129,16,786,146,16,790,159,16,785,166,14,110,167,15,454,169,11,266,175,14,112,176,11,269]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/NIOAny.swift","symbols":[44,14,115,52,11,272,260,15,461]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/NIOCloseOnErrorHandler.swift","symbols":[16,19,129,18,21,1083,21,11,263,23,16,928]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/RecvByteBufferAllocator.swift","symbols":[15,16,21,17,9,929,24,18,930,30,14,113,31,15,458,33,11,270,38,25,945,43,16,944,49,14,111,50,15,457,51,15,456,52,15,455,59,11,268,63,11,267,78,16,942,82,25,943]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/SingleStepByteToMessageDecoder.swift","symbols":[21,16,25,24,19,36,35,18,947,50,18,946,56,25,949,65,25,948,186,19,130,208,11,271,285,16,952,297,16,951]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/SocketAddresses.swift","symbols":[34,12,49,36,9,173,38,9,171,40,9,170,42,9,172,47,18,102,48,19,426,50,15,253,57,12,43,60,18,71,64,19,373,67,19,372,75,18,72,79,19,375,82,19,374,90,18,73,94,19,376,102,9,155,105,9,156,108,9,154,111,15,377,143,15,379,148,15,382,160,15,371,179,15,380,209,15,381,229,16,619,245,11,215,254,11,216,262,11,217,270,11,219,278,11,218,288,11,212,314,11,213,358,11,214,388,23,488,452,23,1016,498,16,620,537,15,378]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/SocketOptionProvider.swift","symbols":[46,16,16,48,8,444,64,13,848,80,9,847,95,13,846,110,9,845,139,16,851,147,16,850,157,16,853,165,16,852,175,16,855,183,16,854,193,16,858,201,16,856,211,16,859,219,16,857,229,16,862,237,16,860,247,16,863,255,16,861,266,20,849]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/TypeAssistedChannelHandler.swift","symbols":[37,16,17,39,19,33,42,19,34,46,9,884,50,9,883,56,16,886,61,16,885,69,16,19,71,19,35,75,9,904,81,16,905,87,17,1075]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/UniversalBootstrapSupport.swift","symbols":[16,16,24,34,9,938,42,9,937,49,9,935,60,9,936,68,9,941,75,9,940,82,9,939,141,14,107,142,15,452,154,11,262,190,16,898,200,16,896,207,16,897,218,16,902,227,16,901,236,16,900,242,16,903,248,16,15,249,19,32,251,9,844,254,14,97,255,11,245,257,16,795]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-nio@2.40.0/.build/checkouts/swift-nio/Sources/NIOCore/Utilities.swift","symbols":[54,12,55,64,22,343,115,23,501,145,23,500]}]}