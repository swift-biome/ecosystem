{"culture":"OrderedCollections","dependencies":[],"extensions":[],"partitions":[{"namespace":"OrderedCollections","communities":[{"community":"struct","startIndex":0,"endIndex":9},{"community":"init","startIndex":9,"endIndex":40},{"community":"subscript","startIndex":40,"endIndex":51},{"community":"property","startIndex":51,"endIndex":98},{"community":"method","startIndex":98,"endIndex":310},{"community":"type.op","startIndex":310,"endIndex":316},{"community":"typealias","startIndex":316,"endIndex":338}]}],"identifiers":["s18OrderedCollections0A10DictionaryV","s18OrderedCollections0A10DictionaryV6ValuesV","s18OrderedCollections0A10DictionaryV8ElementsV","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV8IteratorV","s18OrderedCollections0A10DictionaryV8IteratorV","s18OrderedCollections0A3SetV","s18OrderedCollections0A3SetV11SubSequenceV","s18OrderedCollections0A3SetV13UnorderedViewV","s18OrderedCollections0A10DictionaryV10uniqueKeys6valuesACyxq_Gqd___qd_0_tc7ElementQyd__RszAGQyd_0_Rs_STRd__STRd_0_r0_lufc","s18OrderedCollections0A10DictionaryV15minimumCapacity10persistentACyxq_GSi_Sbtcfc","s18OrderedCollections0A10DictionaryV17dictionaryLiteralACyxq_Gx_q_td_tcfc","s18OrderedCollections0A10DictionaryV19uncheckedUniqueKeys6valuesACyxq_Gqd___qd_0_tc7ElementQyd__RszAGQyd_0_Rs_STRd__STRd_0_r0_lufc","s18OrderedCollections0A10DictionaryV20uniqueKeysWithValuesACyxq_Gqd___tcSTRd__x3key_q_5valuet7ElementRtd__lufc","s18OrderedCollections0A10DictionaryV20uniqueKeysWithValuesACyxq_Gqd___tcSTRd__x_q_t7ElementRtd__lufc","s18OrderedCollections0A10DictionaryV29uncheckedUniqueKeysWithValuesACyxq_Gqd___tcSTRd__x3key_q_5valuet7ElementRtd__lufc","s18OrderedCollections0A10DictionaryV29uncheckedUniqueKeysWithValuesACyxq_Gqd___tcSTRd__x_q_t7ElementRtd__lufc","s18OrderedCollections0A10DictionaryV8grouping2byACyxq_Gqd___x7ElementQy_KXEtKcSmR_STRd__AGQyd__AHRSlufc","s18OrderedCollections0A10DictionaryVAASeRzSeR_rlE4fromACyxq_Gs7Decoder_p_tKcfc","s18OrderedCollections0A10DictionaryVACyxq_Gycfc","s18OrderedCollections0A10DictionaryV_16uniquingKeysWithACyxq_Gqd___q_q__q_tKXEtKcSTRd__x3key_q_5valuet7ElementRtd__lufc","s18OrderedCollections0A10DictionaryV_16uniquingKeysWithACyxq_Gqd___q_q__q_tKXEtKcSTRd__x_q_t7ElementRtd__lufc","s18OrderedCollections0A3SetV12arrayLiteralACyxGxd_tcfc","s18OrderedCollections0A3SetV13UnorderedViewV12arrayLiteralAEyx_Gxd_tcfc","s18OrderedCollections0A3SetV13UnorderedViewVAEyx_Gycfc","s18OrderedCollections0A3SetV13UnorderedViewVyAEyx_GAFcfc","s18OrderedCollections0A3SetV13UnorderedViewVyAEyx_GSD4KeysVyxqd___Gclufc","s18OrderedCollections0A3SetV13UnorderedViewVyAEyx_GShyxGcfc","s18OrderedCollections0A3SetV13UnorderedViewVyAEyx_Gqd__c7ElementQyd__RszSTRd__lufc","s18OrderedCollections0A3SetV15minimumCapacity10persistentACyxGSi_Sbtcfc","s18OrderedCollections0A3SetV23uncheckedUniqueElementsACyxGqd___tc7ElementQyd__RszSTRd__lufc","s18OrderedCollections0A3SetVAASeRzrlE4fromACyxGs7Decoder_p_tKcfc","s18OrderedCollections0A3SetVACyxGycfc","s18OrderedCollections0A3SetVyACyxGAC11SubSequenceVyx_Gcfc","s18OrderedCollections0A3SetVyACyxGAC13UnorderedViewVyx_Gcfc","s18OrderedCollections0A3SetVyACyxGADcfc","s18OrderedCollections0A3SetVyACyxGSD4KeysVyxqd___Gclufc","s18OrderedCollections0A3SetVyACyxGShyxGcfc","s18OrderedCollections0A3SetVyACyxGqd__c7ElementQyd__RszSTRd__lufc","s18OrderedCollections0A3SetVyACyxGqd__c7ElementQyd__RszSkRd__lufc","s18OrderedCollections0A10DictionaryV6ValuesVyq_Sicip","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceVyAGyxq___GSnySiGcip","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceVyx3key_q_5valuetSicip","s18OrderedCollections0A10DictionaryV8ElementsVyAE11SubSequenceVyxq___GSnySiGcip","s18OrderedCollections0A10DictionaryV8ElementsVyx3key_q_5valuetSicip","s18OrderedCollections0A10DictionaryV_7defaultq_x_q_yXKtcip","s18OrderedCollections0A10DictionaryVyq_Sgxcip","s18OrderedCollections0A3SetV11SubSequenceVyAEyx_GSnySiGcip","s18OrderedCollections0A3SetV11SubSequenceVyxSicip","s18OrderedCollections0A3SetVyAC11SubSequenceVyx_GSnySiGcip","s18OrderedCollections0A3SetVyxSicip","s18OrderedCollections0A10DictionaryV11descriptionSSvp","s18OrderedCollections0A10DictionaryV12customMirrors0E0Vvp","s18OrderedCollections0A10DictionaryV16debugDescriptionSSvp","s18OrderedCollections0A10DictionaryV19underestimatedCountSivp","s18OrderedCollections0A10DictionaryV4keysAA0A3SetVyxGvp","s18OrderedCollections0A10DictionaryV5countSivp","s18OrderedCollections0A10DictionaryV6ValuesV10startIndexSivp","s18OrderedCollections0A10DictionaryV6ValuesV8elementsSayq_Gvp","s18OrderedCollections0A10DictionaryV6ValuesV8endIndexSivp","s18OrderedCollections0A10DictionaryV6valuesAC6ValuesVyxq__Gvp","s18OrderedCollections0A10DictionaryV7isEmptySbvp","s18OrderedCollections0A10DictionaryV8ElementsV10startIndexSivp","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV10startIndexSivp","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV4keysAA0A3SetVAFVyx_Gvp","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV5countSivp","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV6valuess5SliceVyAC6ValuesVyxq__GGvp","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV7indicesSnySiGvp","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV7isEmptySbvp","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV8endIndexSivp","s18OrderedCollections0A10DictionaryV8ElementsV11descriptionSSvp","s18OrderedCollections0A10DictionaryV8ElementsV12customMirrors0F0Vvp","s18OrderedCollections0A10DictionaryV8ElementsV16debugDescriptionSSvp","s18OrderedCollections0A10DictionaryV8ElementsV19underestimatedCountSivp","s18OrderedCollections0A10DictionaryV8ElementsV4keysAA0A3SetVyxGvp","s18OrderedCollections0A10DictionaryV8ElementsV5countSivp","s18OrderedCollections0A10DictionaryV8ElementsV6valuesAC6ValuesVyxq__Gvp","s18OrderedCollections0A10DictionaryV8ElementsV7isEmptySbvp","s18OrderedCollections0A10DictionaryV8ElementsV8endIndexSivp","s18OrderedCollections0A10DictionaryV8elementsAC8ElementsVyxq__Gvp","s18OrderedCollections0A3SetV10startIndexSivp","s18OrderedCollections0A3SetV11SubSequenceV10startIndexSivp","s18OrderedCollections0A3SetV11SubSequenceV5countSivp","s18OrderedCollections0A3SetV11SubSequenceV7indicesSnySiGvp","s18OrderedCollections0A3SetV11SubSequenceV7isEmptySbvp","s18OrderedCollections0A3SetV11SubSequenceV8endIndexSivp","s18OrderedCollections0A3SetV11descriptionSSvp","s18OrderedCollections0A3SetV12customMirrors0E0Vvp","s18OrderedCollections0A3SetV13UnorderedViewV11descriptionSSvp","s18OrderedCollections0A3SetV13UnorderedViewV12customMirrors0G0Vvp","s18OrderedCollections0A3SetV13UnorderedViewV16debugDescriptionSSvp","s18OrderedCollections0A3SetV16debugDescriptionSSvp","s18OrderedCollections0A3SetV5countSivp","s18OrderedCollections0A3SetV7indicesSnySiGvp","s18OrderedCollections0A3SetV7isEmptySbvp","s18OrderedCollections0A3SetV8elementsSayxGvp","s18OrderedCollections0A3SetV8endIndexSivp","s18OrderedCollections0A3SetV9unorderedAC13UnorderedViewVyx_Gvp","s18OrderedCollections0A10DictionaryV10removeLastx3key_q_5valuetyF","s18OrderedCollections0A10DictionaryV10removeLastyySiF","s18OrderedCollections0A10DictionaryV11removeFirstx3key_q_5valuetyF","s18OrderedCollections0A10DictionaryV11removeFirstyySiF","s18OrderedCollections0A10DictionaryV11removeValue6forKeyq_Sgx_tF","s18OrderedCollections0A10DictionaryV11updateValue6forKey16insertingDefault2at4withqd__x_q_yXKSiqd__q_zKXEtKlF","s18OrderedCollections0A10DictionaryV11updateValue6forKey7default4withqd__x_q_yXKqd__q_zKXEtKlF","s18OrderedCollections0A10DictionaryV11updateValue_6forKey11insertingAtq_Sg14originalMember_Si5indextq__xSitF","s18OrderedCollections0A10DictionaryV11updateValue_6forKeyq_Sgq__xtF","s18OrderedCollections0A10DictionaryV12makeIteratorAC0E0Vyxq__GyF","s18OrderedCollections0A10DictionaryV14removeSubrangeyySnySiGF","s18OrderedCollections0A10DictionaryV14removeSubrangeyyqd__SXRd__Si5BoundRtd__lF","s18OrderedCollections0A10DictionaryV15reserveCapacityyySiF","s18OrderedCollections0A10DictionaryV16compactMapValuesyACyxqd__Gqd__Sgq_KXEKlF","s18OrderedCollections0A10DictionaryV4sort2byySbx3key_q_5valuet_xAF_q_AGttKXE_tKF","s18OrderedCollections0A10DictionaryV5index6forKeySiSgx_tF","s18OrderedCollections0A10DictionaryV5merge_16uniquingKeysWithyqd__n_q_q__q_tKXEtKSTRd__x3key_q_5valuet7ElementRtd__lF","s18OrderedCollections0A10DictionaryV5merge_16uniquingKeysWithyqd__n_q_q__q_tKXEtKSTRd__x_q_t7ElementRtd__lF","s18OrderedCollections0A10DictionaryV6ValuesV23withUnsafeBufferPointeryqd__qd__SRyq_GKXEKlF","s18OrderedCollections0A10DictionaryV6ValuesV30withUnsafeMutableBufferPointeryqd__qd__Sryq_GzKXEKlF","s18OrderedCollections0A10DictionaryV6ValuesV32withContiguousStorageIfAvailableyqd__Sgqd__SRyq_GKXEKlF","s18OrderedCollections0A10DictionaryV6ValuesV39withContiguousMutableStorageIfAvailableyqd__Sgqd__Sryq_GzKXEKlF","s18OrderedCollections0A10DictionaryV6ValuesV5index5afterS2i_tF","s18OrderedCollections0A10DictionaryV6ValuesV5index6beforeS2i_tF","s18OrderedCollections0A10DictionaryV6ValuesV5index_8offsetBy07limitedG0SiSgSi_S2itF","s18OrderedCollections0A10DictionaryV6ValuesV5index_8offsetByS2i_SitF","s18OrderedCollections0A10DictionaryV6ValuesV6swapAtyySi_SitF","s18OrderedCollections0A10DictionaryV6ValuesV8distance4from2toS2i_SitF","s18OrderedCollections0A10DictionaryV6ValuesV9formIndex5afterySiz_tF","s18OrderedCollections0A10DictionaryV6ValuesV9formIndex6beforeySiz_tF","s18OrderedCollections0A10DictionaryV6ValuesV9partition2bySiSbq_KXE_tKF","s18OrderedCollections0A10DictionaryV6ValuesVAASHR_rlE4hash4intoys6HasherVz_tF","s18OrderedCollections0A10DictionaryV6filteryACyxq_GSbx3key_q_5valuet_tKXEKF","s18OrderedCollections0A10DictionaryV6remove2atx3key_q_5valuetSi_tF","s18OrderedCollections0A10DictionaryV6swapAtyySi_SitF","s18OrderedCollections0A10DictionaryV7merging_16uniquingKeysWithACyxq_Gqd__n_q_q__q_tKXEtKSTRd__x3key_q_5valuet7ElementRtd__lF","s18OrderedCollections0A10DictionaryV7merging_16uniquingKeysWithACyxq_Gqd__n_q_q__q_tKXEtKSTRd__x_q_t7ElementRtd__lF","s18OrderedCollections0A10DictionaryV7reverseyyF","s18OrderedCollections0A10DictionaryV7shuffle5usingyqd__z_tSGRd__lF","s18OrderedCollections0A10DictionaryV7shuffleyyF","s18OrderedCollections0A10DictionaryV8ElementsV10removeLastx3key_q_5valuetyF","s18OrderedCollections0A10DictionaryV8ElementsV10removeLastyySiF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV12makeIteratorAG0H0Vyxq____GyF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV5index5afterS2i_tF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV5index6beforeS2i_tF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV5index6forKeySiSgx_tF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV5index_8offsetBy07limitedI0SiSgSi_S2itF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV5index_8offsetByS2i_SitF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV8IteratorV4nextx3key_q_5valuetSgyF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV8distance4from2toS2i_SitF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV9formIndex5afterySiz_tF","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV9formIndex6beforeySiz_tF","s18OrderedCollections0A10DictionaryV8ElementsV11removeFirstx3key_q_5valuetyF","s18OrderedCollections0A10DictionaryV8ElementsV11removeFirstyySiF","s18OrderedCollections0A10DictionaryV8ElementsV12makeIteratorAC0F0Vyxq__GyF","s18OrderedCollections0A10DictionaryV8ElementsV14removeSubrangeyySnySiGF","s18OrderedCollections0A10DictionaryV8ElementsV14removeSubrangeyyqd__SXRd__Si5BoundRtd__lF","s18OrderedCollections0A10DictionaryV8ElementsV4sort2byySbx3key_q_5valuet_xAH_q_AIttKXE_tKF","s18OrderedCollections0A10DictionaryV8ElementsV5index5afterS2i_tF","s18OrderedCollections0A10DictionaryV8ElementsV5index6beforeS2i_tF","s18OrderedCollections0A10DictionaryV8ElementsV5index6forKeySiSgx_tF","s18OrderedCollections0A10DictionaryV8ElementsV5index_8offsetBy07limitedG0SiSgSi_S2itF","s18OrderedCollections0A10DictionaryV8ElementsV5index_8offsetByS2i_SitF","s18OrderedCollections0A10DictionaryV8ElementsV6remove2atx3key_q_5valuetSi_tF","s18OrderedCollections0A10DictionaryV8ElementsV6swapAtyySi_SitF","s18OrderedCollections0A10DictionaryV8ElementsV7reverseyyF","s18OrderedCollections0A10DictionaryV8ElementsV7shuffle5usingyqd__z_tSGRd__lF","s18OrderedCollections0A10DictionaryV8ElementsV7shuffleyyF","s18OrderedCollections0A10DictionaryV8ElementsV8distance4from2toS2i_SitF","s18OrderedCollections0A10DictionaryV8ElementsV9formIndex5afterySiz_tF","s18OrderedCollections0A10DictionaryV8ElementsV9formIndex6beforeySiz_tF","s18OrderedCollections0A10DictionaryV8ElementsV9partition2bySiSbx3key_q_5valuet_tKXE_tKF","s18OrderedCollections0A10DictionaryV8ElementsV9removeAll15keepingCapacityySb_tF","s18OrderedCollections0A10DictionaryV8ElementsV9removeAll5whereySbx3key_q_5valuet_tKXE_tKF","s18OrderedCollections0A10DictionaryV8ElementsVAASHR_rlE4hash4intoys6HasherVz_tF","s18OrderedCollections0A10DictionaryV8ElementsVAASLRzrlE4sortyyF","s18OrderedCollections0A10DictionaryV8IteratorV4nextx3key_q_5valuetSgyF","s18OrderedCollections0A10DictionaryV9mapValuesyACyxqd__Gqd__q_KXEKlF","s18OrderedCollections0A10DictionaryV9partition2bySiSbx3key_q_5valuet_tKXE_tKF","s18OrderedCollections0A10DictionaryV9removeAll15keepingCapacityySb_tF","s18OrderedCollections0A10DictionaryV9removeAll5whereySbx3key_q_5valuet_tKXE_tKF","s18OrderedCollections0A10DictionaryVAASERzSER_rlE6encode2toys7Encoder_p_tKF","s18OrderedCollections0A10DictionaryVAASHR_rlE4hash4intoys6HasherVz_tF","s18OrderedCollections0A10DictionaryVAASLRzrlE4sortyyF","s18OrderedCollections0A3SetV10difference4froms20CollectionDifferenceVyxGACyxG_tF","s18OrderedCollections0A3SetV10firstIndex2ofSiSgx_tF","s18OrderedCollections0A3SetV10isDisjoint4withSbAC13UnorderedViewVyx_G_tF","s18OrderedCollections0A3SetV10isDisjoint4withSbACyxG_tF","s18OrderedCollections0A3SetV10isDisjoint4withSbShyxG_tF","s18OrderedCollections0A3SetV10isDisjoint4withSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV10isSuperset2ofSbAC13UnorderedViewVyx_G_tF","s18OrderedCollections0A3SetV10isSuperset2ofSbACyxG_tF","s18OrderedCollections0A3SetV10isSuperset2ofSbShyxG_tF","s18OrderedCollections0A3SetV10isSuperset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV10removeLastxyF","s18OrderedCollections0A3SetV10removeLastyySiF","s18OrderedCollections0A3SetV11SubSequenceV32withContiguousStorageIfAvailableyqd__Sgqd__SRyxGKXEKlF","s18OrderedCollections0A3SetV11SubSequenceV4hash4intoys6HasherVz_tF","s18OrderedCollections0A3SetV11SubSequenceV5index5afterS2i_tF","s18OrderedCollections0A3SetV11SubSequenceV5index6beforeS2i_tF","s18OrderedCollections0A3SetV11SubSequenceV5index_8offsetBy07limitedH0SiSgSi_S2itF","s18OrderedCollections0A3SetV11SubSequenceV5index_8offsetByS2i_SitF","s18OrderedCollections0A3SetV11SubSequenceV8distance4from2toS2i_SitF","s18OrderedCollections0A3SetV11SubSequenceV9formIndex5afterySiz_tF","s18OrderedCollections0A3SetV11SubSequenceV9formIndex6beforeySiz_tF","s18OrderedCollections0A3SetV11removeFirstxyF","s18OrderedCollections0A3SetV11removeFirstyySiF","s18OrderedCollections0A3SetV11subtractingyACyxGAC13UnorderedViewVyx_GF","s18OrderedCollections0A3SetV11subtractingyACyxGAEF","s18OrderedCollections0A3SetV11subtractingyACyxGqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV12intersectionyACyxGAC13UnorderedViewVyx_GF","s18OrderedCollections0A3SetV12intersectionyACyxGAEF","s18OrderedCollections0A3SetV12intersectionyACyxGqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV10isDisjoint4withSbAEyx_G_tF","s18OrderedCollections0A3SetV13UnorderedViewV10isDisjoint4withSbShyxG_tF","s18OrderedCollections0A3SetV13UnorderedViewV10isDisjoint4withSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV10isSuperset2ofSbAEyx_G_tF","s18OrderedCollections0A3SetV13UnorderedViewV10isSuperset2ofSbShyxG_tF","s18OrderedCollections0A3SetV13UnorderedViewV10isSuperset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV11subtractingyAEyx_GAGF","s18OrderedCollections0A3SetV13UnorderedViewV11subtractingyAEyx_Gqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV12intersectionyAEyx_GAGF","s18OrderedCollections0A3SetV13UnorderedViewV12intersectionyAEyx_Gqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV14isStrictSubset2ofSbAEyx_G_tF","s18OrderedCollections0A3SetV13UnorderedViewV14isStrictSubset2ofSbShyxG_tF","s18OrderedCollections0A3SetV13UnorderedViewV14isStrictSubset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV16formIntersectionyyAEyx_GF","s18OrderedCollections0A3SetV13UnorderedViewV16formIntersectionyyqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV16isStrictSuperset2ofSbAEyx_G_tF","s18OrderedCollections0A3SetV13UnorderedViewV16isStrictSuperset2ofSbShyxG_tF","s18OrderedCollections0A3SetV13UnorderedViewV16isStrictSuperset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV19symmetricDifferenceyAEyx_GAGnF","s18OrderedCollections0A3SetV13UnorderedViewV19symmetricDifferenceyAEyx_Gqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV23formSymmetricDifferenceyyAEyx_GnF","s18OrderedCollections0A3SetV13UnorderedViewV23formSymmetricDifferenceyyqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV4hash4intoys6HasherVz_tF","s18OrderedCollections0A3SetV13UnorderedViewV5unionyAEyx_GAGnF","s18OrderedCollections0A3SetV13UnorderedViewV5unionyAEyx_Gqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV6insertySb8inserted_x17memberAfterInserttxnF","s18OrderedCollections0A3SetV13UnorderedViewV6removeyxSgxF","s18OrderedCollections0A3SetV13UnorderedViewV6update4withxSgxn_tF","s18OrderedCollections0A3SetV13UnorderedViewV8containsySbxF","s18OrderedCollections0A3SetV13UnorderedViewV8isSubset2ofSbAEyx_G_tF","s18OrderedCollections0A3SetV13UnorderedViewV8isSubset2ofSbShyxG_tF","s18OrderedCollections0A3SetV13UnorderedViewV8isSubset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV8subtractyyAEyx_GF","s18OrderedCollections0A3SetV13UnorderedViewV8subtractyyqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV13UnorderedViewV9formUnionyyAEyx_GnF","s18OrderedCollections0A3SetV13UnorderedViewV9formUnionyyqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV14isStrictSubset2ofSbAC13UnorderedViewVyx_G_tF","s18OrderedCollections0A3SetV14isStrictSubset2ofSbACyxG_tF","s18OrderedCollections0A3SetV14isStrictSubset2ofSbShyxG_tF","s18OrderedCollections0A3SetV14isStrictSubset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV14removeSubrangeyySnySiGF","s18OrderedCollections0A3SetV14removeSubrangeyyqd__SXRd__Si5BoundRtd__lF","s18OrderedCollections0A3SetV14updateOrAppendyxSgxF","s18OrderedCollections0A3SetV14updateOrInsert_2atxSg14originalMember_Si5indextx_SitF","s18OrderedCollections0A3SetV15reserveCapacityyySiF","s18OrderedCollections0A3SetV16formIntersectionyyAC13UnorderedViewVyx_GF","s18OrderedCollections0A3SetV16formIntersectionyyACyxGF","s18OrderedCollections0A3SetV16formIntersectionyyqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV16isStrictSuperset2ofSbAC13UnorderedViewVyx_G_tF","s18OrderedCollections0A3SetV16isStrictSuperset2ofSbACyxG_tF","s18OrderedCollections0A3SetV16isStrictSuperset2ofSbShyxG_tF","s18OrderedCollections0A3SetV16isStrictSuperset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV19symmetricDifferenceyACyxGAC13UnorderedViewVyx_GnF","s18OrderedCollections0A3SetV19symmetricDifferenceyACyxGAEnF","s18OrderedCollections0A3SetV19symmetricDifferenceyACyxGqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV23formSymmetricDifferenceyyAC13UnorderedViewVyx_GnF","s18OrderedCollections0A3SetV23formSymmetricDifferenceyyACyxGnF","s18OrderedCollections0A3SetV23formSymmetricDifferenceyyqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV32withContiguousStorageIfAvailableyqd__Sgqd__SRyxGKXEKlF","s18OrderedCollections0A3SetV4hash4intoys6HasherVz_tF","s18OrderedCollections0A3SetV4sort2byySbx_xtKXE_tKF","s18OrderedCollections0A3SetV5index5afterS2i_tF","s18OrderedCollections0A3SetV5index6beforeS2i_tF","s18OrderedCollections0A3SetV5index_8offsetBy07limitedF0SiSgSi_S2itF","s18OrderedCollections0A3SetV5index_8offsetByS2i_SitF","s18OrderedCollections0A3SetV5unionyACyxGAC13UnorderedViewVyx_GnF","s18OrderedCollections0A3SetV5unionyACyxGAEnF","s18OrderedCollections0A3SetV5unionyACyxGqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV6append10contentsOfyqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV6appendySb8inserted_Si5indextxF","s18OrderedCollections0A3SetV6insert_2atSb8inserted_Si5indextx_SitF","s18OrderedCollections0A3SetV6remove2atxSi_tF","s18OrderedCollections0A3SetV6removeyxSgxF","s18OrderedCollections0A3SetV6swapAtyySi_SitF","s18OrderedCollections0A3SetV6update_2atxx_SitF","s18OrderedCollections0A3SetV7reverseyyF","s18OrderedCollections0A3SetV7shuffle5usingyqd__z_tSGRd__lF","s18OrderedCollections0A3SetV7shuffleyyF","s18OrderedCollections0A3SetV8applyingyACyxGSgs20CollectionDifferenceVyxGF","s18OrderedCollections0A3SetV8containsySbxF","s18OrderedCollections0A3SetV8distance4from2toS2i_SitF","s18OrderedCollections0A3SetV8isSubset2ofSbAC13UnorderedViewVyx_G_tF","s18OrderedCollections0A3SetV8isSubset2ofSbACyxG_tF","s18OrderedCollections0A3SetV8isSubset2ofSbShyxG_tF","s18OrderedCollections0A3SetV8isSubset2ofSbqd___t7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV8subtractyyAC13UnorderedViewVyx_GF","s18OrderedCollections0A3SetV8subtractyyACyxGF","s18OrderedCollections0A3SetV8subtractyyqd__7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV9formIndex5afterySiz_tF","s18OrderedCollections0A3SetV9formIndex6beforeySiz_tF","s18OrderedCollections0A3SetV9formUnionyyAC13UnorderedViewVyx_GnF","s18OrderedCollections0A3SetV9formUnionyyACyxGnF","s18OrderedCollections0A3SetV9formUnionyyqd__n7ElementQyd__RszSTRd__lF","s18OrderedCollections0A3SetV9lastIndex2ofSiSgx_tF","s18OrderedCollections0A3SetV9partition2bySiSbxKXE_tKF","s18OrderedCollections0A3SetV9removeAll15keepingCapacityySb_tF","s18OrderedCollections0A3SetV9removeAll5whereySbxKXE_tKF","s18OrderedCollections0A3SetVAASERzrlE6encode2toys7Encoder_p_tKF","s18OrderedCollections0A3SetVAASLRzrlE4sortyyF","s18OrderedCollections0A10DictionaryV6ValuesVAASQR_rlE2eeoiySbAEyxq__G_AGtFZ","s18OrderedCollections0A10DictionaryV8ElementsVAASQR_rlE2eeoiySbAEyxq__G_AGtFZ","s18OrderedCollections0A10DictionaryVAASQR_rlE2eeoiySbACyxq_G_AEtFZ","s18OrderedCollections0A3SetV11SubSequenceV2eeoiySbAEyx_G_AGtFZ","s18OrderedCollections0A3SetV13UnorderedViewV2eeoiySbAEyx_G_AGtFZ","s18OrderedCollections0A3SetV2eeoiySbACyxG_AEtFZ","s18OrderedCollections0A10DictionaryV5Indexa","s18OrderedCollections0A10DictionaryV6ValuesV5Indexa","s18OrderedCollections0A10DictionaryV6ValuesV7Elementa","s18OrderedCollections0A10DictionaryV6ValuesV7Indicesa","s18OrderedCollections0A10DictionaryV6ValuesV8Iteratora","s18OrderedCollections0A10DictionaryV7Elementa","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV5Indexa","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV7Elementa","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceV7Indicesa","s18OrderedCollections0A10DictionaryV8ElementsV11SubSequenceVAFa","s18OrderedCollections0A10DictionaryV8ElementsV5Indexa","s18OrderedCollections0A10DictionaryV8ElementsV7Elementa","s18OrderedCollections0A10DictionaryV8ElementsV7Indicesa","s18OrderedCollections0A3SetV11SubSequenceV5Indexa","s18OrderedCollections0A3SetV11SubSequenceV7Elementa","s18OrderedCollections0A3SetV11SubSequenceV7Indicesa","s18OrderedCollections0A3SetV11SubSequenceV8Iteratora","s18OrderedCollections0A3SetV11SubSequenceVADa","s18OrderedCollections0A3SetV13UnorderedViewV7Elementa","s18OrderedCollections0A3SetV5Indexa","s18OrderedCollections0A3SetV7Indicesa","s18OrderedCollections0A3SetV8Iteratora","s18OrderedCollections0A10DictionaryV6ValuesV11SubSequencea","sSD","sSD4KeysV","sSE","sSE6encode2toys7Encoder_p_tKF","sSG","sSH","sSH4hash4intoys6HasherVz_tF","sSK","sSK12_RegexParserE10mapOffsetsySny5IndexQzGSi5lower_Si5uppert_tF","sSK12_RegexParserE14flatmapOffsetsySny5IndexQzGSi5lower_Si5uppertSgF","sSK17_StringProcessingSL7ElementRpzrlE10firstRange2ofSny5IndexQzGSgqd___tSlRd__ABQyd__ACRSlF","sSKs11SubSequenceQzRszrlE10removeLast7ElementQzyF","sSKs11SubSequenceQzRszrlE10removeLastyySiF","sSKs11SubSequenceQzRszrlE7popLast7ElementQzSgyF","sSKsE10difference4from2bys20CollectionDifferenceVy7ElementQzGqd___SbAG_AGtXEtSKRd__AFQyd__AGRSlF","sSKsE4last5where7ElementQzSgSbADKXE_tKF","sSKsE4last7ElementQzSgvp","sSKsE6suffixy11SubSequenceQzSiF","sSKsE8dropLasty11SubSequenceQzSiF","sSKsE8reverseds18ReversedCollectionVyxGyF","sSKsE9lastIndex5where0B0QzSgSb7ElementQzKXE_tKF","sSKsSQ7ElementRpzrlE10difference4froms20CollectionDifferenceVyABGqd___tSKRd__AAQyd__ABRSlF","sSKsSQ7ElementRpzrlE9lastIndex2of0C0QzSgAB_tF","sSKsSS7ElementRtzrlE6joined9separatorS2S_tF","sSL","sSM","sSM39withContiguousMutableStorageIfAvailableyqd__Sgqd__Sry7ElementQzGzKXEKlF","sSM6swapAtyy5IndexQz_ACtF","sSM9partition2by5IndexQzSb7ElementQzKXE_tKF","sSMsE39withContiguousMutableStorageIfAvailableyqd__Sgqd__Sry7ElementQzGzKXEKlF","sSMsE6swapAtyy5IndexQz_ACtF","sSMsE9partition2by5IndexQzSb7ElementQzKXE_tKF","sSMsEy11SubSequenceQzSny5IndexQzGcip","sSMsEy11SubSequenceQzqd__cSXRd__5BoundQyd__5IndexRtzluip","sSMsEy11SubSequenceQzys15UnboundedRange_OXEcip","sSMsEys5SliceVyxGSny5IndexQzGcip","sSMsSKRzrlE7reverseyyF","sSMsSKRzrlE9partition2by5IndexSlQzSb7ElementSTQzKXE_tKF","sSMsSkRzSL7ElementSTRpzrlE4sortyyF","sSMsSkRzrlE4sort2byySb7ElementSTQz_ADtKXE_tKF","sSMsSkRzrlE7shuffle5usingyqd__z_tSGRd__lF","sSMsSkRzrlE7shuffleyyF","sSMss5SliceVyxG11SubSequenceRtzrlEyACSny5IndexQzGcip","sSQ","sSQ2eeoiySbx_xtFZ","sSQsE2neoiySbx_xtFZ","sSR","sSS","sST","sST12_RegexParserE3allyS2b7ElementQzXEF","sST12_RegexParserE3anyyS2b7ElementQzXEF","sST12_RegexParserE4noneyS2b7ElementQzXEF","sST12makeIterator0B0QzyF","sST19underestimatedCountSivp","sST32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlF","sST7ElementQa","sST8IteratorQa","sSTsE10allSatisfyyS2b7ElementQzKXEKF","sSTsE10compactMapySayqd__Gqd__Sg7ElementQzKXEKlF","sSTsE10enumerateds18EnumeratedSequenceVyxGyF","sSTsE13elementsEqual_2bySbqd___Sb7ElementQz_ACQyd__tKXEtKSTRd__lF","sSTsE19underestimatedCountSivp","sSTsE25lexicographicallyPrecedes_2bySbqd___Sb7ElementQz_ADtKXEtKSTRd__ACQyd__ADRSlF","sSTsE32withContiguousStorageIfAvailableyqd__Sgqd__SRy7ElementQzGKXEKlF","sSTsE3mapySayqd__Gqd__7ElementQzKXEKlF","sSTsE3max2by7ElementQzSgSbAD_ADtKXE_tKF","sSTsE3min2by7ElementQzSgSbAD_ADtKXE_tKF","sSTsE4drop5whiles17DropWhileSequenceVyxGSb7ElementQzKXE_tKF","sSTsE4lazys12LazySequenceVyxGvp","sSTsE5first5where7ElementQzSgSbADKXE_tKF","sSTsE5split9maxSplits25omittingEmptySubsequences14whereSeparatorSays10ArraySliceVy7ElementQzGGSi_S2bAHKXEtKF","sSTsE6filterySay7ElementQzGSbACKXEKF","sSTsE6prefix5whileSay7ElementQzGSbADKXE_tKF","sSTsE6prefixys14PrefixSequenceVyxGSiF","sSTsE6reduce4into_qd__qd__n_yqd__z_7ElementQztKXEtKlF","sSTsE6reduceyqd__qd___qd__qd___7ElementQztKXEtKlF","sSTsE6sorted2bySay7ElementQzGSbAD_ADtKXE_tKF","sSTsE6starts4with2bySbqd___Sb7ElementQz_ADQyd__tKXEtKSTRd__lF","sSTsE6suffixySay7ElementQzGSiF","sSTsE7flatMapySay7ElementQyd__Gqd__ABQzKXEKSTRd__lF","sSTsE7flatMapySayqd__Gqd__Sg7ElementQzKXEKlF","sSTsE7forEachyyy7ElementQzKXEKF","sSTsE8contains5whereS2b7ElementQzKXE_tKF","sSTsE8dropLastySay7ElementQzGSiF","sSTsE8reversedSay7ElementQzGyF","sSTsE8shuffled5usingSay7ElementQzGqd__z_tSGRd__lF","sSTsE8shuffledSay7ElementQzGyF","sSTsE9dropFirstys04DropB8SequenceVyxGSiF","sSTsSL7ElementRpzrlE25lexicographicallyPrecedesySbqd__STRd__AAQyd__ABRSlF","sSTsSL7ElementRpzrlE3maxABSgyF","sSTsSL7ElementRpzrlE3minABSgyF","sSTsSL7ElementRpzrlE6sortedSayABGyF","sSTsSQ7ElementRpzrlE13elementsEqualySbqd__STRd__AAQyd__ABRSlF","sSTsSQ7ElementRpzrlE5split9separator9maxSplits25omittingEmptySubsequencesSays10ArraySliceVyABGGAB_SiSbtF","sSTsSQ7ElementRpzrlE6starts4withSbqd___tSTRd__AAQyd__ABRSlF","sSTsSQ7ElementRpzrlE8containsySbABF","sSTsST7ElementRpzrlE6joined9separators14JoinedSequenceVyxGqd___tSTRd__AA_AAQZAARtd__lF","sSTsST7ElementRpzrlE6joineds15FlattenSequenceVyxGyF","sSTsSy7ElementRpzrlE6joined9separatorS2S_tF","sSX","sSa","sSa11SubSequencea","sSb","sSe","sSe4fromxs7Decoder_p_tKcfc","sSh","sSi","sSk","sSk10startIndex0B0Qzvp","sSk11SubSequenceQa","sSk5IndexQa","sSk5index5after5IndexQzAD_tF","sSk5index6before5IndexQzAD_tF","sSk5index_8offsetBy07limitedC05IndexQzSgAE_SiAEtF","sSk5index_8offsetBy5IndexQzAD_SitF","sSk7IndicesQa","sSk7indices7IndicesQzvp","sSk8distance4from2toSi5IndexQz_AEtF","sSk8endIndex0B0Qzvp","sSk9formIndex5aftery0B0Qzz_tF","sSk9formIndex6beforey0B0Qzz_tF","sSky11SubSequenceQzSny5IndexQzGcip","sSky7ElementQz5IndexQzcip","sSl","sSl12_RegexParserE15convertByOffset_2in5IndexQyd__ADQz_qd__tSlRd__lF","sSl12_RegexParserE15convertByOffset_2inSny5IndexQyd__GSnyADQzG_qd__tSlRd__lF","sSl12_RegexParserE5index8atOffset5IndexQzSi_tF","sSl12_RegexParserE5split6around11SubSequenceQz6prefix_A2E6suffixtSny5IndexQzG_tF","sSl12_RegexParserE6offset2ofSi5IndexQz_tF","sSl12_RegexParserE6offset7ofIndexSi0E0Qz_tF","sSl12_RegexParserE7offsets2ofSnySiGSny5IndexQzG_tF","sSl12_RegexParserSQ7ElementRpzrlE13tryDropPrefixy11SubSequenceQzSgqd__SlRd__ABQyd__ACRSlF","sSl12_RegexParserSQ7ElementRpzrlE13tryDropSuffixy11SubSequenceQzSgqd__SlRd__ABQyd__ACRSlF","sSl17_StringProcessing11SubSequenceQzRszSQ7ElementRpzrlE10trimPrefixyyqd__STRd__ADQyd__AERSlF","sSl17_StringProcessing11SubSequenceQzRszrlE10trimPrefix5whileySb7ElementQzKXE_tKF","sSl17_StringProcessingE14trimmingPrefix5while11SubSequenceQzSb7ElementQzKXE_tKF","sSl17_StringProcessingSQ7ElementRpzrlE10firstRange2ofSny5IndexQzGSgqd___tSlRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE14trimmingPrefixy11SubSequenceQzqd__STRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE5split9separator9maxSplits25omittingEmptySubsequencesSay11SubSequenceQzGqd___SiSbtSlRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE6ranges2ofSaySny5IndexQzGGqd___tSlRd__ABQyd__ACRSlF","sSl17_StringProcessingSQ7ElementRpzrlE8containsySbqd__SlRd__ABQyd__ACRSlF","sSl5countSivp","sSl7isEmptySbvp","sSls11SubSequenceQzRszrlE11removeFirst7ElementQzyF","sSls11SubSequenceQzRszrlE11removeFirstyySiF","sSls11SubSequenceQzRszrlE8popFirst7ElementQzSgyF","sSlsE10firstIndex5where0B0QzSgSb7ElementQzKXE_tKF","sSlsE13randomElement0B0QzSgyF","sSlsE13randomElement5using0B0QzSgqd__z_tSGRd__lF","sSlsE19underestimatedCountSivp","sSlsE3mapySayqd__Gqd__7ElementQzKXEKlF","sSlsE4drop5while11SubSequenceQzSb7ElementQzKXE_tKF","sSlsE5countSivp","sSlsE5first7ElementQzSgvp","sSlsE5split9maxSplits25omittingEmptySubsequences14whereSeparatorSay11SubSequenceQzGSi_S2b7ElementQzKXEtKF","sSlsE6prefix4upTo11SubSequenceQz5IndexQz_tF","sSlsE6prefix5while11SubSequenceQzSb7ElementQzKXE_tKF","sSlsE6prefix7through11SubSequenceQz5IndexQz_tF","sSlsE6prefixy11SubSequenceQzSiF","sSlsE6suffix4from11SubSequenceQz5IndexQz_tF","sSlsE7isEmptySbvp","sSlsE9dropFirsty11SubSequenceQzSiF","sSlsE9formIndex_8offsetBy07limitedD0Sb0B0Qzz_SiAEtF","sSlsE9formIndex_8offsetByy0B0Qzz_SitF","sSlsEy11SubSequenceQzqd__cSXRd__5BoundQyd__5IndexRtzluip","sSlsEy11SubSequenceQzys15UnboundedRange_OXEcip","sSlsSQ7ElementRpzrlE10firstIndex2of0C0QzSgAB_tF","sSlsSQ7ElementRpzrlE5index2of5IndexQzSgAB_tF","sSlsSQ7ElementRpzrlE5split9separator9maxSplits25omittingEmptySubsequencesSay11SubSequenceQzGAB_SiSbtF","sSlss16IndexingIteratorVyxG0B0RtzrlE04makeB0ACyF","sSlss5SliceVyxG11SubSequenceRtzrlEyACSny5IndexQzGcip","sSm","sSn","sSr","sSt","sSt4next7ElementQzSgyF","ss10ArraySliceV7Indicesa","ss10SetAlgebraP","ss10SetAlgebraP10isDisjoint4withSbx_tF","ss10SetAlgebraP10isSuperset2ofSbx_tF","ss10SetAlgebraP11subtractingyxxF","ss10SetAlgebraP12intersectionyxxF","ss10SetAlgebraP16formIntersectionyyxF","ss10SetAlgebraP19symmetricDifferenceyxxnF","ss10SetAlgebraP23formSymmetricDifferenceyyxnF","ss10SetAlgebraP5unionyxxnF","ss10SetAlgebraP6insertySb8inserted_7ElementQz17memberAfterInserttAFnF","ss10SetAlgebraP6removey7ElementQzSgAEF","ss10SetAlgebraP6update4with7ElementQzSgAFn_tF","ss10SetAlgebraP7ElementQa","ss10SetAlgebraP8containsySb7ElementQzF","ss10SetAlgebraP8isSubset2ofSbx_tF","ss10SetAlgebraP8subtractyyxF","ss10SetAlgebraP9formUnionyyxnF","ss10SetAlgebraPs7ElementQz012ArrayLiteralC0RtzrlE05arrayE0xAFd_tcfc","ss10SetAlgebraPsE10isDisjoint4withSbx_tF","ss10SetAlgebraPsE10isSuperset2ofSbx_tF","ss10SetAlgebraPsE14isStrictSubset2ofSbx_tF","ss10SetAlgebraPsE16isStrictSuperset2ofSbx_tF","ss10SetAlgebraPsE7isEmptySbvp","ss10SetAlgebraPsE8isSubset2ofSbx_tF","ss10SetAlgebraPsE8subtractyyxF","ss10SetAlgebraPsEyxqd__ncSTRd__7ElementQyd__ACRtzlufc","ss10SetAlgebraPxycfc","ss10SetAlgebraPyxqd__ncSTRd__7ElementQyd__ACRtzlufc","ss16IndexingIteratorV","ss17CustomReflectableP","ss17CustomReflectableP12customMirrors0D0Vvp","ss20CollectionDifferenceV","ss23CustomStringConvertibleP","ss23CustomStringConvertibleP11descriptionSSvp","ss23CustomStringConvertibleP12_RegexParserE21halfWidthCornerQuotedSSvp","ss25ExpressibleByArrayLiteralP","ss25ExpressibleByArrayLiteralP05arrayD0x0cD7ElementQzd_tcfc","ss28CustomDebugStringConvertibleP","ss28CustomDebugStringConvertibleP16debugDescriptionSSvp","ss30ExpressibleByDictionaryLiteralP","ss30ExpressibleByDictionaryLiteralP010dictionaryD0x3KeyQz_5ValueQztd_tcfc","ss6HasherV","ss6MirrorV","ss7DecoderP","ss7EncoderP"],"vertices":[{"p":["OrderedDictionary"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["OrderedDictionary",7],["<",17],["Key",0],[", ",17],["Value",0],["> ",17],["where",12],[" ",17],["Key",18],[" : ",17],["Hashable",18,344]],"s":[["struct",12],[" ",17],["OrderedDictionary",7]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"An ordered collection of key-value pairs.\n\nLike the standard `Dictionary`, ordered dictionaries use a hash table to\nensure that no two entries have the same keys, and to efficiently look up\nvalues corresponding to specific keys. However, like an `Array` (and\nunlike `Dictionary`), ordered dictionaries maintain their elements in a\nparticular user-specified order, and they support efficient random-access\ntraversal of their entries.\n\n`OrderedDictionary` is a useful alternative to `Dictionary` when the order\nof elements is important, or when you need to be able to efficiently access\nelements at various positions within the collection.\n\nYou can create an ordered dictionary with any key type that conforms to the\n`Hashable` protocol.\n\n    let responses: OrderedDictionary = [\n      200: \"OK\",\n      403: \"Access forbidden\",\n      404: \"File not found\",\n      500: \"Internal server error\",\n    ]\n\n### Equality of Ordered Dictionaries\n\nTwo ordered dictionaries are considered equal if they contain the same\nelements, and *in the same order*. This matches the concept of equality of\nan `Array`, and it is different from the unordered `Dictionary`.\n\n    let a: OrderedDictionary = [1: \"one\", 2: \"two\"]\n    let b: OrderedDictionary = [2: \"two\", 1: \"one\"]\n    a == b // false\n    b.swapAt(0, 1) // `b` now has value [1: \"one\", 2: \"two\"]\n    a == b // true\n\n(`OrderedDictionary` only conforms to `Equatable` when its `Value` is\nequatable.)\n\n### Dictionary Operations\n\n`OrderedDictionary` provides many of the same operations as `Dictionary`.\n\nFor example, you can look up and add/remove values using the familiar\nkey-based subscript, returning an optional value:\n\n    var dictionary: OrderedDictionary<String, Int> = [:]\n    dictionary[\"one\"] = 1\n    dictionary[\"two\"] = 2\n    dictionary[\"three\"] // nil\n    // dictionary is now [\"one\": 1, \"two\": 2]\n\nIf a new entry is added using the subscript setter, it gets appended to the\nend of the dictionary. (So that by default, the dictionary contains its\nelements in the order they were originally inserted.)\n\n`OrderedDictionary` also implements the variant of this subscript that takes\na default value. Like with `Dictionary`, this is useful when you want to\nperform in-place mutations on values:\n\n    let text = \"short string\"\n    var counts: OrderedDictionary<Character, Int> = [:]\n    for character in text {\n      counts[character, default: 0] += 1\n    }\n    // counts is [\"s\": 2, \"h\": 1, \"o\": 1,\n    //            \"r\": 2, \"t\": 2, \" \": 1,\n    //            \"i\": 1, \"n\": 1, \"g\": 1]\n\nIf the `Value` type implements reference semantics, or when you need to\nperform a series of individual mutations on the values, the closure-based\n`updateValue(forKey:default:_:)` method provides an easier-to-use\nalternative to the defaulted key-based subscript.\n\n    let text = \"short string\"\n    var counts: OrderedDictionary<Character, Int> = [:]\n    for character in text {\n      counts.updateValue(forKey: character, default: 0) { value in\n        value += 1\n      }\n    }\n    // Same result as before\n\n(This isn't currently available on the regular `Dictionary`.)\n\nThe `Dictionary` type's original `updateValue(_:forKey:)` method is also\navailable, and so is `index(forKey:)`, grouping/uniquing initializers\n(`init(uniqueKeysWithValues:)`, `init(_:uniquingKeysWith:)`,\n`init(grouping:by:)`), methods for merging one dictionary with another\n(`merge`, `merging`), filtering dictionary entries (`filter(_:)`),\ntransforming values (`mapValues(_:)`), and a combination of these two\n(`compactMapValues(_:)`).\n\n### Sequence and Collection Operations\n\nOrdered dictionaries use integer indices representing offsets from the\nbeginning of the collection. However, to avoid ambiguity between key-based\nand indexing subscripts, `OrderedDictionary` doesn't directly conform to\n`Collection`. Instead, it only conforms to `Sequence`, and provides a\nrandom-access collection view over its key-value pairs:\n\n    responses[0] // `nil` (key-based subscript)\n    responses.elements[0] // `(200, \"OK\")` (index-based subscript)\n\nBecause ordered dictionaries need to maintain unique keys, neither\n`OrderedDictionary` nor its `elements` view can conform to the full\n`MutableCollection` or `RangeReplaceableCollection` protocols. However, they\nare able to partially implement requirements: they support mutations\nthat merely change the order of elements, or just remove a subset of\nexisting members:\n\n    // Permutation operations from MutableCollection:\n    func swapAt(_ i: Int, _ j: Int)\n    func partition(by predicate: (Element) throws -> Bool) -> rethrows Int\n    func sort() where Element: Comparable\n    func sort(by predicate: (Element, Element) throws -> Bool) rethrows\n    func shuffle()\n    func shuffle<T: RandomNumberGenerator>(using generator: inout T)\n\n    // Removal operations from RangeReplaceableCollection:\n    func removeAll(keepingCapacity: Bool = false)\n    func remove(at index: Int) -> Element\n    func removeSubrange(_ bounds: Range<Int>)\n    func removeLast() -> Element\n    func removeLast(_ n: Int)\n    func removeFirst() -> Element\n    func removeFirst(_ n: Int)\n    func removeAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows\n\n`OrderedDictionary` also implements `reserveCapacity(_)` from\n`RangeReplaceableCollection`, to allow for efficient insertion of a known\nnumber of elements. (However, unlike `Array` and `Dictionary`,\n`OrderedDictionary` does not provide a `capacity` property.)\n\n### Keys and Values Views\n\nLike the standard `Dictionary`, `OrderedDictionary` provides `keys` and\n`values` properties that provide lightweight views into the corresponding\nparts of the dictionary.\n\nThe `keys` collection is of type `OrderedSet<Key>`, containing all the keys\nin the original dictionary.\n\n    let d: OrderedDictionary = [2: \"two\", 1: \"one\", 0: \"zero\"]\n    d.keys // [2, 1, 0] as OrderedSet<Int>\n\nThe `keys` property is read-only, so you cannot mutate the dictionary\nthrough it. However, it returns an ordinary ordered set value, which can be\ncopied out and then mutated if desired. (Such mutations won't affect the\noriginal dictionary value.)\n\nThe `values` collection is a mutable random-access collection of the values\nin the dictionary:\n\n    d.values // \"two\", \"one\", \"zero\"\n    d.values[2] = \"nada\"\n    // `d` is now [2: \"two\", 1: \"one\", 0: \"nada\"]\n    d.values.sort()\n    // `d` is now [2: \"nada\", 1: \"one\", 0: \"two\"]\n\nBoth views store their contents in regular `Array` values, accessible\nthrough their `elements` property.\n\n## Performance\n\nLike the standard `Dictionary` type, the performance of hashing operations\nin `OrderedDictionary` is highly sensitive to the quality of hashing\nimplemented by the `Key` type. Failing to correctly implement hashing can\neasily lead to unacceptable performance, with the severity of the effect\nincreasing with the size of the hash table.\n\nIn particular, if a certain set of keys all produce the same hash value,\nthen hash table lookups regress to searching an element in an unsorted\narray, i.e., a linear operation. To ensure hashed collection types exhibit\ntheir target performance, it is important to ensure that such collisions\ncannot be induced merely by adding a particular list of keys to the\ndictionary.\n\nThe easiest way to achieve this is to make sure `Key` implements hashing\nfollowing `Hashable`'s documented best practices. The conformance must\nimplement the `hash(into:)` requirement, and every bit of information that\nis compared in `==` needs to be combined into the supplied `Hasher` value.\nWhen used correctly, `Hasher` produces high-quality, randomly seeded hash\nvalues that prevent repeatable hash collisions.\n\nWhen `Key` correctly conforms to `Hashable`, key-based lookups in an ordered\ndictionary is expected to take O(1) equality checks on average. Hash\ncollisions can still occur organically, so the worst-case lookup performance\nis technically still O(*n*) (where *n* is the size of the dictionary);\nhowever, long lookup chains are unlikely to occur in practice.\n\n## Implementation Details\n\nAn ordered dictionary consists of an ordered set of keys, alongside a\nregular `Array` value that contains their associated values."},{"p":["OrderedDictionary","Values"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["Values",7]],"s":[["struct",12],[" ",17],["Values",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"A view of an ordered dictionary's values as a standalone collection."},{"p":["OrderedDictionary","Elements"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["Elements",7]],"s":[["struct",12],[" ",17],["Elements",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"A view of the contents of an ordered dictionary as a random-access\ncollection."},{"p":["OrderedDictionary","Elements","SubSequence"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["SubSequence",7]],"s":[["struct",12],[" ",17],["SubSequence",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"A collection that represents a contiguous slice of an ordered dictionary.\n\nOrdered dictionary slices are random access collections that\nsupport efficient key-based lookups.","o":448},{"p":["OrderedDictionary","Elements","SubSequence","Iterator"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["Iterator",7]],"s":[["struct",12],[" ",17],["Iterator",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The type that allows iteration over the collection's elements.","o":395},{"p":["OrderedDictionary","Iterator"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["Iterator",7]],"s":[["struct",12],[" ",17],["Iterator",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The type that allows iteration over an ordered dictionary's elements.","o":395},{"p":["OrderedSet"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["OrderedSet",7],["<",17],["Element",0],["> ",17],["where",12],[" ",17],["Element",18],[" : ",17],["Hashable",18,344]],"s":[["struct",12],[" ",17],["OrderedSet",7]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"An ordered collection of unique elements.\n\nSimilar to the standard `Set`, ordered sets ensure that each element appears\nonly once in the collection, and they provide efficient tests for\nmembership. However, like `Array` (and unlike `Set`), ordered sets maintain\ntheir elements in a particular user-specified order, and they support\nefficient random-access traversal of their members.\n\n`OrderedSet` is a useful alternative to `Set` when the order of elements is\nimportant, or when you need to be able to efficiently access elements at\nvarious positions within the collection. It can also be used instead of an\n`Array` when each element needs to be unique, or when you need to be able to\nquickly determine if a value is a member of the collection.\n\nYou can create an ordered set with any element type that conforms to the\n`Hashable` protocol.\n\n    let buildingMaterials: OrderedSet = [\"straw\", \"sticks\", \"bricks\"]\n\n\n# Equality of Ordered Sets\n\nTwo ordered sets are considered equal if they contain the same elements, and\n*in the same order*. This matches the concept of equality of an `Array`, and\nit is different from the unordered `Set`.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 3, 2, 1]\n    a == b // false\n    b.sort() // `b` now has value [1, 2, 3, 4]\n    a == b // true\n\n# Set Operations\n\n`OrderedSet` implements most, but not all, `SetAlgebra` requirements. In\nparticular, it supports the membership test `contains(_:)` as well as all\nhigh-level set operations such as `union(_:)`, `intersection(_:)` or\n`isSubset(of:)`.\n\n    buildingMaterials.contains(\"glass\") // false\n    buildingMaterials.intersection([\"brick\", \"straw\"]) // [\"straw\", \"brick\"]\n\nOperations that return an ordered set usually preserve the ordering of\nelements in their input. For example, in the case of the `intersection` call\nabove, the ordering of elements in the result is guaranteed to match their\norder in the first input set, `buildingMaterials`.\n\nOn the other hand, predicates such as `isSubset(of:)` tend to ignore element\nordering:\n\n    let moreMaterials: OrderedSet = [\"bricks\", \"glass\", \"sticks\", \"straw\"]\n    buildingMaterials.isSubset(of: moreMaterials) // true\n\nHowever, `OrderedSet` does not implement `insert(_:)` nor `update(with:)` --\nit provides its own variants for insertion that are more explicit about\nwhere in the collection new elements gets inserted:\n\n    func insert(_ item: Element, at index: Int) -> (inserted: Bool, index: Int)\n    func append(_ item: Element) -> (inserted: Bool, index: Int)\n    func update(at index: Int, with item: Element) -> Element\n    func updateOrAppend(_ item: Element) -> Element?\n\nAdditionally,`OrderedSet` has an order-sensitive definition of equality (see\nabove) that is incompatible with `SetAlgebra`'s documented semantic\nrequirements. Accordingly, `OrderedSet` does not (cannot) itself conform to\n`SetAlgebra`.\n\n# Unordered Set View\n\nFor cases where `SetAlgebra` conformance is desired (such as when passing an\nordered set to a function that is generic over that protocol), `OrderedSet`\nprovides an efficient *unordered view* of its elements that conforms to\n`SetAlgebra`. The unordered view implements the same concept of equality as\nthe standard `Set`, ignoring element ordering.\n\n    var a: OrderedSet = [0, 1, 2, 3]\n    let b: OrderedSet = [3, 2, 1, 0]\n    a == b // false\n    a.unordered == b.unordered // true\n\n    func frobnicate<S: SetAlgebra>(_ set: S) { ... }\n    frobnicate(a) // error: `OrderedSet<String>` does not conform to `SetAlgebra`\n    frobnicate(a.unordered) // OK\n\nThe unordered view is mutable. Insertions into it implicitly append new\nelements to the end of the collection.\n\n    buildingMaterials.unordered.insert(\"glass\") // => inserted: true\n    // buildingMaterials is now [\"straw\", \"sticks\", \"brick\", \"glass\"]\n\nAccessing the unordered view is an efficient operation, with constant\n(minimal) overhead. Direct mutations of the unordered view (such as the\ninsertion above) are executed in place when possible. However, as usual with\ncopy-on-write collections, if you make a copy of the view (such as by\nextracting its value into a named variable), the resulting values will share\nthe same underlying storage, so mutations of either will incur a copy of the\nwhole set.\n\n# Sequence and Collection Operations\n\nOrdered sets are random-access collections. Members are assigned integer\nindices, with the first element always being at index `0`:\n\n    let buildingMaterials: OrderedSet = [\"straw\", \"sticks\", \"bricks\"]\n    buildingMaterials[1] // \"sticks\"\n    buildingMaterials.firstIndex(of: \"bricks\") // 2\n\n    for i in 0 ..< buildingMaterials.count {\n      print(\"Little piggie #\\(i) built a house of \\(buildingMaterials[i])\")\n    }\n    // Little piggie #0 built a house of straw\n    // Little piggie #1 built a house of sticks\n    // Little piggie #2 built a house of bricks\n\nBecause `OrderedSet` needs to keep its members unique, it cannot conform to\nthe full `MutableCollection` or `RangeReplaceableCollection` protocols.\nOperations such as `MutableCollection`'s subscript setter or\n`RangeReplaceableCollection`'s `replaceSubrange` assume the ability to\ninsert/replace arbitrary elements in the collection, but allowing that could\nlead to duplicate values.\n\nHowever, `OrderedSet` is able to partially implement these two protocols;\nnamely, there is no issue with mutation operations that merely change the\norder of elements, or just remove some subset of existing members:\n\n    // Permutation operations from MutableCollection:\n    func swapAt(_ i: Int, _ j: Int)\n    func partition(by predicate: (Element) throws -> Bool) -> rethrows Int\n    func sort() where Element: Comparable\n    func sort(by predicate: (Element, Element) throws -> Bool) rethrows\n    func shuffle()\n    func shuffle<T: RandomNumberGenerator>(using generator: inout T)\n    func reverse()\n\n    // Removal operations from RangeReplaceableCollection:\n    func removeAll(keepingCapacity: Bool = false)\n    func remove(at index: Int) -> Element\n    func removeSubrange(_ bounds: Range<Int>)\n    func removeLast() -> Element\n    func removeLast(_ n: Int)\n    func removeFirst() -> Element\n    func removeFirst(_ n: Int)\n    func removeAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows\n\n`OrderedSet` also implements `reserveCapacity(_)` from\n`RangeReplaceableCollection`, to allow for efficient insertion of a known\nnumber of elements. (However, unlike `Array` and `Set`, `OrderedSet` does\nnot provide a `capacity` property.)\n\n# Accessing The Contents of an Ordered Set as an Array\n\nIn cases where you need to pass the contents of an ordered set to a function\nthat only takes an array value or (or something that's generic over\n`RangeReplaceableCollection` or `MutableCollection`), then the best option\nis usually to directly extract the members of the `OrderedSet` as an `Array`\nvalue using its `elements` property. `OrderedSet` uses a standard array\nvalue for element storage, so extracting the array value has minimal\noverhead.\n\n    func pickyFunction(_ items: Array<Int>)\n\n    var set: OrderedSet = [0, 1, 2, 3]\n    pickyFunction(set) // error\n    pickyFunction(set.elements) // OK\n\nIt is also possible to mutate the set by updating the value of the\n`elements` property. This guarantees that direct mutations happen in place\nwhen possible (i.e., without spurious copy-on-write copies).\n\nHowever, the set needs to ensure the uniqueness of its members, so every\nupdate to `elements` includes a postprocessing step to detect and remove\nduplicates over the entire array. This can be slower than doing the\nequivalent updates with direct `OrderedSet` operations, so updating\n`elements` is best used in cases where direct implementations aren't\navailable -- for example, when you need to call a `MutableCollection`\nalgorithm that isn't directly implemented by `OrderedSet` itself.\n\n# Performance\n\nLike the standard `Set` type, the performance of hashing operations in\n`OrderedSet` is highly sensitive to the quality of hashing implemented by\nthe `Element` type. Failing to correctly implement hashing can easily lead\nto unacceptable performance, with the severity of the effect increasing with\nthe size of the hash table.\n\nIn particular, if a certain set of elements all produce the same hash value,\nthen hash table lookups regress to searching an element in an unsorted\narray, i.e., a linear operation. To ensure hashed collection types exhibit\ntheir target performance, it is important to ensure that such collisions\ncannot be induced merely by adding a particular list of members to the set.\n\nThe easiest way to achieve this is to make sure `Element` implements hashing\nfollowing `Hashable`'s documented best practices. The conformance must\nimplement the `hash(into:)` requirement, and every bit of information that\nis compared in `==` needs to be combined into the supplied `Hasher` value.\nWhen used correctly, `Hasher` produces high-quality, randomly seeded hash\nvalues that prevent repeatable hash collisions.\n\nWhen `Element` implements `Hashable` correctly, testing for membership in an\nordered set is expected to take O(1) equality checks on average. Hash\ncollisions can still occur organically, so the worst-case lookup performance\nis technically still O(*n*) (where *n* is the size of the set); however,\nlong lookup chains are unlikely to occur in practice.\n\n# Implementation Details\n\nAn `OrderedSet` stores its members in a regular `Array` value (exposed by\nthe `elements` property). It also maintains a standalone hash table\ncontaining array indices alongside the array; this is used to implement fast\nmembership tests. The size of the array is limited by the capacity of the\ncorresponding hash table, so indices stored inside the hash table can be\nencoded into fewer bits than a standard `Int` value, leading to a storage\nrepresentation that can often be more compact than that of `Set` itself.\n\nInserting or removing a single member (or a range of members) needs to\nperform the corresponding operation in the storage array, in addition to\nrenumbering any subsequent members in the hash table. Therefore, these\noperations are expected to have performance characteristics similar to an\n`Array`: inserting or removing an element to the end of an ordered set is\nexpected to execute in O(1) operations, while they are expected to take\nlinear time at the front (or in the middle) of the set. (Note that this is\ndifferent to the standard `Set`, where insertions and removals are expected\nto take amortized O(1) time.)"},{"p":["OrderedSet","SubSequence"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["SubSequence",7]],"s":[["struct",12],[" ",17],["SubSequence",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"A collection that represents a contiguous slice of an ordered set.\n\nOrdered set slices are random access collections that support efficient\nmembership testing. `contains(_:)` and `firstIndex(of:)`/`lastIndex(of:)`\nare expected to have a complexity of O(1), as long as `Element` has\nhigh-quality hashing.","o":448},{"p":["OrderedSet","UnorderedView"],"f":[["@frozen",3],[" ",17],["struct",12],[" ",17],["UnorderedView",7]],"s":[["struct",12],[" ",17],["UnorderedView",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"An unordered view into an ordered set, providing `SetAlgebra`\nconformance."},{"p":["OrderedDictionary","init(uniqueKeys:values:)"],"f":[["init",10],["<",17],["Keys",0],[", ",17],["Values",0],[">(",17],["uniqueKeys",1],[" ",17],["keys",2],[": ",17],["Keys",18],[", ",17],["values",1],[": ",17],["Values",18],[") ",17],["where",12],[" ",17],["Key",18],[" == ",17],["Keys",18],[".",17],["Element",18],[", ",17],["Value",18],[" == ",17],["Values",18],[".",17],["Element",18],[", ",17],["Keys",18],[" : ",17],["Sequence",18,387],[", ",17],["Values",18],[" : ",17],["Sequence",18,387]],"s":[["init",10],["<",17],["Keys",0],[", ",17],["Values",0],[">(",17],["uniqueKeys",1],[": ",17],["Keys",18],[", ",17],["values",1],[": ",17],["Values",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["Key",2,"Keys.Element"],["Value",2,"Values.Element"],["Keys",1,"Sequence",387],["Values",1,"Sequence",387]],"g":[["Key",0,0],["Value",1,0],["Keys",0,1],["Values",1,1]],"d":"Creates a new dictionary from separate sequences of keys and values.\n\nYou use this initializer to create a dictionary when you have two\nsequences with unique keys and their associated values, respectively.\nPassing a `keys` sequence with duplicate keys to this initializer results\nin a runtime error.\n\n- Parameter keys: A sequence of unique keys.\n\n- Parameter values: A sequence of values associated with items in `keys`.\n\n- Returns: A new dictionary initialized with the data in\n  `keys` and `values`.\n\n- Precondition: The sequence must not have duplicate keys, and `keys` and\n   `values` must contain an equal number of elements.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count if\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(minimumCapacity:persistent:)"],"f":[["init",10],["(",17],["minimumCapacity",1],[": ",17],["Int",18,445],[", ",17],["persistent",1],[": ",17],["Bool",18,441],[" = false)",17]],"s":[["init",10],["(",17],["minimumCapacity",1],[": ",17],["Int",18],[", ",17],["persistent",1],[": ",17],["Bool",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Creates an empty dictionary with preallocated space for at least the\nspecified number of elements.\n\nUse this initializer to avoid intermediate reallocations of a dictionary's\nstorage buffer when you know in advance how many elements you'll insert\ninto it after creation.\n\nIf you have a good idea of the expected working size of the dictionary,\ncalling this initializer with `persistent` set to true can sometimes\nimprove performance by eliminating churn due to repeated rehashings when\nthe dictionary temporarily shrinks below its regular size. You can cancel\nany capacity you've previously reserved by persistently reserving a\ncapacity of zero. (This also shrinks the hash table to the ideal size for\nits current number elements.)\n\n- Parameter minimumCapacity: The minimum number of elements that the newly\n  created dictionary should be able to store without reallocating its\n  storage.\n\n- Parameter persistent: If set to true, prevent removals from shrinking\n  storage below the specified capacity. By default, removals are allowed\n  to shrink storage below any previously reserved capacity.\n\n- Complexity: O(`minimumCapacity`)"},{"p":["OrderedDictionary","init(dictionaryLiteral:)"],"f":[["init",10],["(",17],["dictionaryLiteral",1],[" ",17],["elements",2],[": (",17],["Key",18],[", ",17],["Value",18],[")...)",17]],"s":[["init",10],["(",17],["dictionaryLiteral",1],[": (",17],["Key",18],[", ",17],["Value",18],[")...)",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Creates a new ordered dictionary from the contents of a dictionary\nliteral.\n\nDo not call this initializer directly. It is used by the compiler when you\nuse a dictionary literal. Instead, create a new ordered dictionary using a\ndictionary literal as its value by enclosing a comma-separated list of\nkey-value pairs in square brackets. You can use a dictionary literal\nanywhere an ordered dictionary is expected by the type context.\n\n- Parameter elements: A variadic list of key-value pairs for the new\n   ordered dictionary.\n\n- Complexity: O(`elements.count`) if `Key` implements\n   high-quality hashing.","o":556},{"p":["OrderedDictionary","init(uncheckedUniqueKeys:values:)"],"f":[["init",10],["<",17],["Keys",0],[", ",17],["Values",0],[">(",17],["uncheckedUniqueKeys",1],[" ",17],["keys",2],[": ",17],["Keys",18],[", ",17],["values",1],[": ",17],["Values",18],[") ",17],["where",12],[" ",17],["Key",18],[" == ",17],["Keys",18],[".",17],["Element",18],[", ",17],["Value",18],[" == ",17],["Values",18],[".",17],["Element",18],[", ",17],["Keys",18],[" : ",17],["Sequence",18,387],[", ",17],["Values",18],[" : ",17],["Sequence",18,387]],"s":[["init",10],["<",17],["Keys",0],[", ",17],["Values",0],[">(",17],["uncheckedUniqueKeys",1],[": ",17],["Keys",18],[", ",17],["values",1],[": ",17],["Values",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["Key",2,"Keys.Element"],["Value",2,"Values.Element"],["Keys",1,"Sequence",387],["Values",1,"Sequence",387]],"g":[["Key",0,0],["Value",1,0],["Keys",0,1],["Values",1,1]],"d":"Creates a new dictionary from separate sequences of unique keys and\nassociated values.\n\nIn optimized builds, this initializer does not verify that the keys are\nactually unique. This makes creating the dictionary somewhat faster if you\nknow for sure that the elements are unique (e.g., because they come from\nanother collection with guaranteed-unique members, such as a\n`Dictionary`). However, if you accidentally call this initializer with\nduplicate members, it can return a corrupt dictionary value that may be\ndifficult to debug.\n\n- Parameter keys: A sequence of unique keys.\n\n- Parameter values: A sequence of values associated with items in `keys`.\n\n- Returns: A new dictionary initialized with the data in\n  `keys` and `values`.\n\n- Precondition: The sequence must not have duplicate keys, and `keys` and\n   `values` must contain an equal number of elements.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count if\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(uniqueKeysWithValues:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["uniqueKeysWithValues",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (key",17],[": ",17],["Key",18],[", value",17],[": ",17],["Value",18],[")",17]],"s":[["init",10],["<",17],["S",0],[">(",17],["uniqueKeysWithValues",1],[": ",17],["S",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(key: Key, value: Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a new dictionary from the key-value pairs in the given sequence.\n\nYou use this initializer to create a dictionary when you have a sequence\nof key-value tuples with unique keys. Passing a sequence with duplicate\nkeys to this initializer results in a runtime error. If your\nsequence might have duplicate keys, use the\n`Dictionary(_:uniquingKeysWith:)` initializer instead.\n\n- Parameter keysAndValues: A sequence of key-value pairs to use for\n  the new dictionary. Every key in `keysAndValues` must be unique.\n\n- Returns: A new dictionary initialized with the elements of\n  `keysAndValues`.\n\n- Precondition: The sequence must not have duplicate keys.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count if\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(uniqueKeysWithValues:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["uniqueKeysWithValues",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (",17],["Key",18],[", ",17],["Value",18],[")",17]],"s":[["init",10],["<",17],["S",0],[">(",17],["uniqueKeysWithValues",1],[": ",17],["S",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(Key, Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a new dictionary from the key-value pairs in the given sequence.\n\nYou use this initializer to create a dictionary when you have a sequence\nof key-value tuples with unique keys. Passing a sequence with duplicate\nkeys to this initializer results in a runtime error. If your\nsequence might have duplicate keys, use the\n`Dictionary(_:uniquingKeysWith:)` initializer instead.\n\n- Parameter keysAndValues: A sequence of key-value pairs to use for\n  the new dictionary. Every key in `keysAndValues` must be unique.\n\n- Returns: A new dictionary initialized with the elements of\n  `keysAndValues`.\n\n- Precondition: The sequence must not have duplicate keys.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count if\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(uncheckedUniqueKeysWithValues:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["uncheckedUniqueKeysWithValues",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (key",17],[": ",17],["Key",18],[", value",17],[": ",17],["Value",18],[")",17]],"s":[["init",10],["<",17],["S",0],[">(",17],["uncheckedUniqueKeysWithValues",1],[": ",17],["S",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(key: Key, value: Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a new dictionary from the key-value pairs in the given sequence,\nwhich must not contain duplicate keys.\n\nIn optimized builds, this initializer does not verify that the keys are\nactually unique. This makes creating the dictionary somewhat faster if you\nknow for sure that the elements are unique (e.g., because they come from\nanother collection with guaranteed-unique members, such as a\n`Dictionary`). However, if you accidentally call this initializer with\nduplicate members, it can return a corrupt dictionary value that may be\ndifficult to debug.\n\n- Parameter keysAndValues: A sequence of key-value pairs to use for\n  the new dictionary. Every key in `keysAndValues` must be unique.\n\n- Returns: A new dictionary initialized with the elements of\n  `keysAndValues`.\n\n- Precondition: The sequence must not have duplicate keys.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count if\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(uncheckedUniqueKeysWithValues:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["uncheckedUniqueKeysWithValues",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (",17],["Key",18],[", ",17],["Value",18],[")",17]],"s":[["init",10],["<",17],["S",0],[">(",17],["uncheckedUniqueKeysWithValues",1],[": ",17],["S",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(Key, Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a new dictionary from the key-value pairs in the given sequence,\nwhich must not contain duplicate keys.\n\nIn optimized builds, this initializer does not verify that the keys are\nactually unique. This makes creating the dictionary somewhat faster if you\nknow for sure that the elements are unique (e.g., because they come from\nanother collection with guaranteed-unique members, such as a\n`Dictionary`). However, if you accidentally call this initializer with\nduplicate members, it can return a corrupt dictionary value that may be\ndifficult to debug.\n\n- Parameter keysAndValues: A sequence of key-value pairs to use for\n  the new dictionary. Every key in `keysAndValues` must be unique.\n\n- Returns: A new dictionary initialized with the elements of\n  `keysAndValues`.\n\n- Precondition: The sequence must not have duplicate keys.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count if\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(grouping:by:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["grouping",1],[" ",17],["values",2],[": ",17],["S",18],[", ",17],["by",1],[" ",17],["keyForValue",2],[": (",17],["S",18],[".",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Key",18],[") ",17],["rethrows",12],[" ",17],["where",12],[" ",17],["Value",18],[" : ",17],["RangeReplaceableCollection",18,510],[", ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["Value",18],[".",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18]],"s":[["init",10],["<",17],["S",0],[">(",17],["grouping",1],[": ",17],["S",18],[", ",17],["by",1],[": (",17],["S",18],[".",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Key",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["Value",1,"RangeReplaceableCollection",510],["S",1,"Sequence",387],["Value.Element",2,"S.Element"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a new dictionary whose keys are the groupings returned by the\ngiven closure and whose values are arrays of the elements that returned\neach key.\n\nThe arrays in the \"values\" position of the new dictionary each contain at\nleast one element, with the elements in the same order as the source\nsequence.\n\nThe following example declares an array of names, and then creates a\ndictionary from that array by grouping the names by first letter:\n\n    let students = [\"Kofi\", \"Abena\", \"Efua\", \"Kweku\", \"Akosua\"]\n    let studentsByLetter = OrderedDictionary(grouping: students, by: { $0.first! })\n    // [\"K\": [\"Kofi\", \"Kweku\"], \"A\": [\"Abena\", \"Akosua\"], \"E\": [\"Efua\"]]\n\nThe new `studentsByLetter` dictionary has three entries, with students'\nnames grouped by the keys `\"E\"`, `\"K\"`, and `\"A\"`.\n\n- Parameters:\n  - values: A sequence of values to group into a dictionary.\n  - keyForValue: A closure that returns a key for each element in\n    `values`.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count of\n   values, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(from:)"],"f":[["init",10],["(",17],["from",1],[" ",17],["decoder",2],[": ",17],["Decoder",18,559],[") ",17],["throws",12]],"s":[["init",10],["(",17],["from",1],[": ",17],["Decoder",18],[") ",17],["throws",12]],"e":[["Key",1,"Decodable",442],["Key",1,"Hashable",344],["Value",1,"Decodable",442]],"c":[["Key",1,"Decodable",442],["Key",1,"Hashable",344],["Value",1,"Decodable",442]],"g":[["Key",0,0],["Value",1,0]],"d":"Creates a new dictionary by decoding from the given decoder.\n\n`OrderedDictionary` expects its contents to be encoded as alternating\nkey-value pairs in an unkeyed container.\n\nThis initializer throws an error if reading from the decoder fails, or\nif the decoded contents are not in the expected format.\n\n- Note: Unlike the standard `Dictionary` type, ordered dictionaries\n   always encode themselves into an unkeyed container, because\n   `Codable`'s keyed containers do not guarantee that they preserve the\n   ordering of the items they contain. (And in popular encoding formats,\n   keyed containers tend to map to unordered data structures -- e.g.,\n   JSON's \"object\" construct is explicitly unordered.)\n\n- Parameter decoder: The decoder to read data from.","o":443},{"p":["OrderedDictionary","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Creates an empty dictionary.\n\nThis initializer is equivalent to initializing with an empty dictionary\nliteral.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","init(_:uniquingKeysWith:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["_",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[", ",17],["uniquingKeysWith",1],[" ",17],["combine",2],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (key",17],[": ",17],["Key",18],[", value",17],[": ",17],["Value",18],[")",17]],"s":[["init",10],["<",17],["S",0],[">(",17],["S",18],[", ",17],["uniquingKeysWith",1],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(key: Key, value: Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a new dictionary from the key-value pairs in the given sequence,\nusing a combining closure to determine the value for any duplicate keys.\n\nYou use this initializer to create a dictionary when you have a sequence\nof key-value tuples that might have duplicate keys. As the dictionary is\nbuilt, the initializer calls the `combine` closure with the current and\nnew values for any duplicate keys. Pass a closure as `combine` that\nreturns the value to use in the resulting dictionary: The closure can\nchoose between the two values, combine them to produce a new value, or\neven throw an error.\n\n    let pairsWithDuplicateKeys = [(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"b\", 4)]\n\n    let firstValues = OrderedDictionary(\n      pairsWithDuplicateKeys,\n      uniquingKeysWith: { (first, _) in first })\n    // [\"a\": 1, \"b\": 2]\n\n    let lastValues = OrderedDictionary(\n      pairsWithDuplicateKeys,\n      uniquingKeysWith: { (_, last) in last })\n    // [\"a\": 3, \"b\": 4]\n\n- Parameters:\n  - keysAndValues: A sequence of key-value pairs to use for the new\n    dictionary.\n  - combine: A closure that is called with the values for any duplicate\n    keys that are encountered. The closure returns the desired value for\n    the final dictionary.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count of\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","init(_:uniquingKeysWith:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["_",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[", ",17],["uniquingKeysWith",1],[" ",17],["combine",2],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (",17],["Key",18],[", ",17],["Value",18],[")",17]],"s":[["init",10],["<",17],["S",0],[">(",17],["S",18],[", ",17],["uniquingKeysWith",1],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(Key, Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a new dictionary from the key-value pairs in the given sequence,\nusing a combining closure to determine the value for any duplicate keys.\n\nYou use this initializer to create a dictionary when you have a sequence\nof key-value tuples that might have duplicate keys. As the dictionary is\nbuilt, the initializer calls the `combine` closure with the current and\nnew values for any duplicate keys. Pass a closure as `combine` that\nreturns the value to use in the resulting dictionary: The closure can\nchoose between the two values, combine them to produce a new value, or\neven throw an error.\n\n    let pairsWithDuplicateKeys = [(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"b\", 4)]\n\n    let firstValues = OrderedDictionary(\n      pairsWithDuplicateKeys,\n      uniquingKeysWith: { (first, _) in first })\n    // [\"a\": 1, \"b\": 2]\n\n    let lastValues = OrderedDictionary(\n      pairsWithDuplicateKeys,\n      uniquingKeysWith: { (_, last) in last })\n    // [\"a\": 3, \"b\": 4]\n\n- Parameters:\n  - keysAndValues: A sequence of key-value pairs to use for the new\n    dictionary.\n  - combine: A closure that is called with the values for any duplicate\n    keys that are encountered. The closure returns the desired value for\n    the final dictionary.\n\n- Complexity: Expected O(*n*) on average, where *n* is the count of\n   key-value pairs, if `Key` implements high-quality hashing."},{"p":["OrderedSet","init(arrayLiteral:)"],"f":[["init",10],["(",17],["arrayLiteral",1],[" ",17],["elements",2],[": ",17],["Element",18],["...)",17]],"s":[["init",10],["(",17],["arrayLiteral",1],[": ",17],["Element",18],["...)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new ordered set from the contents of an array literal.\n\nDuplicate elements in the literal are allowed, but the resulting ordered\nset will only contain the first occurrence of each.\n\nDo not call this initializer directly. It is used by the compiler when\nyou use an array literal. Instead, create a new ordered set using an array\nliteral as its value by enclosing a comma-separated list of values in\nsquare brackets. You can use an array literal anywhere an ordered set is\nexpected by the type context.\n\n- Parameter elements: A variadic list of elements of the new ordered set.\n\n- Complexity: O(`elements.count`) if `Element` implements\n   high-quality hashing.","o":552},{"p":["OrderedSet","UnorderedView","init(arrayLiteral:)"],"f":[["init",10],["(",17],["arrayLiteral",1],[" ",17],["elements",2],[": ",17],["Element",18],["...)",17]],"s":[["init",10],["(",17],["arrayLiteral",1],[": ",17],["Element",18],["...)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new unordered set from the contents of an array literal.","o":552},{"p":["OrderedSet","UnorderedView","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates an empty set.\n\nThis initializer is equivalent to initializing with an empty array\nliteral.","o":542},{"p":["OrderedSet","UnorderedView","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["elements",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["init",10],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new set from a an existing set. This is functionally the same as\ncopying the value of `elements` into a new variable.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: O(1)"},{"p":["OrderedSet","UnorderedView","init(_:)"],"f":[["init",10],["<",17],["Value",0],[">(",17],["_",1],[" ",17],["elements",2],[": ",17],["Dictionary",18,339],["<",17],["Element",18],[", ",17],["Value",18],[">.",17],["Keys",18,340],[")",17]],"s":[["init",10],["<",17],["Value",0],[">(",17],["Dictionary",18],["<",17],["Element",18],[", ",17],["Value",18],[">.",17],["Keys",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0],["Value",0,1]],"d":"Creates a new set from the keys of a dictionary value.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform O(*n*)\n   comparisons on average (where *n* is the number of elements\n   in the set), provided that `Element` implements high-quality\n   hashing."},{"p":["OrderedSet","UnorderedView","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["elements",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">)",17]],"s":[["init",10],["(",17],["Set",18],["<",17],["Element",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new set from an existing `Set` value.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform O(*n*)\n   comparisons on average (where *n* is the number of elements\n   in the set), provided that `Element` implements high-quality\n   hashing."},{"p":["OrderedSet","UnorderedView","init(_:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["_",1],[" ",17],["elements",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["init",10],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Creates a new set from a finite sequence of items.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform O(*n*)\n   comparisons on average (where *n* is the number of elements\n   in the sequence), provided that `Element` implements\n   high-quality hashing.","o":543},{"p":["OrderedSet","init(minimumCapacity:persistent:)"],"f":[["init",10],["(",17],["minimumCapacity",1],[": ",17],["Int",18,445],[", ",17],["persistent",1],[": ",17],["Bool",18,441],[" = false)",17]],"s":[["init",10],["(",17],["minimumCapacity",1],[": ",17],["Int",18],[", ",17],["persistent",1],[": ",17],["Bool",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates an empty set with preallocated space for at least the\nspecified number of elements.\n\nUse this initializer to avoid intermediate reallocations of a\nset's storage buffer when you know in advance how many elements\nyou'll insert into the set after creation.\n\nIf you have a good idea of the expected working size of the set, calling\nthis initializer with `persistent` set to true can sometimes improve\nperformance by eliminating churn due to repeated rehashings when the set\ntemporarily shrinks below its regular size.\n\n- Parameter minimumCapacity: The minimum number of elements that the newly\n  created set should be able to store without reallocating its storage.\n\n- Parameter persistent: If set to true, prevent removals from shrinking\n  storage below the specified capacity. By default, removals are allowed\n  to shrink storage below any previously reserved capacity.\n\n- Complexity: O(`minimumCapacity`)"},{"p":["OrderedSet","init(uncheckedUniqueElements:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["uncheckedUniqueElements",1],[" ",17],["elements",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["init",10],["<",17],["S",0],[">(",17],["uncheckedUniqueElements",1],[": ",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Creates a set with the contents of the given sequence, which\nmust not include duplicate elements.\n\nIn optimized builds, this initializer does not verify that the\nelements are actually unique. This makes creating the set\nsomewhat faster if you know for sure that the elements are\nunique (e.g., because they come from another collection with\nguaranteed-unique members, such as a `Set`). However, if you\naccidentally call this initializer with duplicate members, it\ncan return a corrupt set value that may be difficult to debug.\n\n- Parameter elements: A finite sequence of unique elements.\n\n- Complexity: Expected to be O(*n*) on average, where *n* is the\n   number of elements in the sequence, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","init(from:)"],"f":[["init",10],["(",17],["from",1],[" ",17],["decoder",2],[": ",17],["Decoder",18,559],[") ",17],["throws",12]],"s":[["init",10],["(",17],["from",1],[": ",17],["Decoder",18],[") ",17],["throws",12]],"e":[["Element",1,"Decodable",442],["Element",1,"Hashable",344]],"c":[["Element",1,"Decodable",442],["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new ordered set by decoding from the given decoder.\n\nThis initializer throws an error if reading from the decoder fails, or\nif the decoded contents contain duplicate values.\n\n- Parameter decoder: The decoder to read data from.","o":443},{"p":["OrderedSet","init()"],"f":[["init",10],["()",17]],"s":[["init",10],["()",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates an empty set.\n\nThis initializer is equivalent to initializing with an empty array\nliteral.\n\n- Complexity: O(1)"},{"p":["OrderedSet","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["elements",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7],[")",17]],"s":[["init",10],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["SubSequence",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new set from an existing slice of another set.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform\n   O(`elements.count`) operations on average, provided that\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["view",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["init",10],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Create a new ordered set with the same members as the supplied\nunordered view.\n\n- Complexity: O(1)"},{"p":["OrderedSet","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["elements",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">)",17]],"s":[["init",10],["(",17],["OrderedSet",18],["<",17],["Element",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new set from a an existing set. This is functionally the same as\ncopying the value of `elements` into a new variable.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: O(1)"},{"p":["OrderedSet","init(_:)"],"f":[["init",10],["<",17],["Value",0],[">(",17],["_",1],[" ",17],["elements",2],[": ",17],["Dictionary",18,339],["<",17],["Element",18],[", ",17],["Value",18],[">.",17],["Keys",18,340],[")",17]],"s":[["init",10],["<",17],["Value",0],[">(",17],["Dictionary",18],["<",17],["Element",18],[", ",17],["Value",18],[">.",17],["Keys",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0],["Value",0,1]],"d":"Creates a new set from the keys view of a dictionary.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform\n   O(`elements.count`) operations on average, provided that\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","init(_:)"],"f":[["init",10],["(",17],["_",1],[" ",17],["elements",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">)",17]],"s":[["init",10],["(",17],["Set",18],["<",17],["Element",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Creates a new set from an existing `Set` value.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform\n   O(`elements.count`) operations on average, provided that\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","init(_:)"],"f":[["init",10],["<",17],["S",0],[">(",17],["_",1],[" ",17],["elements",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["init",10],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Creates a new set from a finite sequence of items.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform O(*n*)\n   comparisons on average (where *n* is the number of elements\n   in the sequence), provided that `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","init(_:)"],"f":[["init",10],["<",17],["C",0],[">(",17],["_",1],[" ",17],["elements",2],[": ",17],["C",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["C",18],[".",17],["Element",18],[", ",17],["C",18],[" : ",17],["RandomAccessCollection",18,446]],"s":[["init",10],["<",17],["C",0],[">(",17],["C",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"C.Element"],["C",1,"RandomAccessCollection",446]],"g":[["Element",0,0],["C",0,1]],"d":"Creates a new set from a collection of items.\n\n- Parameter elements: The elements to use as members of the new set.\n\n- Complexity: This operation is expected to perform O(*n*)\n   comparisons on average (where *n* is the number of elements\n   in the sequence), provided that `Element` implements\n   high-quality hashing."},{"p":["OrderedDictionary","Values","subscript(_:)"],"f":[["subscript",10],["(",17],["position",2],[": ",17],["Int",18,445],[") -> ",17],["Value",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["Int",18],[") -> ",17],["Value",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Accesses the element at the specified position. This can be used to\nperform in-place mutations on dictionary values.\n\n- Parameter index: The position of the element to access. `index` must be\n  greater than or equal to `startIndex` and less than `endIndex`.\n\n- Complexity: O(1)","o":461},{"p":["OrderedDictionary","Elements","SubSequence","subscript(_:)"],"f":[["subscript",10],["(",17],["bounds",2],[": ",17],["Range",18,511],["<",17],["Int",18,445],[">) -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["SubSequence",18,3],[".",17],["SubSequence",18,325],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Range",18],["<",17],["Int",18],[">) -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["SubSequence",18],[".",17],["SubSequence",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Accesses a contiguous subrange of the dictionary's elements.\n\nThe returned `Subsequence` instance uses the same indices for the same\nelements as the original dictionary. In particular, that slice, unlike an\n`OrderedDictionary`, may have a nonzero `startIndex.offset` and an\n`endIndex.offset` that is not equal to `count`. Always use the slice's\n`startIndex` and `endIndex` properties instead of assuming that its\nindices start or end at a particular value.\n\n- Parameter bounds: A range of valid indices in the dictionary.\n\n- Complexity: O(1)","o":460},{"p":["OrderedDictionary","Elements","SubSequence","subscript(_:)"],"f":[["subscript",10],["(",17],["position",2],[": ",17],["Int",18,445],[") -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["SubSequence",18,3],[".",17],["Element",18,323],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Int",18],[") -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["SubSequence",18],[".",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Accesses the element at the specified position.\n\n- Parameter index: The position of the element to access. `index` must be\n  greater than or equal to `startIndex` and less than `endIndex`.\n\n- Complexity: O(1)","o":461},{"p":["OrderedDictionary","Elements","subscript(_:)"],"f":[["subscript",10],["(",17],["bounds",2],[": ",17],["Range",18,511],["<",17],["Int",18,445],[">) -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["SubSequence",18,3],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Range",18],["<",17],["Int",18],[">) -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["SubSequence",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Accesses a contiguous subrange of the dictionary's elements.\n\nThe returned `Subsequence` instance uses the same indices for the same\nelements as the original collection. In particular, the slice, unlike an\n`Elements`, may have a nonzero `startIndex` and an `endIndex` that is not\nequal to `count`. Always use the slice's `startIndex` and `endIndex`\nproperties instead of assuming that its indices start or end at a\nparticular value.\n\n- Parameter bounds: A range of valid indices in the collection.\n\n- Complexity: O(1)","o":460},{"p":["OrderedDictionary","Elements","subscript(_:)"],"f":[["subscript",10],["(",17],["position",2],[": ",17],["Int",18,445],[") -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Int",18],[") -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Accesses the element at the specified position.\n\n- Parameter index: The position of the element to access. `index` must be\n  greater than or equal to `startIndex` and less than `endIndex`.\n\n- Complexity: O(1)","o":461},{"p":["OrderedDictionary","subscript(_:default:)"],"f":[["subscript",10],["(",17],["key",2],[": ",17],["Key",18],[", ",17],["default",1],[" ",17],["defaultValue",2],[": ",17],["@autoclosure ",3],["() -> ",17],["Value",18],[") -> ",17],["Value",18],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["Key",18],[", ",17],["default",1],[" _: () -> ",17],["Value",18],[") -> ",17],["Value",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Accesses the value with the given key. If the dictionary doesn't contain\nthe given key, accesses the provided default value as if the key and\ndefault value existed in the dictionary.\n\nUse this subscript when you want either the value for a particular key\nor, when that key is not present in the dictionary, a default value. This\nexample uses the subscript with a message to use in case an HTTP response\ncode isn't recognized:\n\n    var responseMessages: OrderedDictionary = [\n        200: \"OK\",\n        403: \"Access forbidden\",\n        404: \"File not found\",\n        500: \"Internal server error\"]\n\n    let httpResponseCodes = [200, 403, 301]\n    for code in httpResponseCodes {\n        let message = responseMessages[code, default: \"Unknown response\"]\n        print(\"Response \\(code): \\(message)\")\n    }\n    // Prints \"Response 200: OK\"\n    // Prints \"Response 403: Access forbidden\"\n    // Prints \"Response 301: Unknown response\"\n\nWhen a dictionary's `Value` type has value semantics, you can use this\nsubscript to perform in-place operations on values in the dictionary.\nThe following example uses this subscript while counting the occurrences\nof each letter in a string:\n\n    let message = \"Hello, Elle!\"\n    var letterCounts: [Character: Int] = [:]\n    for letter in message {\n        letterCounts[letter, default: 0] += 1\n    }\n    // letterCounts == [\"H\": 1, \"e\": 2, \"l\": 4, \"o\": 1, ...]\n\nWhen `letterCounts[letter, defaultValue: 0] += 1` is executed with a\nvalue of `letter` that isn't already a key in `letterCounts`, the\nspecified default value (`0`) is returned from the subscript,\nincremented, and then added to the dictionary under that key.\n\n- Note: Do not use this subscript to modify dictionary values if the\n  dictionary's `Value` type is a class. In that case, the default value\n  and key are not written back to the dictionary after an operation. (For\n  a variant of this operation that supports this usecase, see\n  `updateValue(forKey:default:_:)`.)\n\n- Parameters:\n  - key: The key the look up in the dictionary.\n  - defaultValue: The default value to use if `key` doesn't exist in the\n    dictionary.\n\n- Returns: The value associated with `key` in the dictionary; otherwise,\n  `defaultValue`.\n\n- Complexity: Looking up values in the dictionary through this subscript\n   has an expected complexity of O(1) hashing/comparison operations on\n   average, if `Key` implements high-quality hashing. Updating the\n   dictionary also has an amortized expected complexity of O(1) --\n   although individual updates may need to copy or resize the dictionary's\n   underlying storage."},{"p":["OrderedDictionary","subscript(_:)"],"f":[["subscript",10],["(",17],["key",2],[": ",17],["Key",18],[") -> ",17],["Value",18],["? { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["subscript",10],["(",17],["Key",18],[") -> ",17],["Value",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Accesses the value associated with the given key for reading and writing.\n\nThis *key-based* subscript returns the value for the given key if the key\nis found in the dictionary, or `nil` if the key is not found.\n\nThe following example creates a new dictionary and prints the value of a\nkey found in the dictionary (`\"Coral\"`) and a key not found in the\ndictionary (`\"Cerise\"`).\n\n    var hues: OrderedDictionary = [\"Heliotrope\": 296, \"Coral\": 16, \"Aquamarine\": 156]\n    print(hues[\"Coral\"])\n    // Prints \"Optional(16)\"\n    print(hues[\"Cerise\"])\n    // Prints \"nil\"\n\nWhen you assign a value for a key and that key already exists, the\ndictionary overwrites the existing value. If the dictionary doesn't\ncontain the key, the key and value are added as a new key-value pair.\n\nHere, the value for the key `\"Coral\"` is updated from `16` to `18` and a\nnew key-value pair is added for the key `\"Cerise\"`.\n\n    hues[\"Coral\"] = 18\n    print(hues[\"Coral\"])\n    // Prints \"Optional(18)\"\n\n    hues[\"Cerise\"] = 330\n    print(hues[\"Cerise\"])\n    // Prints \"Optional(330)\"\n\nIf you assign `nil` as the value for the given key, the dictionary\nremoves that key and its associated value.\n\nIn the following example, the key-value pair for the key `\"Aquamarine\"`\nis removed from the dictionary by assigning `nil` to the key-based\nsubscript.\n\n    hues[\"Aquamarine\"] = nil\n    print(hues)\n    // Prints \"[\"Coral\": 18, \"Heliotrope\": 296, \"Cerise\": 330]\"\n\n- Parameter key: The key to find in the dictionary.\n\n- Returns: The value associated with `key` if `key` is in the dictionary;\n  otherwise, `nil`.\n\n- Complexity: Looking up values in the dictionary through this subscript\n   has an expected complexity of O(1) hashing/comparison operations on\n   average, if `Key` implements high-quality hashing. Updating the\n   dictionary also has an amortized expected complexity of O(1) --\n   although individual updates may need to copy or resize the dictionary's\n   underlying storage."},{"p":["OrderedSet","SubSequence","subscript(_:)"],"f":[["subscript",10],["(",17],["bounds",2],[": ",17],["Range",18,511],["<",17],["Int",18,445],[">) -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7],[".",17],["SubSequence",18,333],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Range",18],["<",17],["Int",18],[">) -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["SubSequence",18],[".",17],["SubSequence",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Accesses a contiguous subrange of the set's elements.\n\nThe returned `Subsequence` instance uses the same indices for the same\nelements as the original set. In particular, that slice, unlike an\n`OrderedSet`, may have a nonzero `startIndex` and an `endIndex` that is\nnot equal to `count`. Always use the slice's `startIndex` and `endIndex`\nproperties instead of assuming that its indices start or end at a\nparticular value.\n\n- Parameter bounds: A range of valid indices in the set.\n\n- Complexity: O(1)","o":460},{"p":["OrderedSet","SubSequence","subscript(_:)"],"f":[["subscript",10],["(",17],["position",2],[": ",17],["Int",18,445],[") -> ",17],["Element",18],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Int",18],[") -> ",17],["Element",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Accesses the element at the specified position.\n\n- Parameter index: The position of the element to access. `index` must be\n  greater than or equal to `startIndex` and less than `endIndex`.\n\n- Complexity: O(1)","o":461},{"p":["OrderedSet","subscript(_:)"],"f":[["subscript",10],["(",17],["bounds",2],[": ",17],["Range",18,511],["<",17],["Int",18,445],[">) -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Range",18],["<",17],["Int",18],[">) -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["SubSequence",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Accesses a contiguous subrange of the set's elements.\n\nThe returned `Subsequence` instance uses the same indices for the same\nelements as the original set. In particular, that slice, unlike an\n`OrderedSet`, may have a nonzero `startIndex` and an `endIndex` that is\nnot equal to `count`. Always use the slice's `startIndex` and `endIndex`\nproperties instead of assuming that its indices start or end at a\nparticular value.\n\n- Parameter bounds: A range of valid indices in the set.\n\n- Complexity: O(1)","o":460},{"p":["OrderedSet","subscript(_:)"],"f":[["subscript",10],["(",17],["position",2],[": ",17],["Int",18,445],[") -> ",17],["Element",18],[" { ",17],["get",12],[" }",17]],"s":[["subscript",10],["(",17],["Int",18],[") -> ",17],["Element",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Accesses the element at the specified position.\n\n- Parameter index: The position of the element to access. `index` must be\n  greater than or equal to `startIndex` and less than `endIndex`.\n\n- Complexity: O(1)","o":461},{"p":["OrderedDictionary","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"e":[["Key",1,"Hashable",344]],"d":"A textual representation of this instance.","o":549},{"p":["OrderedDictionary","customMirror"],"f":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18,558],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18]],"e":[["Key",1,"Hashable",344]],"d":"The custom mirror for this instance.","o":546},{"p":["OrderedDictionary","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]],"e":[["Key",1,"Hashable",344]],"d":"A textual representation of this instance, suitable for debugging.","o":554},{"p":["OrderedDictionary","underestimatedCount"],"f":[["var",12],[" ",17],["underestimatedCount",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["underestimatedCount",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The number of elements in the collection.\n\n- Complexity: O(1)","o":392},{"p":["OrderedDictionary","keys"],"f":[["var",12],[" ",17],["keys",7],[": ",17],["OrderedSet",18,6],["<",17],["Key",18],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["keys",7],[": ",17],["OrderedSet",18],["<",17],["Key",18],[">",17]],"e":[["Key",1,"Hashable",344]],"d":"A read-only collection view for the keys contained in this dictionary, as\nan `OrderedSet`.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The number of elements in the dictionary.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","Values","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The position of the first element in a nonempty dictionary.\n\nFor an instance of `OrderedDictionary.Values`, `startIndex` is always\nzero. If the dictionary is empty, `startIndex` is equal to `endIndex`.\n\n- Complexity: O(1)","o":447},{"p":["OrderedDictionary","Values","elements"],"f":[["var",12],[" ",17],["elements",7],[": ",17],["Array",18,439],["<",17],["Value",18],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["elements",7],[": ",17],["Array",18],["<",17],["Value",18],[">",17]],"e":[["Key",1,"Hashable",344]],"d":"A read-only view of the contents of this collection as an array value.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","Values","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The collection's \"past the end\" position---that is, the position one\ngreater than the last valid subscript argument.\n\nIn `OrderedDictionary.Values`, `endIndex` always equals the count of\nelements. If the dictionary is empty, `endIndex` is equal to `startIndex`.\n\n- Complexity: O(1)","o":457},{"p":["OrderedDictionary","values"],"f":[["var",12],[" ",17],["values",7],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["values",7],[": ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18]],"e":[["Key",1,"Hashable",344]],"d":"A mutable collection view containing the values in this dictionary.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,441],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"e":[["Key",1,"Hashable",344]],"d":"A Boolean value indicating whether the dictionary is empty.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","Elements","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The position of the first element in a nonempty dictionary.\n\nFor an instance of `OrderedDictionary.Elements`, `startIndex` is always\nzero. If the dictionary is empty, `startIndex` is equal to `endIndex`.\n\n- Complexity: O(1)","o":447},{"p":["OrderedDictionary","Elements","SubSequence","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The position of the first element in a nonempty ordered dictionary slice.\n\nNote that instances of `OrderedDictionary.SubSequence` generally\ndon't have a `startIndex` with an offset of zero.\n\n- Complexity: O(1)","o":447},{"p":["OrderedDictionary","Elements","SubSequence","keys"],"f":[["var",12],[" ",17],["keys",7],[": ",17],["OrderedSet",18,6],["<",17],["Key",18],[">.",17],["SubSequence",18,7],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["keys",7],[": ",17],["OrderedSet",18],["<",17],["Key",18],[">.",17],["SubSequence",18]],"e":[["Key",1,"Hashable",344]],"d":"A read-only collection view containing the keys in this slice.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","Elements","SubSequence","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The number of elements in the dictionary.\n\n- Complexity: O(1)","o":480},{"p":["OrderedDictionary","Elements","SubSequence","values"],"f":[["var",12],[" ",17],["values",7],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[".",17],["SubSequence",18,338],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["values",7],[": ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18],[".",17],["SubSequence",18]],"e":[["Key",1,"Hashable",344]],"d":"A read-only collection view containing the values in this slice.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","Elements","SubSequence","indices"],"f":[["var",12],[" ",17],["indices",7],[": ",17],["Range",18,511],["<",17],["Int",18,445],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["indices",7],[": ",17],["Range",18],["<",17],["Int",18],[">",17]],"e":[["Key",1,"Hashable",344]],"d":"The indices that are valid for subscripting the collection,\nin ascending order.\n\n- Complexity: O(1)","o":455},{"p":["OrderedDictionary","Elements","SubSequence","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,441],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"e":[["Key",1,"Hashable",344]],"d":"A Boolean value indicating whether the collection is empty.\n\n- Complexity: O(1)","o":481},{"p":["OrderedDictionary","Elements","SubSequence","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The \"past the end\" position---that is, the position one greater\nthan the last valid subscript argument.\n\n- Complexity: O(1)","o":457},{"p":["OrderedDictionary","Elements","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"e":[["Key",1,"Hashable",344]],"o":549},{"p":["OrderedDictionary","Elements","customMirror"],"f":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18,558],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18]],"e":[["Key",1,"Hashable",344]],"o":546},{"p":["OrderedDictionary","Elements","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]],"e":[["Key",1,"Hashable",344]],"o":554},{"p":["OrderedDictionary","Elements","underestimatedCount"],"f":[["var",12],[" ",17],["underestimatedCount",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["underestimatedCount",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"o":392},{"p":["OrderedDictionary","Elements","keys"],"f":[["var",12],[" ",17],["keys",7],[": ",17],["OrderedSet",18,6],["<",17],["Key",18],["> { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["keys",7],[": ",17],["OrderedSet",18],["<",17],["Key",18],[">",17]],"e":[["Key",1,"Hashable",344]],"d":"A read-only collection view containing the keys in this collection.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","Elements","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The number of elements in the dictionary.\n\n- Complexity: O(1)","o":480},{"p":["OrderedDictionary","Elements","values"],"f":[["var",12],[" ",17],["values",7],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["values",7],[": ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18]],"e":[["Key",1,"Hashable",344]],"d":"A mutable collection view containing the values in this collection.\n\n- Complexity: O(1)"},{"p":["OrderedDictionary","Elements","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,441],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"e":[["Key",1,"Hashable",344]],"d":"A Boolean value indicating whether the collection is empty.\n\n- Complexity: O(1)","o":481},{"p":["OrderedDictionary","Elements","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"d":"The collection's \"past the end\" position---that is, the position one\ngreater than the last valid subscript argument.\n\nIn `OrderedDictionary.Elements`, `endIndex` always equals the count of\nelements. If the dictionary is empty, `endIndex` is equal to `startIndex`.\n\n- Complexity: O(1)","o":457},{"p":["OrderedDictionary","elements"],"f":[["var",12],[" ",17],["elements",7],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["elements",7],[": ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18]],"e":[["Key",1,"Hashable",344]],"d":"A view of the contents of this dictionary as a random-access collection.\n\n- Complexity: O(1)"},{"p":["OrderedSet","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"d":"The position of the first element in a nonempty ordered set.\n\nFor an instance of `OrderedSet`, `startIndex` is always zero. If the set\nis empty, `startIndex` is equal to `endIndex`.\n\n- Complexity: O(1)","o":447},{"p":["OrderedSet","SubSequence","startIndex"],"f":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["startIndex",7],[": ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"d":"The position of the first element in a nonempty ordered set slice.\n\nNote that instances of `OrderedSet.SubSequence` generally aren't indexed\nfrom zero.\n\n- Complexity: O(1)","o":447},{"p":["OrderedSet","SubSequence","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"d":"The number of elements in the set.\n\n- Complexity: O(1)","o":480},{"p":["OrderedSet","SubSequence","indices"],"f":[["var",12],[" ",17],["indices",7],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7],[".",17],["Indices",18,331],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["indices",7],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["SubSequence",18],[".",17],["Indices",18]],"e":[["Element",1,"Hashable",344]],"d":"The indices that are valid for subscripting the collection, in ascending\norder.\n\n- Complexity: O(1)","o":455},{"p":["OrderedSet","SubSequence","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,441],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"d":"A Boolean value indicating whether the collection is empty.\n\n- Complexity: O(1)","o":481},{"p":["OrderedSet","SubSequence","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"d":"The \"past the end\" position---that is, the position one greater\nthan the last valid subscript argument.\n\nNote that instances of `OrderedSet.SubSequence` generally aren't indexed\nfrom zero, so `endIndex` may differ from the `count`.\n\n- Complexity: O(1)","o":457},{"p":["OrderedSet","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"e":[["Element",1,"Hashable",344]],"d":"A textual representation of this instance.","o":549},{"p":["OrderedSet","customMirror"],"f":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18,558],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18]],"e":[["Element",1,"Hashable",344]],"d":"The custom mirror for this instance.","o":546},{"p":["OrderedSet","UnorderedView","description"],"f":[["var",12],[" ",17],["description",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["description",7],[": ",17],["String",18]],"e":[["Element",1,"Hashable",344]],"d":"A textual representation of this instance.","o":549},{"p":["OrderedSet","UnorderedView","customMirror"],"f":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18,558],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["customMirror",7],[": ",17],["Mirror",18]],"e":[["Element",1,"Hashable",344]],"d":"The custom mirror for this instance.","o":546},{"p":["OrderedSet","UnorderedView","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]],"e":[["Element",1,"Hashable",344]],"d":"A textual representation of this instance, suitable for debugging.","o":554},{"p":["OrderedSet","debugDescription"],"f":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18,386],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["debugDescription",7],[": ",17],["String",18]],"e":[["Element",1,"Hashable",344]],"d":"A textual representation of this instance, suitable for debugging.","o":554},{"p":["OrderedSet","count"],"f":[["var",12],[" ",17],["count",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["count",7],[": ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"d":"The number of elements in the set.\n\n- Complexity: O(1)","o":480},{"p":["OrderedSet","indices"],"f":[["var",12],[" ",17],["indices",7],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["Indices",18,336],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["indices",7],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["Indices",18]],"e":[["Element",1,"Hashable",344]],"d":"The indices that are valid for subscripting the collection, in ascending\norder.\n\n- Complexity: O(1)","o":455},{"p":["OrderedSet","isEmpty"],"f":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18,441],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["isEmpty",7],[": ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"d":"A Boolean value indicating whether the collection is empty.\n\n- Complexity: O(1)","o":481},{"p":["OrderedSet","elements"],"f":[["var",12],[" ",17],["elements",7],[": [",17],["Element",18],["] { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["elements",7],[": [",17],["Element",18],["]",17]],"e":[["Element",1,"Hashable",344]],"d":"A view of the members of this set, as a regular array value.\n\nIt is possible to mutate the set by updating the value of this property.\nThis guarantees that direct mutations happen in place when possible (i.e.,\nwithout spurious copy-on-write copies).\n\nHowever, the set needs to ensure the uniqueness of its members, so every\nupdate to `elements` includes a postprocessing step to detect and remove\nduplicates over the entire array. This can be slower than doing the\nequivalent updates with direct `OrderedSet` operations, so updating\n`elements` is best used in cases where direct implementations aren't\navailable -- for example, when you need to call a `MutableCollection`\nalgorithm that isn't directly implemented by `OrderedSet` itself.\n\n- Complexity: O(1) for the getter. Mutating this property has an expected\n   complexity of O(`count`), if `Element` implements high-quality hashing."},{"p":["OrderedSet","endIndex"],"f":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18,445],[" { ",17],["get",12],[" }",17]],"s":[["var",12],[" ",17],["endIndex",7],[": ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"d":"The set's \"past the end\" position---that is, the position one greater\nthan the last valid subscript argument.\n\nIn an `OrderedSet`, `endIndex` always equals the count of elements.\nIf the set is empty, `endIndex` is equal to `startIndex`.\n\n- Complexity: O(1)","o":457},{"p":["OrderedSet","unordered"],"f":[["var",12],[" ",17],["unordered",7],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[" { ",17],["get",12],[" ",17],["set",12],[" }",17]],"s":[["var",12],[" ",17],["unordered",7],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"d":"Access a view of the members of this set as an unordered\n`SetAlgebra` value.\n\nThis is useful when you need to pass an ordered set to a\nfunction that is generic over `SetAlgebra`.\n\nThe unordered view has a definition of equality that ignores the\norder of members, so that it can satisfy `SetAlgebra`\nrequirements. New elements inserted to the unordered view get\nappended to the end of the set.\n\n- Complexity: O(1) for both the getter and the setter."},{"p":["OrderedDictionary","removeLast()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321]],"s":[["func",12],[" ",17],["removeLast",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the last element of a non-empty dictionary.\n\n- Complexity: Expected to be O(`1`) on average, if `Element` implements\n   high-quality hashing."},{"p":["OrderedDictionary","removeLast(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["(",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["removeLast",7],["(",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the last `n` element of the dictionary.\n\n- Parameter n: The number of elements to remove from the collection.\n  `n` must be greater than or equal to zero and must not exceed the\n  number of elements in the collection.\n\n- Complexity: Expected to be O(`n`) on average, if `Element` implements\n   high-quality hashing."},{"p":["OrderedDictionary","removeFirst()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321]],"s":[["func",12],[" ",17],["removeFirst",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the first element of a non-empty dictionary.\n\nThe members following the removed key-value pair need to be moved to close\nthe resulting gaps in the storage arrays.\n\n- Complexity: O(`count`)."},{"p":["OrderedDictionary","removeFirst(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["(",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["removeFirst",7],["(",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the first `n` elements of the dictionary.\n\nThe members following the removed items need to be moved to close the\nresulting gaps in the storage arrays.\n\n- Parameter n: The number of elements to remove from the collection.\n  `n` must be greater than or equal to zero and must not exceed the\n  number of elements in the set.\n\n- Complexity: O(`count`)."},{"p":["OrderedDictionary","removeValue(forKey:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeValue",7],["(",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[") -> ",17],["Value",18],["?",17]],"s":[["func",12],[" ",17],["removeValue",7],["(",17],["forKey",1],[": ",17],["Key",18],[") -> ",17],["Value",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the given key and its associated value from the dictionary.\n\nIf the key is found in the dictionary, this method returns the key's\nassociated value.\n\n    var hues: OrderedDictionary = [\n       \"Heliotrope\": 296,\n       \"Coral\": 16,\n       \"Aquamarine\": 156]\n    if let value = hues.removeValue(forKey: \"Coral\") {\n        print(\"The value \\(value) was removed.\")\n    }\n    // Prints \"The value 16 was removed.\"\n\nIf the key isn't found in the dictionary, `removeValue(forKey:)` returns\n`nil`.\n\n    if let value = hues.removeValue(forKey: \"Cerise\") {\n        print(\"The value \\(value) was removed.\")\n    } else {\n        print(\"No value found for that key.\")\n    }\n    // Prints \"No value found for that key.\"\"\n\n- Parameter key: The key to remove along with its associated value.\n- Returns: The value that was removed, or `nil` if the key was not\n  present in the dictionary.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","updateValue(forKey:insertingDefault:at:with:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["updateValue",7],["<",17],["R",0],[">(",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[", ",17],["insertingDefault",1],[" ",17],["defaultValue",2],[": ",17],["@autoclosure ",3],["() -> ",17],["Value",18],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,445],[", ",17],["with",1],[" ",17],["body",2],[": (",17],["inout",12],[" ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"s":[["func",12],[" ",17],["updateValue",7],["<",17],["R",0],[">(",17],["forKey",1],[": ",17],["Key",18],[", ",17],["insertingDefault",1],[": () -> ",17],["Value",18],[", ",17],["at",1],[": ",17],["Int",18],[", ",17],["with",1],[": (",17],["inout",12],[" ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Ensures that the specified key exists in the dictionary (by inserting one\nwith the specified index and default value if necessary), then calls\n`body` to update it in place.\n\nYou can use this method to perform in-place operations on values in the\ndictionary, whether or not `Value` has value semantics. The following\nexample uses this method while counting the occurrences of each letter\nin a string:\n\n    let message = \"Hello, Elle!\"\n    var letterCounts: [Character: Int] = [:]\n    for letter in message {\n        letterCounts.updateValue(forKey: letter, default: 0) { count in\n            count += 1\n        }\n    }\n    // letterCounts == [\"H\": 1, \"e\": 2, \"l\": 4, \"o\": 1, ...]\n\n- Parameters:\n  - key: The key to look up (or append). If `key` does not already exist\n     in the dictionary, it is appended with the supplied default value.\n  - defaultValue: The default value to append if `key` doesn't exist in\n     the dictionary.\n  - body: A function that performs an in-place mutation on the dictionary\n     value.\n\n- Returns: The return value of `body`.\n\n- Complexity: expected complexity is amortized O(1), if `Key` implements\n   high-quality hashing. (Ignoring the complexity of calling `body`.)"},{"p":["OrderedDictionary","updateValue(forKey:default:with:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["updateValue",7],["<",17],["R",0],[">(",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[", ",17],["default",1],[" ",17],["defaultValue",2],[": ",17],["@autoclosure ",3],["() -> ",17],["Value",18],[", ",17],["with",1],[" ",17],["body",2],[": (",17],["inout",12],[" ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"s":[["func",12],[" ",17],["updateValue",7],["<",17],["R",0],[">(",17],["forKey",1],[": ",17],["Key",18],[", ",17],["default",1],[": () -> ",17],["Value",18],[", ",17],["with",1],[": (",17],["inout",12],[" ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Ensures that the specified key exists in the dictionary (by appending one\nwith the supplied default value if necessary), then calls `body` to update\nit in place.\n\nYou can use this method to perform in-place operations on values in the\ndictionary, whether or not `Value` has value semantics. The following\nexample uses this method while counting the occurrences of each letter\nin a string:\n\n    let message = \"Hello, Elle!\"\n    var letterCounts: [Character: Int] = [:]\n    for letter in message {\n        letterCounts.updateValue(forKey: letter, default: 0) { count in\n            count += 1\n        }\n    }\n    // letterCounts == [\"H\": 1, \"e\": 2, \"l\": 4, \"o\": 1, ...]\n\n- Parameters:\n  - key: The key to look up (or append). If `key` does not already exist\n     in the dictionary, it is appended with the supplied default value.\n  - defaultValue: The default value to append if `key` doesn't exist in\n     the dictionary.\n  - body: A function that performs an in-place mutation on the dictionary\n     value.\n\n- Returns: The return value of `body`.\n\n- Complexity: expected complexity is amortized O(1), if `Key` implements\n   high-quality hashing. (Ignoring the complexity of calling `body`.)"},{"p":["OrderedDictionary","updateValue(_:forKey:insertingAt:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["updateValue",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Value",18],[", ",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[", ",17],["insertingAt",1],[" ",17],["index",2],[": ",17],["Int",18,445],[") -> (originalMember",17],[": ",17],["Value",18],["?, index",17],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["updateValue",7],["(",17],["Value",18],[", ",17],["forKey",1],[": ",17],["Key",18],[", ",17],["insertingAt",1],[": ",17],["Int",18],[") -> (originalMember",17],[": ",17],["Value",18],["?, index",17],[": ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Updates the value stored in the dictionary for the given key, or inserts a\nnew key-value pair at the specified index if the key does not exist.\n\nUse this method instead of key-based subscripting when you need to insert\nnew keys at a particular index. You can use the return value to\ndetermine whether or not the new value supplanted the value of an existing\nkey.\n\nIf the value of an existing key is updated,\n`updateValue(_:forKey:insertingAt:)` returns the original value and its\nindex.\n\n    var hues: OrderedDictionary = [\n        \"Heliotrope\": 296,\n        \"Coral\": 16,\n        \"Aquamarine\": 156]\n    let newIndex = hues.startIndex\n    let (old, index) =\n        hues.updateValue(18, forKey: \"Coral\", insertingAt: newIndex)\n    if let old = old {\n        print(\"The value '\\(old)' at offset \\(index.offset) was replaced.\")\n    }\n    // Prints \"The value '16' at offset 1 was replaced.\"\n\nIf the given key is not present in the dictionary, this method inserts the\nkey-value pair at the specified index and returns `nil`.\n\n    let (old, index) =\n        hues.updateValue(330, forKey: \"Cerise\", insertingAt: newIndex)\n    if let old = old {\n        print(\"The value '\\(old)' at offset \\(index.offset) was replaced.\")\n    } else {\n        print(\"A new value was inserted at offset \\(index.offset).\")\n    }\n    // Prints \"A new value was inserted at offset 0.\")\n\n- Parameters:\n  - value: The new value to add to the dictionary.\n  - key: The key to associate with `value`. If `key` already exists in\n     the dictionary, `value` replaces the existing associated value. If\n     `key` isn't already a key of the dictionary, the `(key, value)` pair\n     is inserted.\n  - index: The index at which to insert the key, if it doesn't already\n     exist.\n\n- Returns: A pair `(old, index)`, where `old` is the value that was\n   replaced, or `nil` if a new key-value pair was added, and `index`\n   is the index corresponding to the updated (or inserted) value.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","updateValue(_:forKey:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["updateValue",7],["(",17],["_",1],[" ",17],["value",2],[": ",17],["Value",18],[", ",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[") -> ",17],["Value",18],["?",17]],"s":[["func",12],[" ",17],["updateValue",7],["(",17],["Value",18],[", ",17],["forKey",1],[": ",17],["Key",18],[") -> ",17],["Value",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Updates the value stored in the dictionary for the given key, or appends a\nnew key-value pair if the key does not exist.\n\nUse this method instead of key-based subscripting when you need to know\nwhether the new value supplants the value of an existing key. If the\nvalue of an existing key is updated, `updateValue(_:forKey:)` returns\nthe original value.\n\n    var hues: OrderedDictionary = [\n        \"Heliotrope\": 296,\n        \"Coral\": 16,\n        \"Aquamarine\": 156]\n\n    if let oldValue = hues.updateValue(18, forKey: \"Coral\") {\n        print(\"The old value of \\(oldValue) was replaced with a new one.\")\n    }\n    // Prints \"The old value of 16 was replaced with a new one.\"\n\nIf the given key is not present in the dictionary, this method appends the\nkey-value pair and returns `nil`.\n\n    if let oldValue = hues.updateValue(330, forKey: \"Cerise\") {\n        print(\"The old value of \\(oldValue) was replaced with a new one.\")\n    } else {\n        print(\"No value was found in the dictionary for that key.\")\n    }\n    // Prints \"No value was found in the dictionary for that key.\"\n\n- Parameters:\n  - value: The new value to add to the dictionary.\n  - key: The key to associate with `value`. If `key` already exists in\n    the dictionary, `value` replaces the existing associated value. If\n    `key` isn't already a key of the dictionary, the `(key, value)` pair\n    is added.\n\n- Returns: The value that was replaced, or `nil` if a new key-value pair\n  was added.\n\n- Complexity: expected complexity is amortized O(1), if `Key` implements\n   high-quality hashing."},{"p":["OrderedDictionary","makeIterator()"],"f":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Iterator",18,5]],"s":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Iterator",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an iterator over the elements of this collection.\n\n- Complexity: O(1)","o":391},{"p":["OrderedDictionary","removeSubrange(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeSubrange",7],["(",17],["_",1],[" ",17],["bounds",2],[": ",17],["Range",18,511],["<",17],["Int",18,445],[">)",17]],"s":[["func",12],[" ",17],["removeSubrange",7],["(",17],["Range",18],["<",17],["Int",18],[">)",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the specified subrange of elements from the collection.\n\nAll the elements following the specified subrange are moved to close the\nresulting gap.\n\n- Parameter bounds: The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","removeSubrange(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeSubrange",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["bounds",2],[": ",17],["R",18],[") ",17],["where",12],[" ",17],["R",18],[" : ",17],["RangeExpression",18,438],[", ",17],["R",18],[".",17],["Bound",18],[" == ",17],["Int",18,445]],"s":[["func",12],[" ",17],["removeSubrange",7],["<",17],["R",0],[">(",17],["R",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["R",1,"RangeExpression",438],["R.Bound",2,"Int",445]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Removes the specified subrange of elements from the collection.\n\nAll the elements following the specified subrange are moved to close the\nresulting gap.\n\n- Parameter bounds: The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","reserveCapacity(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reserveCapacity",7],["(",17],["_",1],[" ",17],["minimumCapacity",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["reserveCapacity",7],["(",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Reserves enough space to store the specified number of elements.\n\nThis method ensures that the dictionary has unique, mutable, contiguous\nstorage, with space allocated for at least the requested number of\nelements.\n\nIf you are adding a known number of elements to a dictionary, call this\nmethod once before the first insertion to avoid multiple reallocations.\n\nDo not call this method in a loop -- it does not use an exponential\nallocation strategy, so doing that can result in quadratic instead of\nlinear performance.\n\n- Parameter minimumCapacity: The minimum number of elements that the\n  dictionary should be able to store without reallocating its storage.\n\n- Complexity: O(`max(count, minimumCapacity)`)"},{"p":["OrderedDictionary","compactMapValues(_:)"],"f":[["func",12],[" ",17],["compactMapValues",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["transform",2],[": (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["T",18],["?) ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["compactMapValues",7],["<",17],["T",0],[">((",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["T",18],["?) ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["T",18],[">",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["T",0,1]],"d":"Returns a new dictionary containing only the key-value pairs that have\nnon-`nil` values as the result of transformation by the given closure.\n\nUse this method to receive a dictionary with non-optional values when\nyour transformation produces optional values.\n\nIn this example, note the difference in the result of using `mapValues`\nand `compactMapValues` with a transformation that returns an optional\n`Int` value.\n\n    let data: OrderedDictionary = [\"a\": \"1\", \"b\": \"three\", \"c\": \"///4///\"]\n\n    let m: [String: Int?] = data.mapValues { str in Int(str) }\n    // [\"a\": Optional(1), \"b\": nil, \"c\": nil]\n\n    let c: [String: Int] = data.compactMapValues { str in Int(str) }\n    // [\"a\": 1]\n\n- Parameter transform: A closure that transforms a value. `transform`\n  accepts each value of the dictionary as its parameter and returns an\n  optional transformed value of the same or of a different type.\n\n- Returns: A dictionary containing the keys and non-`nil` transformed\n  values of this dictionary.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","sort(by:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["sort",7],["(",17],["by",1],[" ",17],["areInIncreasingOrder",2],[": (",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321],[", ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12]],"s":[["func",12],[" ",17],["sort",7],["(",17],["by",1],[": (",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18],[", ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Sorts the collection in place, using the given predicate as the\ncomparison between elements.\n\nWhen you want to sort a collection of elements that don't conform to\nthe `Comparable` protocol, pass a closure to this method that returns\n`true` when the first element should be ordered before the second.\n\nAlternatively, use this method to sort a collection of elements that do\nconform to `Comparable` when you want the sort to be descending instead\nof ascending. Pass the greater-than operator (`>`) operator as the\npredicate.\n\n`areInIncreasingOrder` must be a *strict weak ordering* over the\nelements. That is, for any elements `a`, `b`, and `c`, the following\nconditions must hold:\n\n- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)\n- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are\n  both `true`, then `areInIncreasingOrder(a, c)` is also `true`.\n  (Transitive comparability)\n- Two elements are *incomparable* if neither is ordered before the other\n  according to the predicate. If `a` and `b` are incomparable, and `b`\n  and `c` are incomparable, then `a` and `c` are also incomparable.\n  (Transitive incomparability)\n\nThe sorting algorithm is not guaranteed to be stable. A stable sort\npreserves the relative order of elements for which\n`areInIncreasingOrder` does not establish an order.\n\n- Parameter areInIncreasingOrder: A predicate that returns `true` if its\n  first argument should be ordered before its second argument;\n  otherwise, `false`. If `areInIncreasingOrder` throws an error during\n  the sort, the elements may be in a different order, but none will be\n  lost.\n\n- Complexity: O(*n* log *n*), where *n* is the length of the collection."},{"p":["OrderedDictionary","index(forKey:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["forKey",1],[": ",17],["Key",18],[") -> ",17],["Int",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the index for the given key.\n\nIf the given key is found in the dictionary, this method returns an index\ninto the dictionary that corresponds with the key-value pair.\n\n    let countryCodes: OrderedDictionary = [\"BR\": \"Brazil\", \"GH\": \"Ghana\", \"JP\": \"Japan\"]\n    let index = countryCodes.index(forKey: \"JP\")\n\n    print(\"Country code for \\(countryCodes[offset: index!].value): '\\(countryCodes[offset: index!].key)'.\")\n    // Prints \"Country code for Japan: 'JP'.\"\n\n- Parameter key: The key to find in the dictionary.\n\n- Returns: The index for `key` and its associated value if `key` is in\n   the dictionary; otherwise, `nil`.\n\n- Complexity: Expected to be O(1) on average, if `Key` implements\n   high-quality hashing."},{"p":["OrderedDictionary","merge(_:uniquingKeysWith:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["merge",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[", ",17],["uniquingKeysWith",1],[" ",17],["combine",2],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (key",17],[": ",17],["Key",18],[", value",17],[": ",17],["Value",18],[")",17]],"s":[["func",12],[" ",17],["merge",7],["<",17],["S",0],[">(",17],["S",18],[", ",17],["uniquingKeysWith",1],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(key: Key, value: Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Merges the key-value pairs in the given sequence into the dictionary,\nusing a combining closure to determine the value for any duplicate keys.\n\nUse the `combine` closure to select a value to use in the updated\ndictionary, or to combine existing and new values. As the key-value\npairs are merged with the dictionary, the `combine` closure is called\nwith the current and new values for any duplicate keys that are\nencountered.\n\nThis example shows how to choose the current or new values for any\nduplicate keys:\n\n    var dictionary: OrderedDictionary = [\"a\": 1, \"b\": 2]\n\n    // Keeping existing value for key \"a\":\n    dictionary.merge(zip([\"a\", \"c\"], [3, 4])) { (current, _) in current }\n    // [\"b\": 2, \"a\": 1, \"c\": 4]\n\n    // Taking the new value for key \"a\":\n    dictionary.merge(zip([\"a\", \"d\"], [5, 6])) { (_, new) in new }\n    // [\"b\": 2, \"a\": 5, \"c\": 4, \"d\": 6]\n\n- Parameters:\n  - other: A sequence of key-value pairs.\n  - combine: A closure that takes the current and new values for any\n    duplicate keys. The closure returns the desired value for the final\n    dictionary.\n\n- Complexity: Expected to be O(*n*) on average, where *n* is the number of\n   elements in `keysAndValues`, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","merge(_:uniquingKeysWith:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["merge",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["keysAndValues",2],[": ",17],["S",18],[", ",17],["uniquingKeysWith",1],[" ",17],["combine",2],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (",17],["Key",18],[", ",17],["Value",18],[")",17]],"s":[["func",12],[" ",17],["merge",7],["<",17],["S",0],[">(",17],["S",18],[", ",17],["uniquingKeysWith",1],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(Key, Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Merges the key-value pairs in the given sequence into the dictionary,\nusing a combining closure to determine the value for any duplicate keys.\n\nUse the `combine` closure to select a value to use in the updated\ndictionary, or to combine existing and new values. As the key-value\npairs are merged with the dictionary, the `combine` closure is called\nwith the current and new values for any duplicate keys that are\nencountered.\n\nThis example shows how to choose the current or new values for any\nduplicate keys:\n\n    var dictionary: OrderedDictionary = [\"a\": 1, \"b\": 2]\n\n    // Keeping existing value for key \"a\":\n    dictionary.merge(zip([\"a\", \"c\"], [3, 4])) { (current, _) in current }\n    // [\"b\": 2, \"a\": 1, \"c\": 4]\n\n    // Taking the new value for key \"a\":\n    dictionary.merge(zip([\"a\", \"d\"], [5, 6])) { (_, new) in new }\n    // [\"b\": 2, \"a\": 5, \"c\": 4, \"d\": 6]\n\n- Parameters:\n  - other: A sequence of key-value pairs.\n  - combine: A closure that takes the current and new values for any\n    duplicate keys. The closure returns the desired value for the final\n    dictionary.\n\n- Complexity: Expected to be O(*n*) on average, where *n* is the number of\n   elements in `keysAndValues`, if `Key` implements high-quality hashing."},{"p":["OrderedDictionary","Values","withUnsafeBufferPointer(_:)"],"f":[["func",12],[" ",17],["withUnsafeBufferPointer",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeBufferPointer",18,385],["<",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[".",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"s":[["func",12],[" ",17],["withUnsafeBufferPointer",7],["<",17],["R",0],[">((",17],["UnsafeBufferPointer",18],["<",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18],[".",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Calls a closure with a pointer to the collection's contiguous storage.\n\nOften, the optimizer can eliminate bounds checks within a collection\nalgorithm, but when that fails, invoking the same algorithm on the\nbuffer pointer passed into your closure lets you trade safety for speed.\n\nThe pointer passed as an argument to `body` is valid only during the\nexecution of `withUnsafeBufferPointer(_:)`. Do not store or return the\npointer for later use.\n\n- Parameter body: A closure with an `UnsafeBufferPointer` parameter that\n  points to the contiguous storage for the collection. If `body` has a\n  return value, that value is also used as the return value for the\n  `withUnsafeBufferPointer(_:)` method. The pointer argument is valid only\n  for the duration of the method's execution.\n\n- Returns: The return value, if any, of the `body` closure parameter.\n\n- Complexity: O(1) (not counting the closure call)"},{"p":["OrderedDictionary","Values","withUnsafeMutableBufferPointer(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["withUnsafeMutableBufferPointer",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["inout",12],[" ",17],["UnsafeMutableBufferPointer",18,512],["<",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[".",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"s":[["func",12],[" ",17],["withUnsafeMutableBufferPointer",7],["<",17],["R",0],[">((",17],["inout",12],[" ",17],["UnsafeMutableBufferPointer",18],["<",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18],[".",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Calls the given closure with a pointer to the collection's mutable\ncontiguous storage.\n\nOften, the optimizer can eliminate bounds checks within a collection\nalgorithm, but when that fails, invoking the same algorithm on the buffer\npointer passed into your closure lets you trade safety for speed.\n\nThe pointer passed as an argument to `body` is valid only during the\nexecution of `withUnsafeMutableBufferPointer(_:)`. Do not store or return\nthe pointer for later use.\n\n- Parameter body: A closure with an `UnsafeMutableBufferPointer` parameter\n  that points to the contiguous storage for the collection. If `body` has\n  a return value, that value is also used as the return value for the\n  `withUnsafeMutableBufferPointer(_:)` method. The pointer argument is\n  valid only for the duration of the method's execution.\n\n- Returns: The return value, if any, of the `body` closure parameter.\n\n- Complexity: O(1) (not counting the closure call)"},{"p":["OrderedDictionary","Values","withContiguousStorageIfAvailable(_:)"],"f":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeBufferPointer",18,385],["<",17],["Value",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"s":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">((",17],["UnsafeBufferPointer",18],["<",17],["Value",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Call `body(p)`, where `p` is a buffer pointer to the collections\ncontiguous storage. `OrderedDictionary.Values` values always have\ncontiguous storage.\n\n- Parameter body: A function to call. The function must not escape its\n   unsafe buffer pointer argument.\n\n- Returns: The value returned by `body`.\n\n- Complexity: O(1) (ignoring time spent in `body`)","o":393},{"p":["OrderedDictionary","Values","withContiguousMutableStorageIfAvailable(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["withContiguousMutableStorageIfAvailable",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["inout",12],[" ",17],["UnsafeMutableBufferPointer",18,512],["<",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[".",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"s":[["func",12],[" ",17],["withContiguousMutableStorageIfAvailable",7],["<",17],["R",0],[">((",17],["inout",12],[" ",17],["UnsafeMutableBufferPointer",18],["<",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18],[".",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Call `body(b)`, where `b` is an unsafe buffer pointer to the collection's\nmutable contiguous storage. `OrderedDictionary.Values` always stores its\nelements in contiguous storage.\n\nThe supplied buffer pointer is only valid for the duration of the call.\n\nOften, the optimizer can eliminate bounds- and uniqueness-checks within an\nalgorithm, but when that fails, invoking the same algorithm on the unsafe\nbuffer supplied to `body` lets you trade safety for speed.\n\n- Parameters:\n  - body: The function to invoke.\n\n- Returns: The value returned by `body`, or `nil` if `body` wasn't called.\n\n- Complexity: O(1) when this instance has a unique reference to its\n   underlying storage; O(`count`) otherwise. (Not counting the call to\n   `body`.)","o":365},{"p":["OrderedDictionary","Values","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the position immediately after the given index.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately after `i`.\n\n- Complexity: O(1)","o":450},{"p":["OrderedDictionary","Values","index(before:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the position immediately before the given index.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately before `i`.\n\n- Complexity: O(1)","o":451},{"p":["OrderedDictionary","Values","index(_:offsetBy:limitedBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[", ",17],["limitedBy",1],[" ",17],["limit",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[", ",17],["limitedBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, unless the index passed as `limit` prevents offsetting\nbeyond those bounds. (Otherwise the returned value won't be a valid index\nin the collection.)\n\n- Parameters:\n  - i: A valid index of the collection.\n  - distance: The distance to offset `i`.\n  - limit: A valid index of the collection to use as a limit. If\n    `distance > 0`, `limit` has no effect if it is less than `i`.\n    Likewise, if `distance < 0`, `limit` has no effect if it is greater\n    than `i`.\n- Returns: An index offset by `distance` from the index `i`, unless that\n  index would be beyond `limit` in the direction of movement. In that\n  case, the method returns `nil`.\n\n- Complexity: O(1)","o":452},{"p":["OrderedDictionary","Values","index(_:offsetBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an index that is the specified distance from the given index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, or the returned value will not be a valid index.\n\n- Parameters:\n  - i: A valid index of the collection.\n  - distance: The distance to offset `i`.\n\n- Returns: An index offset by `distance` from the index `i`. If `distance`\n  is positive, this is the same value as the result of `distance` calls to\n  `index(after:)`. If `distance` is negative, this is the same value as\n  the result of `abs(distance)` calls to `index(before:)`.\n\n- Complexity: O(1)","o":453},{"p":["OrderedDictionary","Values","swapAt(_:_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["swapAt",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["_",1],[" ",17],["j",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["swapAt",7],["(",17],["Int",18],[", ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Exchanges the values at the specified indices of the collection. (Leaving\ntheir associated keys in the underlying dictionary at their original\nposition.)\n\nBoth parameters must be valid indices below `endIndex`. Passing the same\nindex as both `i` and `j` has no effect.\n\n- Parameters:\n  - i: The index of the first value to swap.\n  - j: The index of the second value to swap.\n\n- Complexity: O(1) when the dictionary's storage isn't shared with another\n   value; O(`count`) otherwise.","o":366},{"p":["OrderedDictionary","Values","distance(from:to:)"],"f":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[" ",17],["start",2],[": ",17],["Int",18,445],[", ",17],["to",1],[" ",17],["end",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[": ",17],["Int",18],[", ",17],["to",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the distance between two indices.\n\n- Parameters:\n  - start: A valid index of the collection.\n  - end: Another valid index of the collection. If `end` is equal to\n    `start`, the result is zero.\n\n- Returns: The distance between `start` and `end`.\n\n- Complexity: O(1)","o":456},{"p":["OrderedDictionary","Values","formIndex(after:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Replaces the given index with its successor.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":458},{"p":["OrderedDictionary","Values","formIndex(before:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Replaces the given index with its predecessor.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":459},{"p":["OrderedDictionary","Values","partition(by:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["partition",7],["(",17],["by",1],[" ",17],["belongsInSecondPartition",2],[": (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12],[" -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["partition",7],["(",17],["by",1],[": (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Reorders the elements of the collection such that all the elements that\nmatch the given predicate are after all the elements that don't match.\n\nThis operation does not reorder the keys of the underlying dictionary,\njust their associated values.\n\nAfter partitioning a collection, there is a pivot index `p` where\nno element before `p` satisfies the `belongsInSecondPartition`\npredicate and every element at or after `p` satisfies\n`belongsInSecondPartition`.\n\n- Parameter belongsInSecondPartition: A predicate used to partition\n  the collection. All elements satisfying this predicate are ordered\n  after all elements not satisfying it.\n- Returns: The index of the first element in the reordered collection\n  that matches `belongsInSecondPartition`. If no elements in the\n  collection match `belongsInSecondPartition`, the returned index is\n  equal to the collection's `endIndex`.\n\n- Complexity: O(`count`)","o":367},{"p":["OrderedDictionary","Values","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,557],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"o":345},{"p":["OrderedDictionary","filter(_:)"],"f":[["func",12],[" ",17],["filter",7],["(",17],["_",1],[" ",17],["isIncluded",2],[": (",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">",17]],"s":[["func",12],[" ",17],["filter",7],["((",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns a new dictionary containing the key-value pairs of the dictionary\nthat satisfy the given predicate.\n\n- Parameter isIncluded: A closure that takes a key-value pair as its\n  argument and returns a Boolean value indicating whether the pair\n  should be included in the returned dictionary.\n\n- Returns: A dictionary of the key-value pairs that `isIncluded` allows.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","remove(at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["remove",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,445],[") -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321]],"s":[["func",12],[" ",17],["remove",7],["(",17],["at",1],[": ",17],["Int",18],[") -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes and returns the element at the specified position.\n\nAll the elements following the specified position are moved to close the\nresulting gap.\n\n- Parameter index: The position of the element to remove. `index` must be\n   a valid index of the collection that is not equal to the collection's\n   end index.\n\n- Returns: The removed element.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","swapAt(_:_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["swapAt",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["_",1],[" ",17],["j",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["swapAt",7],["(",17],["Int",18],[", ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Exchanges the key-value pairs at the specified indices of the dictionary.\n\nBoth parameters must be valid indices below `endIndex`. Passing the same\nindex as both `i` and `j` has no effect.\n\n- Parameters:\n  - i: The index of the first value to swap.\n  - j: The index of the second value to swap.\n\n- Complexity: O(1) when the dictionary's storage isn't shared with another\n   value; O(`count`) otherwise."},{"p":["OrderedDictionary","merging(_:uniquingKeysWith:)"],"f":[["func",12],[" ",17],["merging",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[", ",17],["uniquingKeysWith",1],[" ",17],["combine",2],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],["> ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (key",17],[": ",17],["Key",18],[", value",17],[": ",17],["Value",18],[")",17]],"s":[["func",12],[" ",17],["merging",7],["<",17],["S",0],[">(",17],["S",18],[", ",17],["uniquingKeysWith",1],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(key: Key, value: Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a dictionary by merging key-value pairs in a sequence into this\ndictionary, using a combining closure to determine the value for\nduplicate keys.\n\nUse the `combine` closure to select a value to use in the returned\ndictionary, or to combine existing and new values. As the key-value\npairs are merged with the dictionary, the `combine` closure is called\nwith the current and new values for any duplicate keys that are\nencountered.\n\nThis example shows how to choose the current or new values for any\nduplicate keys:\n\n    let dictionary: OrderedDictionary = [\"a\": 1, \"b\": 2]\n    let newKeyValues = zip([\"a\", \"b\"], [3, 4])\n\n    let keepingCurrent = dictionary.merging(newKeyValues) { (current, _) in current }\n    // [\"b\": 2, \"a\": 1]\n    let replacingCurrent = dictionary.merging(newKeyValues) { (_, new) in new }\n    // [\"b\": 4, \"a\": 3]\n\n- Parameters:\n  - other: A sequence of key-value pairs.\n  - combine: A closure that takes the current and new values for any\n    duplicate keys. The closure returns the desired value for the final\n    dictionary.\n\n- Returns: A new dictionary with the combined keys and values of this\n  dictionary and `other`.\n\n- Complexity: Expected to be O(`count` + *n*) on average, where *n* is the\n   number of elements in `keysAndValues`, if `Key` implements high-quality\n   hashing."},{"p":["OrderedDictionary","merging(_:uniquingKeysWith:)"],"f":[["func",12],[" ",17],["merging",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[", ",17],["uniquingKeysWith",1],[" ",17],["combine",2],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],["> ",17],["where",12],[" ",17],["S",18],[" : ",17],["Sequence",18,387],[", ",17],["S",18],[".",17],["Element",18],[" == (",17],["Key",18],[", ",17],["Value",18],[")",17]],"s":[["func",12],[" ",17],["merging",7],["<",17],["S",0],[">(",17],["S",18],[", ",17],["uniquingKeysWith",1],[": (",17],["Value",18],[", ",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["Value",18],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["S",1,"Sequence",387],["S.Element",2,"(Key, Value)"]],"g":[["Key",0,0],["Value",1,0],["S",0,1]],"d":"Creates a dictionary by merging key-value pairs in a sequence into this\ndictionary, using a combining closure to determine the value for\nduplicate keys.\n\nUse the `combine` closure to select a value to use in the returned\ndictionary, or to combine existing and new values. As the key-value\npairs are merged with the dictionary, the `combine` closure is called\nwith the current and new values for any duplicate keys that are\nencountered.\n\nThis example shows how to choose the current or new values for any\nduplicate keys:\n\n    let dictionary: OrderedDictionary = [\"a\": 1, \"b\": 2]\n    let newKeyValues = zip([\"a\", \"b\"], [3, 4])\n\n    let keepingCurrent = dictionary.merging(newKeyValues) { (current, _) in current }\n    // [\"b\": 2, \"a\": 1]\n    let replacingCurrent = dictionary.merging(newKeyValues) { (_, new) in new }\n    // [\"b\": 4, \"a\": 3]\n\n- Parameters:\n  - other: A sequence of key-value pairs.\n  - combine: A closure that takes the current and new values for any\n    duplicate keys. The closure returns the desired value for the final\n    dictionary.\n\n- Returns: A new dictionary with the combined keys and values of this\n  dictionary and `other`.\n\n- Complexity: Expected to be O(`count` + *n*) on average, where *n* is the\n   number of elements in `keysAndValues`, if `Key` implements high-quality\n   hashing."},{"p":["OrderedDictionary","reverse()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reverse",7],["()",17]],"s":[["func",12],[" ",17],["reverse",7],["()",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Reverses the elements of the ordered dictionary in place.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","shuffle(using:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["shuffle",7],["<",17],["T",0],[">(",17],["using",1],[" ",17],["generator",2],[": ",17],["inout",12],[" ",17],["T",18],[") ",17],["where",12],[" ",17],["T",18],[" : ",17],["RandomNumberGenerator",18,343]],"s":[["func",12],[" ",17],["shuffle",7],["<",17],["T",0],[">(",17],["using",1],[": ",17],["inout",12],[" ",17],["T",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["T",1,"RandomNumberGenerator",343]],"g":[["Key",0,0],["Value",1,0],["T",0,1]],"d":"Shuffles the collection in place, using the given generator as a source\nfor randomness.\n\nYou use this method to randomize the elements of a collection when you\nare using a custom random number generator. For example, you can use the\n`shuffle(using:)` method to randomly reorder the elements of an array.\n\n- Parameter generator: The random number generator to use when shuffling\n  the collection.\n\n- Complexity: O(*n*), where *n* is the length of the collection.\n\n- Note: The algorithm used to shuffle a collection may change in a future\n  version of Swift. If you're passing a generator that results in the\n  same shuffled order each time you run your program, that sequence may\n  change when your program is compiled using a different version of\n  Swift."},{"p":["OrderedDictionary","shuffle()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["shuffle",7],["()",17]],"s":[["func",12],[" ",17],["shuffle",7],["()",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Shuffles the collection in place.\n\nUse the `shuffle()` method to randomly reorder the elements of an ordered\ndictionary.\n\nThis method is equivalent to calling `shuffle(using:)`, passing in the\nsystem's default random generator.\n\n- Complexity: O(*n*), where *n* is the length of the collection."},{"p":["OrderedDictionary","Elements","removeLast()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327]],"s":[["func",12],[" ",17],["removeLast",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the last element of a non-empty dictionary.\n\n- Complexity: Expected to be O(`1`) on average, if `Element` implements\n   high-quality hashing."},{"p":["OrderedDictionary","Elements","removeLast(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["(",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["removeLast",7],["(",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the last `n` element of the dictionary.\n\n- Parameter n: The number of elements to remove from the collection.\n  `n` must be greater than or equal to zero and must not exceed the\n  number of elements in the collection.\n\n- Complexity: Expected to be O(`n`) on average, if `Element` implements\n   high-quality hashing."},{"p":["OrderedDictionary","Elements","SubSequence","makeIterator()"],"f":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["SubSequence",18,3],[".",17],["Iterator",18,4]],"s":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["SubSequence",18],[".",17],["Iterator",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an iterator over the elements of this dictionary slice.","o":391},{"p":["OrderedDictionary","Elements","SubSequence","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the position immediately after the given index.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the dictionary.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately after `i`.\n\n- Complexity: O(1)","o":450},{"p":["OrderedDictionary","Elements","SubSequence","index(before:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the position immediately before the given index.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the dictionary.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately before `i`.\n\n- Complexity: O(1)","o":451},{"p":["OrderedDictionary","Elements","SubSequence","index(forKey:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["forKey",1],[": ",17],["Key",18],[") -> ",17],["Int",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the index for the given key.\n\nIf the given key is found in the dictionary slice, this method returns an\nindex into the dictionary that corresponds with the key-value pair.\n\n    let countryCodes: OrderedDictionary = [\"BR\": \"Brazil\", \"GH\": \"Ghana\", \"JP\": \"Japan\"]\n    let slice = countryCodes.elements[1...]\n    let index = slice.index(forKey: \"JP\")\n\n    print(\"Country code for \\(countryCodes[offset: index!].value): '\\(countryCodes[offset: index!].key)'.\")\n    // Prints \"Country code for Japan: 'JP'.\"\n\n- Parameter key: The key to find in the dictionary slice.\n\n- Returns: The index for `key` and its associated value if `key` is in\n   the dictionary slice; otherwise, `nil`.\n\n- Complexity: Expected to be O(1) on average, if `Key` implements\n   high-quality hashing."},{"p":["OrderedDictionary","Elements","SubSequence","index(_:offsetBy:limitedBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[", ",17],["limitedBy",1],[" ",17],["limit",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[", ",17],["limitedBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, unless the index passed as `limit` prevents offsetting\nbeyond those bounds. (Otherwise the returned value won't be a valid index\nin the set.)\n\n- Parameters:\n  - i: A valid index of the dictionary.\n  - distance: The distance to offset `i`.\n  - limit: A valid index of the collection to use as a limit. If\n    `distance > 0`, `limit` has no effect if it is less than `i`.\n    Likewise, if `distance < 0`, `limit` has no effect if it is greater\n    than `i`.\n- Returns: An index offset by `distance` from the index `i`, unless that\n  index would be beyond `limit` in the direction of movement. In that\n  case, the method returns `nil`.\n\n- Complexity: O(1)","o":452},{"p":["OrderedDictionary","Elements","SubSequence","index(_:offsetBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an index that is the specified distance from the given index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, or the returned value will not be a valid index.\n\n- Parameters:\n  - i: A valid index of the dictionary.\n  - distance: The distance to offset `i`.\n\n- Returns: An index offset by `distance` from the index `i`. If `distance`\n  is positive, this is the same value as the result of `distance` calls to\n  `index(after:)`. If `distance` is negative, this is the same value as\n  the result of `abs(distance)` calls to `index(before:)`.\n\n- Complexity: O(1)","o":453},{"p":["OrderedDictionary","Elements","SubSequence","Iterator","next()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["next",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["SubSequence",18,3],[".",17],["Element",18,323],["?",17]],"s":[["func",12],[" ",17],["next",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["SubSequence",18],[".",17],["Element",18],["?",17]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Advances to the next element and returns it, or `nil` if no next\nelement exists.\n\n- Complexity: O(1)","o":514},{"p":["OrderedDictionary","Elements","SubSequence","distance(from:to:)"],"f":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[" ",17],["start",2],[": ",17],["Int",18,445],[", ",17],["to",1],[" ",17],["end",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[": ",17],["Int",18],[", ",17],["to",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the distance between two indices.\n\n- Parameters:\n  - start: A valid index of the collection.\n  - end: Another valid index of the collection. If `end` is equal to\n    `start`, the result is zero.\n\n- Returns: The distance between `start` and `end`.\n\n- Complexity: O(1)","o":456},{"p":["OrderedDictionary","Elements","SubSequence","formIndex(after:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Replaces the given index with its successor.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the dictionary.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":458},{"p":["OrderedDictionary","Elements","SubSequence","formIndex(before:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Replaces the given index with its predecessor.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the dictionary.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":459},{"p":["OrderedDictionary","Elements","removeFirst()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327]],"s":[["func",12],[" ",17],["removeFirst",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the first element of a non-empty dictionary.\n\nThe members following the removed key-value pair need to be moved to close\nthe resulting gaps in the storage arrays.\n\n- Complexity: O(`count`)."},{"p":["OrderedDictionary","Elements","removeFirst(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["(",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["removeFirst",7],["(",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the first `n` elements of the dictionary.\n\nThe members following the removed items need to be moved to close the\nresulting gaps in the storage arrays.\n\n- Parameter n: The number of elements to remove from the collection.\n  `n` must be greater than or equal to zero and must not exceed the\n  number of elements in the set.\n\n- Complexity: O(`count`)."},{"p":["OrderedDictionary","Elements","makeIterator()"],"f":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Iterator",18,5]],"s":[["func",12],[" ",17],["makeIterator",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Iterator",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"o":391},{"p":["OrderedDictionary","Elements","removeSubrange(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeSubrange",7],["(",17],["_",1],[" ",17],["bounds",2],[": ",17],["Range",18,511],["<",17],["Int",18,445],[">)",17]],"s":[["func",12],[" ",17],["removeSubrange",7],["(",17],["Range",18],["<",17],["Int",18],[">)",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes the specified subrange of elements from the collection.\n\nAll the elements following the specified subrange are moved to close the\nresulting gap.\n\n- Parameter bounds: The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","Elements","removeSubrange(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeSubrange",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["bounds",2],[": ",17],["R",18],[") ",17],["where",12],[" ",17],["R",18],[" : ",17],["RangeExpression",18,438],[", ",17],["R",18],[".",17],["Bound",18],[" == ",17],["Int",18,445]],"s":[["func",12],[" ",17],["removeSubrange",7],["<",17],["R",0],[">(",17],["R",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["R",1,"RangeExpression",438],["R.Bound",2,"Int",445]],"g":[["Key",0,0],["Value",1,0],["R",0,1]],"d":"Removes the specified subrange of elements from the collection.\n\nAll the elements following the specified subrange are moved to close the\nresulting gap.\n\n- Parameter bounds: The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","Elements","sort(by:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["sort",7],["(",17],["by",1],[" ",17],["areInIncreasingOrder",2],[": (",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327],[", ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12]],"s":[["func",12],[" ",17],["sort",7],["(",17],["by",1],[": (",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18],[", ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Sorts the collection in place, using the given predicate as the\ncomparison between elements.\n\nWhen you want to sort a collection of elements that don't conform to\nthe `Comparable` protocol, pass a closure to this method that returns\n`true` when the first element should be ordered before the second.\n\nAlternatively, use this method to sort a collection of elements that do\nconform to `Comparable` when you want the sort to be descending instead\nof ascending. Pass the greater-than operator (`>`) operator as the\npredicate.\n\n`areInIncreasingOrder` must be a *strict weak ordering* over the\nelements. That is, for any elements `a`, `b`, and `c`, the following\nconditions must hold:\n\n- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)\n- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are\n  both `true`, then `areInIncreasingOrder(a, c)` is also `true`.\n  (Transitive comparability)\n- Two elements are *incomparable* if neither is ordered before the other\n  according to the predicate. If `a` and `b` are incomparable, and `b`\n  and `c` are incomparable, then `a` and `c` are also incomparable.\n  (Transitive incomparability)\n\nThe sorting algorithm is not guaranteed to be stable. A stable sort\npreserves the relative order of elements for which\n`areInIncreasingOrder` does not establish an order.\n\n- Parameter areInIncreasingOrder: A predicate that returns `true` if its\n  first argument should be ordered before its second argument;\n  otherwise, `false`. If `areInIncreasingOrder` throws an error during\n  the sort, the elements may be in a different order, but none will be\n  lost.\n\n- Complexity: O(*n* log *n*), where *n* is the length of the collection."},{"p":["OrderedDictionary","Elements","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the position immediately after the given index.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately after `i`.\n\n- Complexity: O(1)","o":450},{"p":["OrderedDictionary","Elements","index(before:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the position immediately before the given index.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately before `i`.\n\n- Complexity: O(1)","o":451},{"p":["OrderedDictionary","Elements","index(forKey:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["forKey",1],[" ",17],["key",2],[": ",17],["Key",18],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["forKey",1],[": ",17],["Key",18],[") -> ",17],["Int",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the index for the given key.\n\nIf the given key is found in the dictionary, this method returns an index\ninto the dictionary that corresponds with the key-value pair.\n\n    let countryCodes: OrderedDictionary = [\"BR\": \"Brazil\", \"GH\": \"Ghana\", \"JP\": \"Japan\"]\n    let index = countryCodes.elements.index(forKey: \"JP\")\n\n    print(\"Country code for \\(countryCodes[offset: index!].value): '\\(countryCodes[offset: index!].key)'.\")\n    // Prints \"Country code for Japan: 'JP'.\"\n\n- Parameter key: The key to find in the dictionary.\n\n- Returns: The index for `key` and its associated value if `key` is in\n   the dictionary; otherwise, `nil`.\n\n- Complexity: Expected to be O(1) on average, if `Key` implements\n   high-quality hashing."},{"p":["OrderedDictionary","Elements","index(_:offsetBy:limitedBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[", ",17],["limitedBy",1],[" ",17],["limit",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[", ",17],["limitedBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18],["?",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, unless the index passed as `limit` prevents offsetting\nbeyond those bounds. (Otherwise the returned value won't be a valid index\nin the collection.)\n\n- Parameters:\n  - i: A valid index of the collection.\n  - distance: The distance to offset `i`.\n  - limit: A valid index of the collection to use as a limit. If\n    `distance > 0`, `limit` has no effect if it is less than `i`.\n    Likewise, if `distance < 0`, `limit` has no effect if it is greater\n    than `i`.\n- Returns: An index offset by `distance` from the index `i`, unless that\n  index would be beyond `limit` in the direction of movement. In that\n  case, the method returns `nil`.\n\n- Complexity: O(1)","o":452},{"p":["OrderedDictionary","Elements","index(_:offsetBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns an index that is the specified distance from the given index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, or the returned value will not be a valid index.\n\n- Parameters:\n  - i: A valid index of the collection.\n  - distance: The distance to offset `i`.\n\n- Returns: An index offset by `distance` from the index `i`. If `distance`\n  is positive, this is the same value as the result of `distance` calls to\n  `index(after:)`. If `distance` is negative, this is the same value as\n  the result of `abs(distance)` calls to `index(before:)`.\n\n- Complexity: O(1)","o":453},{"p":["OrderedDictionary","Elements","remove(at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["remove",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,445],[") -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327]],"s":[["func",12],[" ",17],["remove",7],["(",17],["at",1],[": ",17],["Int",18],[") -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes and returns the element at the specified position.\n\nAll the elements following the specified position are moved to close the\nresulting gap.\n\n- Parameter index: The position of the element to remove. `index` must be\n   a valid index of the collection that is not equal to the collection's\n   end index.\n\n- Returns: The removed element.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","Elements","swapAt(_:_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["swapAt",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["_",1],[" ",17],["j",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["swapAt",7],["(",17],["Int",18],[", ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Exchanges the key-value pairs at the specified indices of the dictionary.\n\nBoth parameters must be valid indices below `endIndex`. Passing the same\nindex as both `i` and `j` has no effect.\n\n- Parameters:\n  - i: The index of the first value to swap.\n  - j: The index of the second value to swap.\n\n- Complexity: O(1) when the dictionary's storage isn't shared with another\n   value; O(`count`) otherwise."},{"p":["OrderedDictionary","Elements","reverse()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reverse",7],["()",17]],"s":[["func",12],[" ",17],["reverse",7],["()",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Reverses the elements of the ordered dictionary in place.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","Elements","shuffle(using:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["shuffle",7],["<",17],["T",0],[">(",17],["using",1],[" ",17],["generator",2],[": ",17],["inout",12],[" ",17],["T",18],[") ",17],["where",12],[" ",17],["T",18],[" : ",17],["RandomNumberGenerator",18,343]],"s":[["func",12],[" ",17],["shuffle",7],["<",17],["T",0],[">(",17],["using",1],[": ",17],["inout",12],[" ",17],["T",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["T",1,"RandomNumberGenerator",343]],"g":[["Key",0,0],["Value",1,0],["T",0,1]],"d":"Shuffles the collection in place, using the given generator as a source\nfor randomness.\n\nYou use this method to randomize the elements of a collection when you\nare using a custom random number generator. For example, you can use the\n`shuffle(using:)` method to randomly reorder the elements of an array.\n\n- Parameter generator: The random number generator to use when shuffling\n  the collection.\n\n- Complexity: O(*n*), where *n* is the length of the collection.\n\n- Note: The algorithm used to shuffle a collection may change in a future\n  version of Swift. If you're passing a generator that results in the\n  same shuffled order each time you run your program, that sequence may\n  change when your program is compiled using a different version of\n  Swift."},{"p":["OrderedDictionary","Elements","shuffle()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["shuffle",7],["()",17]],"s":[["func",12],[" ",17],["shuffle",7],["()",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Shuffles the collection in place.\n\nUse the `shuffle()` method to randomly reorder the elements of an ordered\ndictionary.\n\nThis method is equivalent to calling `shuffle(using:)`, passing in the\nsystem's default random generator.\n\n- Complexity: O(*n*), where *n* is the length of the collection."},{"p":["OrderedDictionary","Elements","distance(from:to:)"],"f":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[" ",17],["start",2],[": ",17],["Int",18,445],[", ",17],["to",1],[" ",17],["end",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[": ",17],["Int",18],[", ",17],["to",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns the distance between two indices.\n\n- Parameters:\n  - start: A valid index of the collection.\n  - end: Another valid index of the collection. If `end` is equal to\n    `start`, the result is zero.\n\n- Returns: The distance between `start` and `end`.\n\n- Complexity: O(1)","o":456},{"p":["OrderedDictionary","Elements","formIndex(after:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Replaces the given index with its successor.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":458},{"p":["OrderedDictionary","Elements","formIndex(before:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Replaces the given index with its predecessor.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the collection.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":459},{"p":["OrderedDictionary","Elements","partition(by:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["partition",7],["(",17],["by",1],[" ",17],["belongsInSecondPartition",2],[": (",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12],[" -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["partition",7],["(",17],["by",1],[": (",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Reorders the elements of the dictionary such that all the elements that\nmatch the given predicate are after all the elements that don't match.\n\nAfter partitioning a collection, there is a pivot index `p` where\nno element before `p` satisfies the `belongsInSecondPartition`\npredicate and every element at or after `p` satisfies\n`belongsInSecondPartition`.\n\n- Parameter belongsInSecondPartition: A predicate used to partition\n  the collection. All elements satisfying this predicate are ordered\n  after all elements not satisfying it.\n- Returns: The index of the first element in the reordered collection\n  that matches `belongsInSecondPartition`. If no elements in the\n  collection match `belongsInSecondPartition`, the returned index is\n  equal to the collection's `endIndex`.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","Elements","removeAll(keepingCapacity:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[" ",17],["keepCapacity",2],[": ",17],["Bool",18,441],[" = false)",17]],"s":[["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[": ",17],["Bool",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes all members from the dictionary.\n\n- Parameter keepingCapacity: If `true`, the dictionary's storage capacity\n  is preserved; if `false`, the underlying storage is released. The\n  default is `false`.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","Elements","removeAll(where:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeAll",7],["(",17],["where",1],[" ",17],["shouldBeRemoved",2],[": (",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["Element",18,327],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12]],"s":[["func",12],[" ",17],["removeAll",7],["(",17],["where",1],[": (",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[".",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes all the elements that satisfy the given predicate.\n\nUse this method to remove every element in a collection that meets\nparticular criteria. The order of the remaining elements is preserved.\n\n- Parameter shouldBeRemoved: A closure that takes an element of the\n  dictionary as its argument and returns a Boolean value indicating\n  whether the element should be removed from the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","Elements","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,557],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"o":345},{"p":["OrderedDictionary","Elements","sort()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["sort",7],["()",17]],"s":[["func",12],[" ",17],["sort",7],["()",17]],"e":[["Key",1,"Comparable",363],["Key",1,"Hashable",344]],"c":[["Key",1,"Comparable",363],["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Sorts the dictionary in place.\n\nYou can sort an ordered dictionary of keys that conform to the\n`Comparable` protocol by calling this method. The key-value pairs are\nsorted in ascending order. (`Value` doesn't need to conform to\n`Comparable` because the keys are guaranteed to be unique.)\n\nThe sorting algorithm is not guaranteed to be stable. A stable sort\npreserves the relative order of elements that compare equal.\n\n- Complexity: O(*n* log *n*), where *n* is the length of the collection."},{"p":["OrderedDictionary","Iterator","next()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["next",7],["() -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321],["?",17]],"s":[["func",12],[" ",17],["next",7],["() -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18],["?",17]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Advances to the next element and returns it, or nil if no next\nelement exists.\n\n- Complexity: O(1)","o":514},{"p":["OrderedDictionary","mapValues(_:)"],"f":[["func",12],[" ",17],["mapValues",7],["<",17],["T",0],[">(",17],["_",1],[" ",17],["transform",2],[": (",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["T",18],[">",17]],"s":[["func",12],[" ",17],["mapValues",7],["<",17],["T",0],[">((",17],["Value",18],[") ",17],["throws",12],[" -> ",17],["T",18],[") ",17],["rethrows",12],[" -> ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["T",18],[">",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0],["T",0,1]],"d":"Returns a new dictionary containing the keys of this dictionary with the\nvalues transformed by the given closure.\n\n- Parameter transform: A closure that transforms a value. `transform`\n  accepts each value of the dictionary as its parameter and returns a\n  transformed value of the same or of a different type.\n- Returns: A dictionary containing the keys and transformed values of\n  this dictionary.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","partition(by:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["partition",7],["(",17],["by",1],[" ",17],["belongsInSecondPartition",2],[": (",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12],[" -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["partition",7],["(",17],["by",1],[": (",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Reorders the elements of the dictionary such that all the elements that\nmatch the given predicate are after all the elements that don't match.\n\nAfter partitioning a collection, there is a pivot index `p` where\nno element before `p` satisfies the `belongsInSecondPartition`\npredicate and every element at or after `p` satisfies\n`belongsInSecondPartition`.\n\n- Parameter belongsInSecondPartition: A predicate used to partition\n  the collection. All elements satisfying this predicate are ordered\n  after all elements not satisfying it.\n- Returns: The index of the first element in the reordered collection\n  that matches `belongsInSecondPartition`. If no elements in the\n  collection match `belongsInSecondPartition`, the returned index is\n  equal to the collection's `endIndex`.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","removeAll(keepingCapacity:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[" ",17],["keepCapacity",2],[": ",17],["Bool",18,441],[" = false)",17]],"s":[["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[": ",17],["Bool",18],[")",17]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes all members from the dictionary.\n\n- Parameter keepingCapacity: If `true`, the dictionary's storage capacity\n  is preserved; if `false`, the underlying storage is released. The\n  default is `false`.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","removeAll(where:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeAll",7],["(",17],["where",1],[" ",17],["shouldBeRemoved",2],[": (",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12]],"s":[["func",12],[" ",17],["removeAll",7],["(",17],["where",1],[": (",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Removes all the elements that satisfy the given predicate.\n\nUse this method to remove every element in a collection that meets\nparticular criteria. The order of the remaining elements is preserved.\n\n- Parameter shouldBeRemoved: A closure that takes an element of the\n  dictionary as its argument and returns a Boolean value indicating\n  whether the element should be removed from the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedDictionary","encode(to:)"],"f":[["func",12],[" ",17],["encode",7],["(",17],["to",1],[" ",17],["encoder",2],[": ",17],["Encoder",18,560],[") ",17],["throws",12]],"s":[["func",12],[" ",17],["encode",7],["(",17],["to",1],[": ",17],["Encoder",18],[") ",17],["throws",12]],"e":[["Key",1,"Encodable",341],["Key",1,"Hashable",344],["Value",1,"Encodable",341]],"c":[["Key",1,"Encodable",341],["Key",1,"Hashable",344],["Value",1,"Encodable",341]],"g":[["Key",0,0],["Value",1,0]],"d":"Encodes the contents of this dictionary into the given encoder.\n\nThe dictionary's contents are encoded as alternating key-value pairs in\nan unkeyed container.\n\nThis function throws an error if any values are invalid for the given\nencoder's format.\n\n- Note: Unlike the standard `Dictionary` type, ordered dictionaries\n   always encode themselves into an unkeyed container, because\n   `Codable`'s keyed containers do not guarantee that they preserve the\n   ordering of the items they contain. (And in popular encoding formats,\n   keyed containers tend to map to unordered data structures -- e.g.,\n   JSON's \"object\" construct is explicitly unordered.)\n\n- Parameter encoder: The encoder to write data to.","o":342},{"p":["OrderedDictionary","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,557],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],"c":[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Hashes the essential components of this value by feeding them into the\ngiven hasher.\n\nComplexity: O(`count`)","o":345},{"p":["OrderedDictionary","sort()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["sort",7],["()",17]],"s":[["func",12],[" ",17],["sort",7],["()",17]],"e":[["Key",1,"Comparable",363],["Key",1,"Hashable",344]],"c":[["Key",1,"Comparable",363],["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Sorts the dictionary in place.\n\nYou can sort an ordered dictionary of keys that conform to the\n`Comparable` protocol by calling this method. The key-value pairs are\nsorted in ascending order. (`Value` doesn't need to conform to\n`Comparable` because the keys are guaranteed to be unique.)\n\nThe sorting algorithm is not guaranteed to be stable. A stable sort\npreserves the relative order of elements that compare equal.\n\n- Complexity: O(*n* log *n*), where *n* is the length of the collection."},{"p":["OrderedSet","difference(from:)"],"f":[["func",12],[" ",17],["difference",7],["(",17],["from",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["CollectionDifference",18,547],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["difference",7],["(",17],["from",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["CollectionDifference",18],["<",17],["Element",18],[">",17]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the collection difference between the parameter and the\nreceiver, using an algorithm specialized to exploit fast membership\ntesting and the member uniqueness guarantees of `OrderedSet`.\n\n- Complexity: O(`self.count + other.count`)"},{"p":["OrderedSet","firstIndex(of:)"],"f":[["func",12],[" ",17],["firstIndex",7],["(",17],["of",1],[" ",17],["element",2],[": ",17],["Element",18],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["firstIndex",7],["(",17],["of",1],[": ",17],["Element",18],[") -> ",17],["Int",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the index of the given element in the set, or `nil` if the element\nis not a member of the set.\n\n`OrderedSet` members are always unique, so the first index of an element\nis always the same as its last index.\n\n- Complexity: This operation is expected to perform O(1) comparisons on\n   average, provided that `Element` implements high-quality hashing."},{"p":["OrderedSet","isDisjoint(with:)"],"f":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set has no members in\ncommon with the given set.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [5, 6]\n    a.isDisjoint(with: b.unordered) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` has no elements in common with `other`;\n  otherwise, `false`.\n\n- Complexity: Expected to be O(min(`self.count`, `other.count`)) on\n   average, if `Element` implements high-quality hashing."},{"p":["OrderedSet","isDisjoint(with:)"],"f":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set has no members in\ncommon with the given set.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [5, 6]\n    a.isDisjoint(with: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` has no elements in common with `other`;\n  otherwise, `false`.\n\n- Complexity: Expected to be O(min(`self.count`, `other.count`)) on\n   average, if `Element` implements high-quality hashing."},{"p":["OrderedSet","isDisjoint(with:)"],"f":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set has no members in\ncommon with the given set.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Set = [5, 6]\n    a.isDisjoint(with: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` has no elements in common with `other`;\n  otherwise, `false`.\n\n- Complexity: Expected to be O(min(`self.count`, `other.count`)) on\n   average, if `Element` implements high-quality hashing."},{"p":["OrderedSet","isDisjoint(with:)"],"f":[["func",12],[" ",17],["isDisjoint",7],["<",17],["S",0],[">(",17],["with",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isDisjoint",7],["<",17],["S",0],[">(",17],["with",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether the set has no members in\ncommon with the given sequence.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Array = [5, 6]\n    a.isDisjoint(with: b) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if `self` has no elements in common with `other`;\n  otherwise, `false`.\n\n- Complexity: Expected to be O(*n*) on average, where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","isSuperset(of:)"],"f":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a superset of\nthe given set.\n\nSet *A* is a superset of another set *B* if every member of *B* is also a\nmember of *A*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Set = [4, 2, 1]\n    a.isSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isSuperset(of:)"],"f":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a superset of\nthe given set.\n\nSet *A* is a superset of another set *B* if every member of *B* is also a\nmember of *A*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    a.isSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isSuperset(of:)"],"f":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]]},{"p":["OrderedSet","isSuperset(of:)"],"f":[["func",12],[" ",17],["isSuperset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isSuperset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether this set is a superset of\nthe given sequence.\n\nSet *A* is a superset of another set *B* if every member of *B* is also a\nmember of *A*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Array = [4, 2, 1]\n    a.isSuperset(of: b) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(*n*) on average, where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","removeLast()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["() -> ",17],["Element",18]],"s":[["func",12],[" ",17],["removeLast",7],["() -> ",17],["Element",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the last element of a non-empty set.\n\n- Complexity: Expected to be O(`1`) on average, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","removeLast(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeLast",7],["(",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["removeLast",7],["(",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the last `n` element of the set.\n\n- Parameter n: The number of elements to remove from the collection.\n  `n` must be greater than or equal to zero and must not exceed the\n  number of elements in the collection.\n\n- Complexity: Expected to be O(`n`) on average, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","SubSequence","withContiguousStorageIfAvailable(_:)"],"f":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeBufferPointer",18,385],["<",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"s":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">((",17],["UnsafeBufferPointer",18],["<",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0],["R",0,1]],"d":"Call `body(p)`, where `p` is a buffer pointer to the collections\ncontiguous storage. Ordered sets always have contiguous storage.\n\n- Parameter body: A function to call. The function must not escape its\n   unsafe buffer pointer argument.\n\n- Returns: The value returned by `body`.\n\n- Complexity: O(1) (ignoring time spent in `body`)","o":393},{"p":["OrderedSet","SubSequence","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,557],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"o":345},{"p":["OrderedSet","SubSequence","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the position immediately after the given index.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately after `i`.\n\n- Complexity: O(1)","o":450},{"p":["OrderedSet","SubSequence","index(before:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the position immediately before the given index.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately before `i`.\n\n- Complexity: O(1)","o":451},{"p":["OrderedSet","SubSequence","index(_:offsetBy:limitedBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[", ",17],["limitedBy",1],[" ",17],["limit",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[", ",17],["limitedBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, unless the index passed as `limit` prevents offsetting\nbeyond those bounds. (Otherwise the returned value won't be a valid index\nin the set.)\n\n- Parameters:\n  - i: A valid index of the set.\n  - distance: The distance to offset `i`.\n  - limit: A valid index of the collection to use as a limit. If\n    `distance > 0`, `limit` has no effect if it is less than `i`.\n    Likewise, if `distance < 0`, `limit` has no effect if it is greater\n    than `i`.\n- Returns: An index offset by `distance` from the index `i`, unless that\n  index would be beyond `limit` in the direction of movement. In that\n  case, the method returns `nil`.\n\n- Complexity: O(1)","o":452},{"p":["OrderedSet","SubSequence","index(_:offsetBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns an index that is the specified distance from the given index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, or the returned value will not be a valid index.\n\n- Parameters:\n  - i: A valid index of the set.\n  - distance: The distance to offset `i`.\n\n- Returns: An index offset by `distance` from the index `i`. If `distance`\n  is positive, this is the same value as the result of `distance` calls to\n  `index(after:)`. If `distance` is negative, this is the same value as\n  the result of `abs(distance)` calls to `index(before:)`.\n\n- Complexity: O(1)","o":453},{"p":["OrderedSet","SubSequence","distance(from:to:)"],"f":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[" ",17],["start",2],[": ",17],["Int",18,445],[", ",17],["to",1],[" ",17],["end",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[": ",17],["Int",18],[", ",17],["to",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the distance between two indices.\n\n- Parameters:\n  - start: A valid index of the collection.\n  - end: Another valid index of the collection. If `end` is equal to\n    `start`, the result is zero.\n\n- Returns: The distance between `start` and `end`.\n\n- Complexity: O(1)","o":456},{"p":["OrderedSet","SubSequence","formIndex(after:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replaces the given index with its successor.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":458},{"p":["OrderedSet","SubSequence","formIndex(before:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replaces the given index with its predecessor.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":459},{"p":["OrderedSet","removeFirst()"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["() -> ",17],["Element",18]],"s":[["func",12],[" ",17],["removeFirst",7],["() -> ",17],["Element",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the first element of a non-empty set.\n\nThe members following the removed item need to be moved to close the\nresulting gap in the storage array.\n\n- Complexity: O(`count`)."},{"p":["OrderedSet","removeFirst(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeFirst",7],["(",17],["_",1],[" ",17],["n",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["removeFirst",7],["(",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the first `n` elements of the set.\n\nThe members following the removed items need to be moved to close the\nresulting gap in the storage array.\n\n- Parameter n: The number of elements to remove from the collection.\n  `n` must be greater than or equal to zero and must not exceed the\n  number of elements in the set.\n\n- Complexity: O(`count`)."},{"p":["OrderedSet","subtracting(_:)"],"f":[["func",12],[" ",17],["subtracting",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["subtracting",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set containing the elements of this set that do not occur\nin the given set.\n\nThe result contains elements in the same order they appear in `self`.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.subtracting(other.unordered) // [1, 3]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","subtracting(_:)"],"f":[["func",12],[" ",17],["subtracting",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["subtracting",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set containing the elements of this set that do not occur\nin the given set.\n\nThe result contains elements in the same order they appear in `self`.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.subtracting(other) // [1, 3]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","subtracting(_:)"],"f":[["func",12],[" ",17],["subtracting",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],["> ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["subtracting",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set containing the elements of this set that do not occur\nin the given sequence.\n\nThe result contains elements in the same order they appear in `self`.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    set.subtracting([6, 4, 2, 0] as Array) // [1, 3]\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","intersection(_:)"],"f":[["func",12],[" ",17],["intersection",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["intersection",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements that are common to both this set and\nthe provided other one, in the order they appear in `self`.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.intersection(other) // [2, 4]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","intersection(_:)"],"f":[["func",12],[" ",17],["intersection",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["intersection",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements that are common to both this set and\nthe provided other one, in the order they appear in `self`.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.intersection(other) // [2, 4]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","intersection(_:)"],"f":[["func",12],[" ",17],["intersection",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],["> ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["intersection",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set with the elements that are common to both this set and\nthe provided sequence, in the order they appear in `self`.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    set.intersection([6, 4, 2, 0] as Array) // [2, 4]\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(*n*) on average where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isDisjoint(with:)"],"f":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set has no members in\ncommon with the given set.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [5, 6]\n    a.isDisjoint(with: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` has no elements in common with `other`;\n  otherwise, `false`.\n\n- Complexity: Expected to be O(min(`self.count`, `other.count`)) on\n   average, if `Element` implements high-quality hashing.","o":517},{"p":["OrderedSet","UnorderedView","isDisjoint(with:)"],"f":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isDisjoint",7],["(",17],["with",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set has no members in\ncommon with the given set.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: Set = [5, 6]\n    a.isDisjoint(with: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` has no elements in common with `other`;\n  otherwise, `false`.\n\n- Complexity: Expected to be O(min(`self.count`, `other.count`)) on\n   average, if `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isDisjoint(with:)"],"f":[["func",12],[" ",17],["isDisjoint",7],["<",17],["S",0],[">(",17],["with",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isDisjoint",7],["<",17],["S",0],[">(",17],["with",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether the set has no members in\ncommon with the given sequence.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: Array = [5, 6]\n    a.isDisjoint(with: b) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if `self` has no elements in common with `other`;\n  otherwise, `false`.\n\n- Complexity: Expected to be O(*n*) on average, where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isSuperset(of:)"],"f":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a superset of\nthe given set.\n\nSet *A* is a superset of another set *B* if every member of *B* is also a\nmember of *A*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    a.isSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing.","o":518},{"p":["OrderedSet","UnorderedView","isSuperset(of:)"],"f":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSuperset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a superset of\nthe given set.\n\nSet *A* is a superset of another set *B* if every member of *B* is also a\nmember of *A*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: Set<Int> = [4, 2, 1]\n    a.isSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isSuperset(of:)"],"f":[["func",12],[" ",17],["isSuperset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isSuperset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether this set is a superset of\nthe given sequence.\n\nSet *A* is a superset of another set *B* if every member of *B* is also a\nmember of *A*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: Array = [4, 2, 1]\n    a.isSuperset(of: b) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(*n*) on average, where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","subtracting(_:)"],"f":[["func",12],[" ",17],["subtracting",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8]],"s":[["func",12],[" ",17],["subtracting",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set containing the elements of this set that do not occur\nin the given set.\n\nThe result contains elements in the same order they appear in `self`.\n\n    let set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let other: OrderedSet<Int>.UnorderedView = [6, 4, 2, 0]\n    set.subtracting(other) // [1, 3]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing.","o":519},{"p":["OrderedSet","UnorderedView","subtracting(_:)"],"f":[["func",12],[" ",17],["subtracting",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["subtracting",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set containing the elements of this set that do not occur\nin the given sequence.\n\nThe result contains elements in the same order they appear in `self`.\n\n    let set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    set.subtracting([6, 4, 2, 0] as Array) // [1, 3]\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","intersection(_:)"],"f":[["func",12],[" ",17],["intersection",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8]],"s":[["func",12],[" ",17],["intersection",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements that are common to both this set and\nthe provided other one, in the order they appear in `self`.\n\n    let set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let other: OrderedSet<Int>.UnorderedView = [6, 4, 2, 0]\n    set.intersection(other) // [2, 4]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing.","o":520},{"p":["OrderedSet","UnorderedView","intersection(_:)"],"f":[["func",12],[" ",17],["intersection",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["intersection",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set with the elements that are common to both this set and\nthe provided sequence, in the order they appear in `self`.\n\n    let set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    set.intersection([6, 4, 2, 0] as Array) // [2, 4]\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(*n*) on average where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isStrictSubset(of:)"],"f":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict subset\nof the given set.\n\nSet *A* is a strict subset of another set *B* if every member of *A* is\nalso a member of *B* and *B* contains at least one element that is not a\nmember of *A*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    b.isStrictSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict subset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isStrictSubset(of:)"],"f":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict subset\nof the given set.\n\nSet *A* is a strict subset of another set *B* if every member of *A* is\nalso a member of *B* and *B* contains at least one element that is not a\nmember of *A*. (Ignoring the order the elements appear in the sets.)\n\n    let a: Set<Int> = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    b.isStrictSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict subset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isStrictSubset(of:)"],"f":[["func",12],[" ",17],["isStrictSubset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isStrictSubset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether the set is a strict subset\nof the given sequence.\n\nSet *A* is a strict subset of another set *B* if every member of *A* is\nalso a member of *B* and *B* contains at least one element that is not a\nmember of *A*. (Ignoring the order the elements appear in the sets.)\n\n    let a: Array = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    b.isStrictSubset(of: a) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if `self` is a strict subset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","UnorderedView","formIntersection(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formIntersection",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["formIntersection",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the elements of this set that aren't also in the given one.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let other: OrderedSet<Int>.UnorderedView = [6, 4, 2, 0]\n    set.formIntersection(other)\n    // set is now [2, 4]\n\n- Parameter other: A set of elements.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing.","o":521},{"p":["OrderedSet","UnorderedView","formIntersection(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formIntersection",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["formIntersection",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Removes the elements of this set that aren't also in the given sequence.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    set.formIntersection([6, 4, 2, 0] as Array)\n    // set is now [2, 4]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(*n*) on average where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isStrictSuperset(of:)"],"f":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given set.\n\nSet *A* is a strict superset of another set *B* if every member of *B* is\nalso a member of *A* and *A* contains at least one element that is *not*\na member of *B*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    a.isStrictSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict superset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isStrictSuperset(of:)"],"f":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given set.\n\nSet *A* is a strict superset of another set *B* if every member of *B* is\nalso a member of *A* and *A* contains at least one element that is *not*\na member of *B*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: Set = [4, 2, 1]\n    a.isStrictSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict superset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isStrictSuperset(of:)"],"f":[["func",12],[" ",17],["isStrictSuperset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isStrictSuperset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given sequence.\n\nSet *A* is a strict superset of another set *B* if every member of *B* is\nalso a member of *A* and *A* contains at least one element that is *not*\na member of *B*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: Array = [4, 2, 1]\n    a.isStrictSuperset(of: b) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if `self` is a strict superset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","UnorderedView","symmetricDifference(_:)"],"f":[["func",12],[" ",17],["symmetricDifference",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8]],"s":[["func",12],[" ",17],["symmetricDifference",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements that are either in this set or in\n`other`, but not in both.\n\nThe result contains elements from `self` followed by elements in `other`,\nin the same order they appeared in the original sets.\n\n    let set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let other: OrderedSet<Int>.UnorderedView = [6, 4, 2, 0]\n    set.symmetricDifference(other) // [1, 3, 6, 0]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing.","o":522},{"p":["OrderedSet","UnorderedView","symmetricDifference(_:)"],"f":[["func",12],[" ",17],["symmetricDifference",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["symmetricDifference",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set with the elements that are either in this set or in the\ngiven sequence, but not in both.\n\nThe result contains elements from `self` followed by elements in `other`,\nin the same order they first appeared in the input values.\n\n    let set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    set.symmetricDifference([6, 4, 2, 0] as Array) // [1, 3, 6, 0]\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average where *n* is\n   the number of elements in `other`, if `Element` implements high-quality\n   hashing."},{"p":["OrderedSet","UnorderedView","formSymmetricDifference(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formSymmetricDifference",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["formSymmetricDifference",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replace this set with the elements contained in this set or the given\nset, but not both.\n\nOn return, `self` contains elements originally from `self` followed by\nelements in `other`, in the same order they appeared in the input values.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let other: OrderedSet<Int>.UnorderedView = [6, 4, 2, 0]\n    set.formSymmetricDifference(other)\n    // set is now [1, 3, 6, 0]\n\n- Parameter other: Another set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing.","o":523},{"p":["OrderedSet","UnorderedView","formSymmetricDifference(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formSymmetricDifference",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["formSymmetricDifference",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Replace this set with the elements contained in this set or the given\nsequence, but not both.\n\nOn return, `self` contains elements originally from `self` followed by\nelements in `other`, in the same order they first appeared in the input\nvalues.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    set.formSymmetricDifference([6, 4, 2, 0] as Array)\n    // set is now [1, 3, 6, 0]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average where *n* is\n   the number of elements in `other`, if `Element` implements high-quality\n   hashing."},{"p":["OrderedSet","UnorderedView","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,557],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Hashes the essential components of this value by feeding them into the\ngiven hasher.\n\nComplexity: O(`count`)","o":345},{"p":["OrderedSet","UnorderedView","union(_:)"],"f":[["func",12],[" ",17],["union",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8]],"s":[["func",12],[" ",17],["union",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements of both this and the given set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the result, in the order they appear in `other`.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [0, 2, 4, 6]\n    a.union(b) // [1, 2, 3, 4, 0, 6]\n\n- Parameter other: The set of elements to add.\n\n- Complexity: Expected to be O(`self.count` + `other.count`) on average,\n   if `Element` implements high-quality hashing.","o":524},{"p":["OrderedSet","UnorderedView","union(_:)"],"f":[["func",12],[" ",17],["union",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["union",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set with the elements of both this and the given set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the result, in the order they appear in `other`.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    a.union([0, 2, 4, 6]) // [1, 2, 3, 4, 0, 6]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`self.count` + `other.count`) on average,\n   if `Element` implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","insert(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["insert",7],["(",17],["_",1],[" ",17],["newMember",2],[": ",17],["Element",18],[") -> (inserted",17],[": ",17],["Bool",18,441],[", memberAfterInsert",17],[": ",17],["Element",18],[")",17]],"s":[["func",12],[" ",17],["insert",7],["(",17],["Element",18],[") -> (inserted",17],[": ",17],["Bool",18],[", memberAfterInsert",17],[": ",17],["Element",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Inserts the given element in the set if it is not already present.\n\nIf an element equal to `newMember` is already contained in the set, this\nmethod has no effect.\n\nIf `newMember` was not already a member, it gets appended to the end of\nthe underlying ordered set value.\n\n- Parameter newMember: An element to insert into the set.\n\n- Returns: `(true, newMember)` if `newMember` was not contained in the\n   set. If an element equal to `newMember` was already contained in the\n   set, the method returns `(false, oldMember)`, where `oldMember` is the\n   element that was equal to `newMember`. In some cases, `oldMember` may\n   be distinguishable from `newMember` by identity comparison or some\n   other means.\n\n- Complexity: This operation is expected to perform O(1)\n   hashing/comparison operations on average (over many insertions to the\n   same set), provided that `Element` implements high-quality hashing.","o":525},{"p":["OrderedSet","UnorderedView","remove(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["remove",7],["(",17],["_",1],[" ",17],["member",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[".",17],["Element",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[".",17],["Element",18],["?",17]],"s":[["func",12],[" ",17],["remove",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[".",17],["Element",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[".",17],["Element",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the given element from the set.\n\n- Parameter member: The element of the set to remove.\n\n- Returns: The element equal to `member` if `member` is contained in the\n   set; otherwise, `nil`. In some cases, the returned element may be\n   distinguishable from `newMember` by identity comparison or some other\n   means.\n\n- Complexity: O(`count`). Removing an element from the middle of the\n   underlying ordered set needs to rearrange the remaining elements to\n   close the resulting gap.\n\n   Removing the last element only takes (amortized) O(1)\n   hashing/comparisons operations, if `Element` implements high quality\n   hashing.","o":526},{"p":["OrderedSet","UnorderedView","update(with:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["update",7],["(",17],["with",1],[" ",17],["newMember",2],[": ",17],["Element",18],[") -> ",17],["Element",18],["?",17]],"s":[["func",12],[" ",17],["update",7],["(",17],["with",1],[": ",17],["Element",18],[") -> ",17],["Element",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Inserts the given element into the set unconditionally.\n\nIf an element equal to `newMember` is already contained in the set,\n`newMember` replaces the existing element.\n\nIf `newMember` was not already a member, it gets appended to the end of\nthe underlying ordered set value.\n\n- Parameter newMember: An element to insert into the set.\n\n- Returns: The original member equal to `newMember` if the set already\n   contained such a member; otherwise, `nil`. In some cases, the returned\n   element may be distinguishable from `newMember` by identity comparison\n   or some other means.\n\n- Complexity: This operation is expected to perform O(1)\n   hashing/comparison operations on average (over many insertions to the\n   same set), provided that `Element` implements high-quality hashing.","o":527},{"p":["OrderedSet","UnorderedView","contains(_:)"],"f":[["func",12],[" ",17],["contains",7],["(",17],["_",1],[" ",17],["element",2],[": ",17],["Element",18],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["contains",7],["(",17],["Element",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the given element exists\nin the set.\n\n- Parameter element: An element to look for in the set.\n\n- Returns: `true` if `member` exists in the set; otherwise, `false`.\n\n- Complexity: This operation is expected to perform O(1) comparisons on\n   average, provided that `Element` implements high-quality hashing.","o":529},{"p":["OrderedSet","UnorderedView","isSubset(of:)"],"f":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a subset of\nthe given set.\n\nSet *A* is a subset of another set *B* if every member of *A* is also a\nmember of *B*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    b.isSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing.","o":530},{"p":["OrderedSet","UnorderedView","isSubset(of:)"],"f":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a subset of\nthe given set.\n\nSet *A* is a subset of another set *B* if every member of *A* is also a\nmember of *B*, ignoring the order they appear in the two sets.\n\n    let a: Set<Int> = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    b.isSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","UnorderedView","isSubset(of:)"],"f":[["func",12],[" ",17],["isSubset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isSubset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether this set is a subset of\nthe elements in the given sequence.\n\nSet *A* is a subset of another set *B* if every member of *A* is also a\nmember of *B*, ignoring the order they appear in the two sets.\n\n    let a: Array = [1, 2, 3, 4]\n    let b: OrderedSet<Int>.UnorderedView = [4, 2, 1]\n    b.isSubset(of: a) // true\n\n- Parameter other: A finite sequence.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","UnorderedView","subtract(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["subtract",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["subtract",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the elements of the given set from this set.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let other: OrderedSet<Int>.UnorderedView = [6, 4, 2, 0]\n    set.subtract(other)\n    // set is now [1, 3]\n\n- Parameter other: Another set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing.","o":531},{"p":["OrderedSet","UnorderedView","subtract(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["subtract",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["subtract",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Removes the elements of the given sequence from this set.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    set.subtract([6, 4, 2, 0] as Array)\n    // set is now [1, 3]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","UnorderedView","formUnion(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formUnion",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["formUnion",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Adds the elements of the given set to this set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the set, in the order they appear in `other`.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    let other: OrderedSet<Int>.UnorderedView = [0, 2, 4, 6]\n    set.formUnion(other)\n    // `set` is now `[1, 2, 3, 4, 0, 6]`\n\n- Parameter other: The set of elements to insert.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing.","o":532},{"p":["OrderedSet","UnorderedView","formUnion(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formUnion",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["formUnion",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Adds the elements of the given sequence to this set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the set, in the order they appear in `other`.\n\n    var set: OrderedSet<Int>.UnorderedView = [1, 2, 3, 4]\n    set.formUnion([0, 2, 4, 6])\n    // `set` is now `[1, 2, 3, 4, 0, 6]`\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isStrictSubset(of:)"],"f":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict subset\nof the given set.\n\nSet *A* is a strict subset of another set *B* if every member of *A* is\nalso a member of *B* and *B* contains at least one element that is not a\nmember of *A*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    b.isStrictSubset(of: a.unordered) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict subset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isStrictSubset(of:)"],"f":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict subset\nof the given set.\n\nSet *A* is a strict subset of another set *B* if every member of *A* is\nalso a member of *B* and *B* contains at least one element that is not a\nmember of *A*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    b.isStrictSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict subset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isStrictSubset(of:)"],"f":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSubset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict subset\nof the given set.\n\nSet *A* is a strict subset of another set *B* if every member of *A* is\nalso a member of *B* and *B* contains at least one element that is not a\nmember of *A*. (Ignoring the order the elements appear in the sets.)\n\n    let a: Set = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    b.isStrictSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict subset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isStrictSubset(of:)"],"f":[["func",12],[" ",17],["isStrictSubset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isStrictSubset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether the set is a strict subset\nof the given sequence.\n\nSet *A* is a strict subset of another set *B* if every member of *A* is\nalso a member of *B* and *B* contains at least one element that is not a\nmember of *A*. (Ignoring the order the elements appear in the sets.)\n\n    let a: Array = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    b.isStrictSubset(of: a) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if `self` is a strict subset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","removeSubrange(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeSubrange",7],["(",17],["_",1],[" ",17],["bounds",2],[": ",17],["Range",18,511],["<",17],["Int",18,445],[">)",17]],"s":[["func",12],[" ",17],["removeSubrange",7],["(",17],["Range",18],["<",17],["Int",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the specified subrange of elements from the collection.\n\nAll the elements following the specified subrange are moved to close the\nresulting gap.\n\n- Parameter bounds: The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedSet","removeSubrange(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeSubrange",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["bounds",2],[": ",17],["R",18],[") ",17],["where",12],[" ",17],["R",18],[" : ",17],["RangeExpression",18,438],[", ",17],["R",18],[".",17],["Bound",18],[" == ",17],["Int",18,445]],"s":[["func",12],[" ",17],["removeSubrange",7],["<",17],["R",0],[">(",17],["R",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["R",1,"RangeExpression",438],["R.Bound",2,"Int",445]],"g":[["Element",0,0],["R",0,1]],"d":"Removes the specified subrange of elements from the collection.\n\nAll the elements following the specified subrange are moved to close the\nresulting gap.\n\n- Parameter bounds: The subrange of the collection to remove. The bounds\n  of the range must be valid indices of the collection.\n\n- Complexity: O(`count`)"},{"p":["OrderedSet","updateOrAppend(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["updateOrAppend",7],["(",17],["_",1],[" ",17],["item",2],[": ",17],["Element",18],[") -> ",17],["Element",18],["?",17]],"s":[["func",12],[" ",17],["updateOrAppend",7],["(",17],["Element",18],[") -> ",17],["Element",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Adds the given element to the set unconditionally, either appending it to\nthe set, or replacing an existing value if it's already present.\n\nThis is useful when equal elements can be distinguished by identity\ncomparison or some other means.\n\n- Parameter item: The value to append or replace.\n\n- Returns: The original element that was replaced by this operation, or\n   `nil` if the value was appended to the end of the collection.\n\n- Complexity: The operation is expected to perform amortized O(1) copy,\n   hash, and compare operations on the `Element` type, if it implements\n   high-quality hashing."},{"p":["OrderedSet","updateOrInsert(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["updateOrInsert",7],["(",17],["_",1],[" ",17],["item",2],[": ",17],["Element",18],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,445],[") -> (originalMember",17],[": ",17],["Element",18],["?, index",17],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["updateOrInsert",7],["(",17],["Element",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> (originalMember",17],[": ",17],["Element",18],["?, index",17],[": ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Adds the given element into the set unconditionally, either inserting it\nat the specified index, or replacing an existing value if it's already\npresent.\n\nThis is useful when equal elements can be distinguished by identity\ncomparison or some other means.\n\n- Parameter item: The value to append or replace.\n\n- Parameter index: The index at which to insert the new member if `item`\n   isn't already in the set.\n\n- Returns: The original element that was replaced by this operation, or\n   `nil` if the value was newly inserted into the collection.\n\n- Complexity: The operation is expected to perform amortized O(1) copy,\n   hash, and compare operations on the `Element` type, if it implements\n   high-quality hashing."},{"p":["OrderedSet","reserveCapacity(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reserveCapacity",7],["(",17],["_",1],[" ",17],["minimumCapacity",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["reserveCapacity",7],["(",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Reserves enough space to store the specified number of elements.\n\nThis method ensures that the set has unique mutable storage, with space\nallocated for at least the requested number of elements.\n\nIf you are adding a known number of elements to a set, call this method\nonce before the first insertion to avoid multiple reallocations.\n\nDo not call this method in a loop -- it does not use an exponential\nallocation strategy, so doing that can result in quadratic instead of\nlinear performance.\n\n- Parameter minimumCapacity: The minimum number of elements that the set\n  should be able to store without reallocating its storage.\n\n- Complexity: O(`max(count, minimumCapacity)`)"},{"p":["OrderedSet","formIntersection(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formIntersection",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["formIntersection",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the elements of this set that aren't also in the given one.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.formIntersection(other)\n    // set is now [2, 4]\n\n- Parameter other: A set of elements.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","formIntersection(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formIntersection",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">)",17]],"s":[["func",12],[" ",17],["formIntersection",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the elements of this set that aren't also in the given one.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.formIntersection(other)\n    // set is now [2, 4]\n\n- Parameter other: A set of elements.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","formIntersection(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formIntersection",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["formIntersection",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Removes the elements of this set that aren't also in the given sequence.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    set.formIntersection([6, 4, 2, 0] as Array)\n    // set is now [2, 4]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(*n*) on average where *n* is the number of\n   elements in `other`, if `Element` implements high-quality hashing."},{"p":["OrderedSet","isStrictSuperset(of:)"],"f":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given set.\n\nSet *A* is a strict superset of another set *B* if every member of *B* is\nalso a member of *A* and *A* contains at least one element that is *not*\na member of *B*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    a.isStrictSuperset(of: b.unordered) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict superset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isStrictSuperset(of:)"],"f":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given set.\n\nSet *A* is a strict superset of another set *B* if every member of *B* is\nalso a member of *A* and *A* contains at least one element that is *not*\na member of *B*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    a.isStrictSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict superset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isStrictSuperset(of:)"],"f":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isStrictSuperset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given set.\n\nSet *A* is a strict superset of another set *B* if every member of *B* is\nalso a member of *A* and *A* contains at least one element that is *not*\na member of *B*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Set = [4, 2, 1]\n    a.isStrictSuperset(of: b) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if `self` is a strict superset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isStrictSuperset(of:)"],"f":[["func",12],[" ",17],["isStrictSuperset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isStrictSuperset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether the set is a strict\nsuperset of the given sequence.\n\nSet *A* is a strict superset of another set *B* if every member of *B* is\nalso a member of *A* and *A* contains at least one element that is *not*\na member of *B*. (Ignoring the order the elements appear in the sets.)\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Array = [4, 2, 1]\n    a.isStrictSuperset(of: b) // true\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: `true` if `self` is a strict superset of `other`; otherwise,\n   `false`.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","symmetricDifference(_:)"],"f":[["func",12],[" ",17],["symmetricDifference",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["symmetricDifference",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements that are either in this set or in\n`other`, but not in both.\n\nThe result contains elements from `self` followed by elements in `other`,\nin the same order they appeared in the original sets.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.symmetricDifference(other.unordered) // [1, 3, 6, 0]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","symmetricDifference(_:)"],"f":[["func",12],[" ",17],["symmetricDifference",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["symmetricDifference",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements that are either in this set or in\n`other`, but not in both.\n\nThe result contains elements from `self` followed by elements in `other`,\nin the same order they appeared in the original sets.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.symmetricDifference(other) // [1, 3, 6, 0]\n\n- Parameter other: Another set.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","symmetricDifference(_:)"],"f":[["func",12],[" ",17],["symmetricDifference",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],["> ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["symmetricDifference",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set with the elements that are either in this set or in\n`other`, but not in both.\n\nThe result contains elements from `self` followed by elements in `other`,\nin the same order they appeared in the original input values.\n\n    let set: OrderedSet = [1, 2, 3, 4]\n    let other: Array = [6, 4, 2, 0]\n    set.symmetricDifference(other) // [1, 3, 6, 0]\n\n- Parameter other: A finite sequence of elements.\n\n- Returns: A new set.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average where *n* is\n   the number of elements in `other`, if `Element` implements high-quality\n   hashing."},{"p":["OrderedSet","formSymmetricDifference(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formSymmetricDifference",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["formSymmetricDifference",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replace this set with the elements contained in this set or the given\nset, but not both.\n\nOn return, `self` contains elements originally from `self` followed by\nelements in `other`, in the same order they appeared in the input values.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.formSymmetricDifference(other.unordered)\n    // set is now [1, 3, 6, 0]\n\n- Parameter other: Another set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","formSymmetricDifference(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formSymmetricDifference",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">)",17]],"s":[["func",12],[" ",17],["formSymmetricDifference",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replace this set with the elements contained in this set or the given\nset, but not both.\n\nOn return, `self` contains elements originally from `self` followed by\nelements in `other`, in the same order they appeared in the input values.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.formSymmetricDifference(other)\n    // set is now [1, 3, 6, 0]\n\n- Parameter other: Another set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","formSymmetricDifference(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formSymmetricDifference",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["formSymmetricDifference",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Replace this set with the elements contained in this set or the given\nsequence, but not both.\n\nOn return, `self` contains elements originally from `self` followed by\nelements in `other`, in the same order they first appeared in the input\nvalues.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    set.formSymmetricDifference([6, 4, 2, 0] as Array)\n    // set is now [1, 3, 6, 0]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average where *n* is\n   the number of elements in `other`, if `Element` implements high-quality\n   hashing."},{"p":["OrderedSet","withContiguousStorageIfAvailable(_:)"],"f":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">(",17],["_",1],[" ",17],["body",2],[": (",17],["UnsafeBufferPointer",18,385],["<",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"s":[["func",12],[" ",17],["withContiguousStorageIfAvailable",7],["<",17],["R",0],[">((",17],["UnsafeBufferPointer",18],["<",17],["Element",18],[">) ",17],["throws",12],[" -> ",17],["R",18],[") ",17],["rethrows",12],[" -> ",17],["R",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0],["R",0,1]],"d":"Call `body(p)`, where `p` is a buffer pointer to the collections\ncontiguous storage. Ordered sets always have contiguous storage.\n\n- Parameter body: A function to call. The function must not escape its\n   unsafe buffer pointer argument.\n\n- Returns: The value returned by `body`.\n\n- Complexity: O(1) (ignoring time spent in `body`)","o":393},{"p":["OrderedSet","hash(into:)"],"f":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[" ",17],["hasher",2],[": ",17],["inout",12],[" ",17],["Hasher",18,557],[")",17]],"s":[["func",12],[" ",17],["hash",7],["(",17],["into",1],[": ",17],["inout",12],[" ",17],["Hasher",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Hashes the essential components of this value by feeding them into the\ngiven hasher.\n\nComplexity: O(`count`)","o":345},{"p":["OrderedSet","sort(by:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["sort",7],["(",17],["by",1],[" ",17],["areInIncreasingOrder",2],[": (",17],["Element",18],[", ",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12]],"s":[["func",12],[" ",17],["sort",7],["(",17],["by",1],[": (",17],["Element",18],[", ",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Sorts the collection in place, using the given predicate as the\ncomparison between elements.\n\nWhen you want to sort a collection of elements that don't conform to\nthe `Comparable` protocol, pass a closure to this method that returns\n`true` when the first element should be ordered before the second.\n\nAlternatively, use this method to sort a collection of elements that do\nconform to `Comparable` when you want the sort to be descending instead\nof ascending. Pass the greater-than operator (`>`) operator as the\npredicate.\n\n`areInIncreasingOrder` must be a *strict weak ordering* over the\nelements. That is, for any elements `a`, `b`, and `c`, the following\nconditions must hold:\n\n- `areInIncreasingOrder(a, a)` is always `false`. (Irreflexivity)\n- If `areInIncreasingOrder(a, b)` and `areInIncreasingOrder(b, c)` are\n  both `true`, then `areInIncreasingOrder(a, c)` is also `true`.\n  (Transitive comparability)\n- Two elements are *incomparable* if neither is ordered before the other\n  according to the predicate. If `a` and `b` are incomparable, and `b`\n  and `c` are incomparable, then `a` and `c` are also incomparable.\n  (Transitive incomparability)\n\nThe sorting algorithm is not guaranteed to be stable. A stable sort\npreserves the relative order of elements for which\n`areInIncreasingOrder` does not establish an order.\n\n- Parameter areInIncreasingOrder: A predicate that returns `true` if its\n  first argument should be ordered before its second argument;\n  otherwise, `false`. If `areInIncreasingOrder` throws an error during\n  the sort, the elements may be in a different order, but none will be\n  lost.\n\n- Complexity: O(*n* log *n*), where *n* is the length of the collection."},{"p":["OrderedSet","index(after:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["after",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the position immediately after the given index.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately after `i`.\n\n- Complexity: O(1)","o":450},{"p":["OrderedSet","index(before:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["before",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the position immediately before the given index.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Returns: The index immediately before `i`.\n\n- Complexity: O(1)","o":451},{"p":["OrderedSet","index(_:offsetBy:limitedBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[", ",17],["limitedBy",1],[" ",17],["limit",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[", ",17],["limitedBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns an index that is the specified distance from the given index,\nunless that distance is beyond a given limiting index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, unless the index passed as `limit` prevents offsetting\nbeyond those bounds. (Otherwise the returned value won't be a valid index\nin the set.)\n\n- Parameters:\n  - i: A valid index of the set.\n  - distance: The distance to offset `i`.\n  - limit: A valid index of the collection to use as a limit. If\n    `distance > 0`, `limit` has no effect if it is less than `i`.\n    Likewise, if `distance < 0`, `limit` has no effect if it is greater\n    than `i`.\n- Returns: An index offset by `distance` from the index `i`, unless that\n  index would be beyond `limit` in the direction of movement. In that\n  case, the method returns `nil`.\n\n- Complexity: O(1)","o":452},{"p":["OrderedSet","index(_:offsetBy:)"],"f":[["func",12],[" ",17],["index",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["offsetBy",1],[" ",17],["distance",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["index",7],["(",17],["Int",18],[", ",17],["offsetBy",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns an index that is the specified distance from the given index.\n\nThe value passed as `distance` must not offset `i` beyond the bounds of\nthe collection, or the returned value will not be a valid index.\n\n- Parameters:\n  - i: A valid index of the set.\n  - distance: The distance to offset `i`.\n\n- Returns: An index offset by `distance` from the index `i`. If `distance`\n  is positive, this is the same value as the result of `distance` calls to\n  `index(after:)`. If `distance` is negative, this is the same value as\n  the result of `abs(distance)` calls to `index(before:)`.\n\n- Complexity: O(1)","o":453},{"p":["OrderedSet","union(_:)"],"f":[["func",12],[" ",17],["union",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["union",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements of both this and the given set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the result, in the order they appear in `other`.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [0, 2, 4, 6]\n    a.union(b.unordered) // [1, 2, 3, 4, 0, 6]\n\n- Parameter other: The set of elements to add.\n\n- Complexity: Expected to be O(`self.count` + `other.count`) on average,\n   if `Element` implements high-quality hashing."},{"p":["OrderedSet","union(_:)"],"f":[["func",12],[" ",17],["union",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">",17]],"s":[["func",12],[" ",17],["union",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a new set with the elements of both this and the given set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the result, in the order they appear in `other`.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [0, 2, 4, 6]\n    a.union(b) // [1, 2, 3, 4, 0, 6]\n\n- Parameter other: The set of elements to add.\n\n- Complexity: Expected to be O(`self.count` + `other.count`) on average,\n   if `Element` implements high-quality hashing."},{"p":["OrderedSet","union(_:)"],"f":[["func",12],[" ",17],["union",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],["> ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["union",7],["<",17],["S",0],[">(",17],["S",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a new set with the elements of both this and the given set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the result, in the order they appear in `other`.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Array = [0, 2, 4, 6]\n    a.union(b) // [1, 2, 3, 4, 0, 6]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`self.count` + `other.count`) on average,\n   if `Element` implements high-quality hashing."},{"p":["OrderedSet","append(contentsOf:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["append",7],["<",17],["S",0],[">(",17],["contentsOf",1],[" ",17],["elements",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["append",7],["<",17],["S",0],[">(",17],["contentsOf",1],[": ",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Append the contents of a sequence to the end of the set, excluding\nelements that are already members.\n\nThis is functionally equivalent to `self.formUnion(elements)`, but it's\nmore explicit about how the new members are ordered in the new set.\n\n- Parameter elements: A finite sequence of elements to append.\n\n- Complexity: The operation is expected to perform amortized O(1) copy,\n   hash, and compare operations on the `Element` type, if it implements\n   high-quality hashing."},{"p":["OrderedSet","append(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["append",7],["(",17],["_",1],[" ",17],["item",2],[": ",17],["Element",18],[") -> (inserted",17],[": ",17],["Bool",18,441],[", index",17],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["append",7],["(",17],["Element",18],[") -> (inserted",17],[": ",17],["Bool",18],[", index",17],[": ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Append a new member to the end of the set, if the set doesn't\nalready contain it.\n\n- Parameter item: The element to add to the set.\n\n- Returns: A pair `(inserted, index)`, where `inserted` is a Boolean value\n   indicating whether the operation added a new element, and `index` is\n   the index of `item` in the resulting set.\n\n- Complexity: The operation is expected to perform O(1) copy, hash, and\n   compare operations on the `Element` type, if it implements high-quality\n   hashing."},{"p":["OrderedSet","insert(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["insert",7],["(",17],["_",1],[" ",17],["item",2],[": ",17],["Element",18],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,445],[") -> (inserted",17],[": ",17],["Bool",18,441],[", index",17],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["insert",7],["(",17],["Element",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> (inserted",17],[": ",17],["Bool",18],[", index",17],[": ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Insert a new member to this set at the specified index, if the set doesn't\nalready contain it.\n\n- Parameter item: The element to insert.\n\n- Returns: A pair `(inserted, index)`, where `inserted` is a Boolean value\n   indicating whether the operation added a new element, and `index` is\n   the index of `item` in the resulting set. If `inserted` is false, then\n   the returned `index` may be different from the index requested.\n\n- Complexity: The operation is expected to perform amortized\n   O(`self.count`) copy, hash, and compare operations on the `Element`\n   type, if it implements high-quality hashing. (Insertions need to make\n   room in the storage array to add the inserted element.)"},{"p":["OrderedSet","remove(at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["remove",7],["(",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,445],[") -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["Element",18]],"s":[["func",12],[" ",17],["remove",7],["(",17],["at",1],[": ",17],["Int",18],[") -> ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["Element",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes and returns the element at the specified position.\n\nAll the elements following the specified position are moved to close the\nresulting gap.\n\n- Parameter index: The position of the element to remove. `index` must be\n   a valid index of the collection that is not equal to the collection's\n   end index.\n\n- Returns: The removed element.\n\n- Complexity: O(`count`)"},{"p":["OrderedSet","remove(_:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["remove",7],["(",17],["_",1],[" ",17],["member",2],[": ",17],["Element",18],[") -> ",17],["Element",18],["?",17]],"s":[["func",12],[" ",17],["remove",7],["(",17],["Element",18],[") -> ",17],["Element",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the given element from the set.\n\n- Parameter member: The element of the set to remove.\n\n- Returns: The element equal to `member` if `member` is contained in the\n   set; otherwise, `nil`. In some cases, the returned element may be\n   distinguishable from `newMember` by identity comparison or some other\n   means.\n\n- Complexity: O(`count`). Removing an element from the middle of the\n   underlying ordered set needs to rearrange the remaining elements to\n   close the resulting gap.\n\n   Removing the last element only takes (amortized) O(1)\n   hashing/comparisons operations, if `Element` implements high quality\n   hashing."},{"p":["OrderedSet","swapAt(_:_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["swapAt",7],["(",17],["_",1],[" ",17],["i",2],[": ",17],["Int",18,445],[", ",17],["_",1],[" ",17],["j",2],[": ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["swapAt",7],["(",17],["Int",18],[", ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Exchanges the values at the specified indices of the set.\n\nBoth parameters must be valid indices below `endIndex`. Passing the same\nindex as both `i` and `j` has no effect.\n\n- Parameters:\n  - i: The index of the first value to swap.\n  - j: The index of the second value to swap.\n\n- Complexity: O(1) when the set's storage isn't shared with another\n   value; O(`count`) otherwise."},{"p":["OrderedSet","update(_:at:)"],"f":[["@discardableResult",3],[" ",17],["mutating",12],[" ",17],["func",12],[" ",17],["update",7],["(",17],["_",1],[" ",17],["item",2],[": ",17],["Element",18],[", ",17],["at",1],[" ",17],["index",2],[": ",17],["Int",18,445],[") -> ",17],["Element",18]],"s":[["func",12],[" ",17],["update",7],["(",17],["Element",18],[", ",17],["at",1],[": ",17],["Int",18],[") -> ",17],["Element",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replace the member at the given index with a new value that compares equal\nto it.\n\nThis is useful when equal elements can be distinguished by identity\ncomparison or some other means.\n\n- Parameter item: The new value that should replace the original element.\n    `item` must compare equal to the original value.\n\n- Parameter index: The index of the element to be replaced.\n\n- Returns: The original element that was replaced.\n\n- Complexity: Amortized O(1)."},{"p":["OrderedSet","reverse()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["reverse",7],["()",17]],"s":[["func",12],[" ",17],["reverse",7],["()",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Reverses the elements of the ordered set in place.\n\n- Complexity: O(`count`)"},{"p":["OrderedSet","shuffle(using:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["shuffle",7],["<",17],["T",0],[">(",17],["using",1],[" ",17],["generator",2],[": ",17],["inout",12],[" ",17],["T",18],[") ",17],["where",12],[" ",17],["T",18],[" : ",17],["RandomNumberGenerator",18,343]],"s":[["func",12],[" ",17],["shuffle",7],["<",17],["T",0],[">(",17],["using",1],[": ",17],["inout",12],[" ",17],["T",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["T",1,"RandomNumberGenerator",343]],"g":[["Element",0,0],["T",0,1]],"d":"Shuffles the collection in place, using the given generator as a source\nfor randomness.\n\nYou use this method to randomize the elements of a collection when you\nare using a custom random number generator. For example, you can use the\n`shuffle(using:)` method to randomly reorder the elements of an array.\n\n    var names: OrderedSet\n      = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofa\"]\n    names.shuffle(using: &myGenerator)\n    // names == [\"Sofa\", \"Alejandro\", \"Camila\", \"Luis\", \"Diego\", \"Luciana\"]\n\n- Parameter generator: The random number generator to use when shuffling\n  the collection.\n\n- Complexity: O(*n*), where *n* is the length of the collection.\n\n- Note: The algorithm used to shuffle a collection may change in a future\n  version of Swift. If you're passing a generator that results in the\n  same shuffled order each time you run your program, that sequence may\n  change when your program is compiled using a different version of\n  Swift."},{"p":["OrderedSet","shuffle()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["shuffle",7],["()",17]],"s":[["func",12],[" ",17],["shuffle",7],["()",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Shuffles the collection in place.\n\nUse the `shuffle()` method to randomly reorder the elements of an ordered\nset.\n\n    var names: OrderedSet\n      = [\"Alejandro\", \"Camila\", \"Diego\", \"Luciana\", \"Luis\", \"Sofa\"]\n    names.shuffle()\n    // names == [\"Luis\", \"Camila\", \"Luciana\", \"Sofa\", \"Alejandro\", \"Diego\"]\n\nThis method is equivalent to calling `shuffle(using:)`, passing in the\nsystem's default random generator.\n\n- Complexity: O(*n*), where *n* is the length of the collection."},{"p":["OrderedSet","applying(_:)"],"f":[["func",12],[" ",17],["applying",7],["(",17],["_",1],[" ",17],["difference",2],[": ",17],["CollectionDifference",18,547],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18,6],["<",17],["Element",18],[">?",17]],"s":[["func",12],[" ",17],["applying",7],["(",17],["CollectionDifference",18],["<",17],["Element",18],[">) -> ",17],["OrderedSet",18],["<",17],["Element",18],[">?",17]],"a":{"iOS":{"i":"13"},"macOS":{"i":"10.15"},"tvOS":{"i":"13"},"watchOS":{"i":"6"}},"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Applies the given difference to this collection.\n\n- Parameter difference: The difference to be applied.\n\n- Returns: An instance representing the state of the receiver with the\n  difference applied, or `nil` if the difference is incompatible with\n  the receiver's state.\n\n- Complexity: O(*n* + *c*), where *n* is `self.count` and *c*\n  is the number of changes contained by the parameter."},{"p":["OrderedSet","contains(_:)"],"f":[["func",12],[" ",17],["contains",7],["(",17],["_",1],[" ",17],["element",2],[": ",17],["Element",18],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["contains",7],["(",17],["Element",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether the given element exists\nin the set.\n\n- Parameter element: An element to look for in the set.\n\n- Returns: `true` if `member` exists in the set; otherwise, `false`.\n\n- Complexity: This operation is expected to perform O(1) comparisons on\n   average, provided that `Element` implements high-quality hashing."},{"p":["OrderedSet","distance(from:to:)"],"f":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[" ",17],["start",2],[": ",17],["Int",18,445],[", ",17],["to",1],[" ",17],["end",2],[": ",17],["Int",18,445],[") -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["distance",7],["(",17],["from",1],[": ",17],["Int",18],[", ",17],["to",1],[": ",17],["Int",18],[") -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the distance between two indices.\n\n- Parameters:\n  - start: A valid index of the collection.\n  - end: Another valid index of the collection. If `end` is equal to\n    `start`, the result is zero.\n\n- Returns: The distance between `start` and `end`.\n\n- Complexity: O(1)","o":456},{"p":["OrderedSet","isSubset(of:)"],"f":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a subset of\nthe given set.\n\nSet *A* is a subset of another set *B* if every member of *A* is also a\nmember of *B*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    b.isSubset(of: a.unordered) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isSubset(of:)"],"f":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[": ",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a subset of\nthe given set.\n\nSet *A* is a subset of another set *B* if every member of *A* is also a\nmember of *B*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    b.isSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isSubset(of:)"],"f":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[" ",17],["other",2],[": ",17],["Set",18,444],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["func",12],[" ",17],["isSubset",7],["(",17],["of",1],[": ",17],["Set",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value that indicates whether this set is a subset of\nthe given set.\n\nSet *A* is a subset of another set *B* if every member of *A* is also a\nmember of *B*, ignoring the order they appear in the two sets.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Set = [4, 2, 1]\n    b.isSubset(of: a) // true\n\n- Parameter other: Another set.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`self.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","isSubset(of:)"],"f":[["func",12],[" ",17],["isSubset",7],["<",17],["S",0],[">(",17],["of",1],[" ",17],["other",2],[": ",17],["S",18],[") -> ",17],["Bool",18,441],[" ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["isSubset",7],["<",17],["S",0],[">(",17],["of",1],[": ",17],["S",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Returns a Boolean value that indicates whether this set is a subset of\nthe elements in the given sequence.\n\nSet *A* is a subset of another set *B* if every member of *A* is also a\nmember of *B*, ignoring the order they appear in the two sets.\n\n    let a: Array = [1, 2, 3, 4]\n    let b: OrderedSet = [4, 2, 1]\n    b.isSubset(of: a) // true\n\n- Parameter other: A finite sequence.\n\n- Returns: `true` if the set is a subset of `other`; otherwise, `false`.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","subtract(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["subtract",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["subtract",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the elements of the given set from this set.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.subtract(other.unordered)\n    // set is now [1, 3]\n\n- Parameter other: Another set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","subtract(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["subtract",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">)",17]],"s":[["func",12],[" ",17],["subtract",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes the elements of the given set from this set.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    let other: OrderedSet = [6, 4, 2, 0]\n    set.subtract(other)\n    // set is now [1, 3]\n\n- Parameter other: Another set.\n\n- Complexity: Expected to be O(`self.count + other.count`) on average, if\n   `Element` implements high-quality hashing."},{"p":["OrderedSet","subtract(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["subtract",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["subtract",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Removes the elements of the given sequence from this set.\n\n    var set: OrderedSet = [1, 2, 3, 4]\n    set.subtract([6, 4, 2, 0] as Array)\n    // set is now [1, 3]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`self.count` + *n*) on average, where *n*\n   is the number of elements in `other`, if `Element` implements\n   high-quality hashing."},{"p":["OrderedSet","formIndex(after:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["after",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replaces the given index with its successor.\n\nThe specified index must be a valid index less than `endIndex`, or the\nreturned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":458},{"p":["OrderedSet","formIndex(before:)"],"f":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[" ",17],["i",2],[": ",17],["inout",12],[" ",17],["Int",18,445],[")",17]],"s":[["func",12],[" ",17],["formIndex",7],["(",17],["before",1],[": ",17],["inout",12],[" ",17],["Int",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Replaces the given index with its predecessor.\n\nThe specified index must be a valid index greater than `startIndex`, or\nthe returned value won't be a valid index in the set.\n\n- Parameter i: A valid index of the collection.\n\n- Complexity: O(1)","o":459},{"p":["OrderedSet","formUnion(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formUnion",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[")",17]],"s":[["func",12],[" ",17],["formUnion",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Adds the elements of the given set to this set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the set, in the order they appear in `other`.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [0, 2, 4, 6]\n    a.formUnion(b.unordered)\n    // a is now [1, 2, 3, 4, 0, 6]\n\n- Parameter other: The set of elements to add.\n\n- Complexity: Expected to be O(`self.count` + `other.count`) on average,\n   if `Element` implements high-quality hashing."},{"p":["OrderedSet","formUnion(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formUnion",7],["(",17],["_",1],[" ",17],["other",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">)",17]],"s":[["func",12],[" ",17],["formUnion",7],["(",17],["OrderedSet",18],["<",17],["Element",18],[">)",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Adds the elements of the given set to this set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the set, in the order they appear in `other`.\n\n    var a: OrderedSet = [1, 2, 3, 4]\n    let b: OrderedSet = [0, 2, 4, 6]\n    a.formUnion(b)\n    // `a` is now `[1, 2, 3, 4, 0, 6]`\n\n- Parameter other: The set of elements to insert.\n\n- Complexity: Expected to be O(`other.count`) on average, if `Element`\n   implements high-quality hashing."},{"p":["OrderedSet","formUnion(_:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["formUnion",7],["<",17],["S",0],[">(",17],["_",1],[" ",17],["other",2],[": ",17],["S",18],[") ",17],["where",12],[" ",17],["Element",18],[" == ",17],["S",18],[".",17],["Element",18],[", ",17],["S",18],[" : ",17],["Sequence",18,387]],"s":[["func",12],[" ",17],["formUnion",7],["<",17],["S",0],[">(",17],["S",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344],["Element",2,"S.Element"],["S",1,"Sequence",387]],"g":[["Element",0,0],["S",0,1]],"d":"Adds the elements of the given sequence to this set.\n\nMembers of `other` that aren't already in `self` get appended to the end\nof the set, in the order they appear in `other`.\n\n    let a: OrderedSet = [1, 2, 3, 4]\n    let b: Array = [0, 2, 4, 6]\n    a.formUnion(b)\n    // a is now [1, 2, 3, 4, 0, 6]\n\n- Parameter other: A finite sequence of elements.\n\n- Complexity: Expected to be O(`self.count` + `other.count`) on average,\n   if `Element` implements high-quality hashing."},{"p":["OrderedSet","lastIndex(of:)"],"f":[["func",12],[" ",17],["lastIndex",7],["(",17],["of",1],[" ",17],["element",2],[": ",17],["Element",18],[") -> ",17],["Int",18,445],["?",17]],"s":[["func",12],[" ",17],["lastIndex",7],["(",17],["of",1],[": ",17],["Element",18],[") -> ",17],["Int",18],["?",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns the index of the given element in the set, or `nil` if the element\nis not a member of the set.\n\n`OrderedSet` members are always unique, so the first index of an element\nis always the same as its last index.\n\n- Complexity: This operation is expected to perform O(1) comparisons on\n   average, provided that `Element` implements high-quality hashing."},{"p":["OrderedSet","partition(by:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["partition",7],["(",17],["by",1],[" ",17],["belongsInSecondPartition",2],[": (",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12],[" -> ",17],["Int",18,445]],"s":[["func",12],[" ",17],["partition",7],["(",17],["by",1],[": (",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12],[" -> ",17],["Int",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Reorders the elements of the set such that all the elements that match the\ngiven predicate are after all the elements that don't match.\n\nAfter partitioning a collection, there is a pivot index `p` where\nno element before `p` satisfies the `belongsInSecondPartition`\npredicate and every element at or after `p` satisfies\n`belongsInSecondPartition`.\n\nIn the following example, an ordered set of numbers is partitioned by a\npredicate that matches elements greater than 30.\n\n    var numbers: OrderedSet = [30, 40, 20, 30, 30, 60, 10]\n    let p = numbers.partition(by: { $0 > 30 })\n    // p == 5\n    // numbers == [30, 10, 20, 30, 30, 60, 40]\n\nThe `numbers` set is now arranged in two partitions. The first partition,\n`numbers[..<p]`, is made up of the elements that are not greater than 30.\nThe second partition, `numbers[p...]`, is made up of the elements that\n*are* greater than 30.\n\n    let first = numbers[..<p]\n    // first == [30, 10, 20, 30, 30]\n    let second = numbers[p...]\n    // second == [60, 40]\n\n- Parameter belongsInSecondPartition: A predicate used to partition\n  the collection. All elements satisfying this predicate are ordered\n  after all elements not satisfying it.\n- Returns: The index of the first element in the reordered collection\n  that matches `belongsInSecondPartition`. If no elements in the\n  collection match `belongsInSecondPartition`, the returned index is\n  equal to the collection's `endIndex`.\n\n- Complexity: O(`count`)"},{"p":["OrderedSet","removeAll(keepingCapacity:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[" ",17],["keepCapacity",2],[": ",17],["Bool",18,441],[" = false)",17]],"s":[["func",12],[" ",17],["removeAll",7],["(",17],["keepingCapacity",1],[": ",17],["Bool",18],[")",17]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes all members from the set.\n\n- Parameter keepingCapacity: If `true`, the set's storage capacity is\n  preserved; if `false`, the underlying storage is released. The default\n  is `false`.\n\n- Complexity: O(`count`)"},{"p":["OrderedSet","removeAll(where:)"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["removeAll",7],["(",17],["where",1],[" ",17],["shouldBeRemoved",2],[": (",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18,441],[") ",17],["rethrows",12]],"s":[["func",12],[" ",17],["removeAll",7],["(",17],["where",1],[": (",17],["Element",18],[") ",17],["throws",12],[" -> ",17],["Bool",18],[") ",17],["rethrows",12]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Removes all the elements that satisfy the given predicate.\n\nUse this method to remove every element in a collection that meets\nparticular criteria. The order of the remaining elements is preserved.\n\nThis example removes all the odd values from an\narray of numbers:\n\n    var numbers: OrderedSet = [5, 6, 7, 8, 9, 10, 11]\n    numbers.removeAll(where: { !$0.isMultiple(of: 2) })\n    // numbers == [6, 8, 10]\n\n- Parameter shouldBeRemoved: A closure that takes an element of the\n  set as its argument and returns a Boolean value indicating\n  whether the element should be removed from the set.\n\n- Complexity: O(`count`)"},{"p":["OrderedSet","encode(to:)"],"f":[["func",12],[" ",17],["encode",7],["(",17],["to",1],[" ",17],["encoder",2],[": ",17],["Encoder",18,560],[") ",17],["throws",12]],"s":[["func",12],[" ",17],["encode",7],["(",17],["to",1],[": ",17],["Encoder",18],[") ",17],["throws",12]],"e":[["Element",1,"Encodable",341],["Element",1,"Hashable",344]],"c":[["Element",1,"Encodable",341],["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Encodes the elements of this ordered set into the given encoder.\n\n- Parameter encoder: The encoder to write data to.","o":342},{"p":["OrderedSet","sort()"],"f":[["mutating",12],[" ",17],["func",12],[" ",17],["sort",7],["()",17]],"s":[["func",12],[" ",17],["sort",7],["()",17]],"e":[["Element",1,"Comparable",363],["Element",1,"Hashable",344]],"c":[["Element",1,"Comparable",363],["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Sorts the set in place.\n\nYou can sort an ordered set of elements that conform to the\n`Comparable` protocol by calling this method. Elements are sorted in\nascending order.\n\nHere's an example of sorting a list of students' names. Strings in Swift\nconform to the `Comparable` protocol, so the names are sorted in\nascending order according to the less-than operator (`<`).\n\n    var students: OrderedSet = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]\n    students.sort()\n    print(students)\n    // Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"\n\nTo sort the elements of your collection in descending order, pass the\ngreater-than operator (`>`) to the `sort(by:)` method.\n\n    students.sort(by: >)\n    print(students)\n    // Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\"\n\nThe sorting algorithm is not guaranteed to be stable. A stable sort\npreserves the relative order of elements that compare equal.\n\n- Complexity: O(*n* log *n*), where *n* is the length of the collection."},{"p":["OrderedDictionary","Values","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["left",2],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[", ",17],["right",2],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[") -> ",17],["Bool",18,441]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18],[", ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18],[") -> ",17],["Bool",18]],"e":[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],"c":[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],"g":[["Key",0,0],["Value",1,0]],"o":383},{"p":["OrderedDictionary","Elements","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["left",2],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[", ",17],["right",2],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[") -> ",17],["Bool",18,441]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[", ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18],[") -> ",17],["Bool",18]],"e":[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],"c":[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],"g":[["Key",0,0],["Value",1,0]],"o":383},{"p":["OrderedDictionary","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["left",2],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">, ",17],["right",2],[": ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">) -> ",17],["Bool",18,441]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">, ",17],["OrderedDictionary",18],["<",17],["Key",18],[", ",17],["Value",18],[">) -> ",17],["Bool",18]],"e":[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],"c":[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],"g":[["Key",0,0],["Value",1,0]],"d":"Returns a Boolean value indicating whether two values are equal.\n\nTwo ordered dictionaries are considered equal if they contain the same\nkey-value pairs, in the same order.\n\n- Complexity: O(`min(left.count, right.count)`)","o":383},{"p":["OrderedSet","SubSequence","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["left",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7],[", ",17],["right",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7],[") -> ",17],["Bool",18,441]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["SubSequence",18],[", ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["SubSequence",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"o":383},{"p":["OrderedSet","UnorderedView","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["left",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[", ",17],["right",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["UnorderedView",18,8],[") -> ",17],["Bool",18,441]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[", ",17],["OrderedSet",18],["<",17],["Element",18],[">.",17],["UnorderedView",18],[") -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value indicating whether two values are equal.\nTwo unordered sets are considered equal if they contain the same\nelements, but not necessarily in the same order.\n\n- Complexity: O(`min(left.count, right.count)`)","o":383},{"p":["OrderedSet","==(_:_:)"],"f":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["left",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">, ",17],["right",2],[": ",17],["OrderedSet",18,6],["<",17],["Element",18],[">) -> ",17],["Bool",18,441]],"s":[["static",12],[" ",17],["func",12],[" ",17],["==",7],[" ",17],["(",17],["OrderedSet",18],["<",17],["Element",18],[">, ",17],["OrderedSet",18],["<",17],["Element",18],[">) -> ",17],["Bool",18]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Returns a Boolean value indicating whether two values are equal.\n\nTwo ordered sets are considered equal if they contain the same\nelements in the same order.\n\n- Complexity: O(`min(left.count, right.count)`)","o":383},{"p":["OrderedDictionary","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["Int",18,445]],"s":[["typealias",12],[" ",17],["Index",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]]},{"p":["OrderedDictionary","Values","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["Int",18,445]],"s":[["typealias",12],[" ",17],["Index",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The index type for a dictionary's values view, `Int`.\n\nIndices in `Values` are integer offsets from the start of the collection.","o":449},{"p":["OrderedDictionary","Values","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = ",17],["Value",18]],"s":[["typealias",12],[" ",17],["Element",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The element type of the collection.","o":394},{"p":["OrderedDictionary","Values","Indices"],"f":[["typealias",12],[" ",17],["Indices",7],[" = ",17],["Range",18,511],["<",17],["Int",18,445],[">",17]],"s":[["typealias",12],[" ",17],["Indices",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The type that represents the indices that are valid for subscripting the\n`Values` collection, in ascending order.","o":454},{"p":["OrderedDictionary","Values","Iterator"],"f":[["typealias",12],[" ",17],["Iterator",7],[" = ",17],["IndexingIterator",18,544],["<",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Values",18,1],[">",17]],"s":[["typealias",12],[" ",17],["Iterator",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The type that allows iteration over the collection's elements.","o":395},{"p":["OrderedDictionary","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = (key",17],[": ",17],["Key",18],[", value",17],[": ",17],["Value",18],[")",17]],"s":[["typealias",12],[" ",17],["Element",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The element type of a dictionary: a tuple containing an individual\nkey-value pair.","o":394},{"p":["OrderedDictionary","Elements","SubSequence","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["Int",18,445]],"s":[["typealias",12],[" ",17],["Index",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The index type for an ordered dictionary: `Int`.\n\nThe indices are integer offsets from the start of the original\n(unsliced) collection.","o":449},{"p":["OrderedDictionary","Elements","SubSequence","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Element",18,321]],"s":[["typealias",12],[" ",17],["Element",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"o":394},{"p":["OrderedDictionary","Elements","SubSequence","Indices"],"f":[["typealias",12],[" ",17],["Indices",7],[" = ",17],["Range",18,511],["<",17],["Int",18,445],[">",17]],"s":[["typealias",12],[" ",17],["Indices",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The type that represents the indices that are valid for subscripting an\nordered dictionary, in ascending order.","o":454},{"p":["OrderedDictionary","Elements","SubSequence","SubSequence"],"f":[["typealias",12],[" ",17],["SubSequence",7],[" = ",17],["OrderedDictionary",18,0],["<",17],["Key",18],[", ",17],["Value",18],[">.",17],["Elements",18,2],[".",17],["SubSequence",18,3]],"s":[["typealias",12],[" ",17],["SubSequence",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"Ordered dictionary subsequences are self-slicing.","o":448},{"p":["OrderedDictionary","Elements","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["Int",18,445]],"s":[["typealias",12],[" ",17],["Index",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The index type for an ordered dictionary: `Int`.\n\nIndices in `Elements` are integer offsets from the start of the\ncollection.","o":449},{"p":["OrderedDictionary","Elements","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = (key",17],[": ",17],["Key",18],[", value",17],[": ",17],["Value",18],[")",17]],"s":[["typealias",12],[" ",17],["Element",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The element type of the collection.","o":394},{"p":["OrderedDictionary","Elements","Indices"],"f":[["typealias",12],[" ",17],["Indices",7],[" = ",17],["Range",18,511],["<",17],["Int",18,445],[">",17]],"s":[["typealias",12],[" ",17],["Indices",7]],"e":[["Key",1,"Hashable",344]],"c":[["Key",1,"Hashable",344]],"g":[["Key",0,0],["Value",1,0]],"d":"The type that represents the indices that are valid for subscripting the\n`Elements` collection, in ascending order.","o":454},{"p":["OrderedSet","SubSequence","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["Int",18,445]],"s":[["typealias",12],[" ",17],["Index",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"The index type for ordered sets, `Int`.\n\nIndices in the order set are integer offsets from the start of the\ncollection, starting at zero for the first element (if exists).","o":449},{"p":["OrderedSet","SubSequence","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["Element",18]],"s":[["typealias",12],[" ",17],["Element",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"o":394},{"p":["OrderedSet","SubSequence","Indices"],"f":[["typealias",12],[" ",17],["Indices",7],[" = ",17],["Array",18,439],["<",17],["Element",18],[">.",17],["SubSequence",18,440],[".",17],["Indices",18,515]],"s":[["typealias",12],[" ",17],["Indices",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"The type that represents the indices that are valid for subscripting an\nordered set, in ascending order.","o":454},{"p":["OrderedSet","SubSequence","Iterator"],"f":[["typealias",12],[" ",17],["Iterator",7],[" = ",17],["IndexingIterator",18,544],["<",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7],[">",17]],"s":[["typealias",12],[" ",17],["Iterator",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"The type that allows iteration over the collection's elements.","o":395},{"p":["OrderedSet","SubSequence","SubSequence"],"f":[["typealias",12],[" ",17],["SubSequence",7],[" = ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["SubSequence",18,7]],"s":[["typealias",12],[" ",17],["SubSequence",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"Ordered set subsequences are self-slicing.","o":448},{"p":["OrderedSet","UnorderedView","Element"],"f":[["typealias",12],[" ",17],["Element",7],[" = ",17],["OrderedSet",18,6],["<",17],["Element",18],[">.",17],["Element",18]],"s":[["typealias",12],[" ",17],["Element",7]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"o":528},{"p":["OrderedSet","Index"],"f":[["typealias",12],[" ",17],["Index",7],[" = ",17],["Int",18,445]],"s":[["typealias",12],[" ",17],["Index",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"The index type for ordered sets, `Int`.\n\n`OrderedSet` indices are integer offsets from the start of the collection,\nstarting at zero for the first element (if exists).","o":449},{"p":["OrderedSet","Indices"],"f":[["typealias",12],[" ",17],["Indices",7],[" = ",17],["Range",18,511],["<",17],["Int",18,445],[">",17]],"s":[["typealias",12],[" ",17],["Indices",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"The type that represents the indices that are valid for subscripting an\nordered set, in ascending order.","o":454},{"p":["OrderedSet","Iterator"],"f":[["typealias",12],[" ",17],["Iterator",7],[" = ",17],["IndexingIterator",18,544],["<",17],["OrderedSet",18,6],["<",17],["Element",18],[">>",17]],"s":[["typealias",12],[" ",17],["Iterator",7]],"e":[["Element",1,"Hashable",344]],"c":[["Element",1,"Hashable",344]],"g":[["Element",0,0]],"d":"The type that allows iteration over an ordered set's elements.","o":395}],"edges":{"conformer":[0,341,[["Key",1,"Encodable",341],["Key",1,"Hashable",344],["Value",1,"Encodable",341]],0,344,[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],0,382,[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],0,387,[["Key",1,"Hashable",344]],0,442,[["Key",1,"Decodable",442],["Key",1,"Hashable",344],["Value",1,"Decodable",442]],0,545,[["Key",1,"Hashable",344]],0,548,[["Key",1,"Hashable",344]],0,553,[["Key",1,"Hashable",344]],0,555,[["Key",1,"Hashable",344]],1,344,[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],1,346,[["Key",1,"Hashable",344]],1,364,[["Key",1,"Hashable",344]],1,382,[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],1,387,[["Key",1,"Hashable",344]],1,446,[["Key",1,"Hashable",344]],1,462,[["Key",1,"Hashable",344]],2,344,[["Key",1,"Hashable",344],["Value",1,"Hashable",344]],2,346,[["Key",1,"Hashable",344]],2,382,[["Key",1,"Hashable",344],["Value",1,"Equatable",382]],2,387,[["Key",1,"Hashable",344]],2,446,[["Key",1,"Hashable",344]],2,462,[["Key",1,"Hashable",344]],2,545,[["Key",1,"Hashable",344]],2,548,[["Key",1,"Hashable",344]],2,553,[["Key",1,"Hashable",344]],3,346,[["Key",1,"Hashable",344]],3,387,[["Key",1,"Hashable",344]],3,446,[["Key",1,"Hashable",344]],3,462,[["Key",1,"Hashable",344]],4,513,[],5,513,[],6,341,[["Element",1,"Encodable",341],["Element",1,"Hashable",344]],6,344,[["Element",1,"Hashable",344]],6,346,[["Element",1,"Hashable",344]],6,382,[["Element",1,"Hashable",344]],6,387,[["Element",1,"Hashable",344]],6,442,[["Element",1,"Decodable",442],["Element",1,"Hashable",344]],6,446,[["Element",1,"Hashable",344]],6,462,[["Element",1,"Hashable",344]],6,545,[["Element",1,"Hashable",344]],6,548,[["Element",1,"Hashable",344]],6,551,[["Element",1,"Hashable",344]],6,553,[["Element",1,"Hashable",344]],7,344,[["Element",1,"Hashable",344]],7,346,[["Element",1,"Hashable",344]],7,382,[["Element",1,"Hashable",344]],7,387,[["Element",1,"Hashable",344]],7,446,[["Element",1,"Hashable",344]],7,462,[["Element",1,"Hashable",344]],8,344,[["Element",1,"Hashable",344]],8,382,[["Element",1,"Hashable",344]],8,516,[["Element",1,"Hashable",344]],8,545,[["Element",1,"Hashable",344]],8,548,[["Element",1,"Hashable",344]],8,551,[["Element",1,"Hashable",344]],8,553,[["Element",1,"Hashable",344]]],"feature":[347,1,347,2,347,3,347,6,347,7,348,1,348,2,348,3,348,6,348,7,349,1,349,6,349,7,350,3,350,7,351,3,351,7,352,3,352,7,353,1,353,2,353,3,353,6,353,7,354,1,354,2,354,3,354,6,354,7,355,1,355,2,355,3,355,6,355,7,356,1,356,2,356,3,356,6,356,7,357,1,357,2,357,3,357,6,357,7,358,1,358,2,358,3,358,6,358,7,359,1,359,2,359,3,359,6,359,7,360,1,360,7,361,1,361,7,362,1,362,6,362,7,368,1,369,1,370,1,371,1,372,1,373,1,374,1,375,1,376,1,377,1,378,1,379,1,380,1,381,1,384,0,384,1,384,2,384,6,384,7,384,8,388,0,388,1,388,2,388,3,388,6,388,7,389,0,389,1,389,2,389,3,389,6,389,7,390,0,390,1,390,2,390,3,390,6,390,7,396,0,396,1,396,2,396,3,396,6,396,7,397,0,397,1,397,2,397,3,397,6,397,7,398,0,398,1,398,2,398,3,398,6,398,7,399,0,399,1,399,2,399,3,399,6,399,7,400,0,400,1,400,2,400,3,400,6,400,7,401,0,401,1,401,2,401,3,401,6,401,7,402,0,402,1,402,2,402,3,402,6,402,7,403,0,403,1,403,2,403,3,403,6,403,7,404,0,404,1,404,2,404,3,404,6,404,7,405,0,405,1,405,2,405,3,405,6,405,7,406,0,407,0,407,1,407,2,407,3,407,6,407,7,408,0,408,1,408,2,408,3,408,6,408,7,409,0,410,1,410,2,410,3,410,6,410,7,411,0,412,0,413,0,413,1,413,2,413,3,413,6,413,7,414,0,414,1,414,2,414,3,414,6,414,7,415,0,415,1,415,2,415,3,415,6,415,7,416,0,416,1,416,2,416,3,416,6,416,7,417,0,418,0,418,1,418,2,418,3,418,6,418,7,419,0,419,1,419,2,419,3,419,6,419,7,420,0,420,1,420,2,420,3,420,6,420,7,421,0,421,1,421,2,421,3,421,6,421,7,422,0,423,0,424,0,424,1,424,2,424,3,424,6,424,7,425,0,425,1,425,2,425,3,425,6,425,7,426,0,427,1,427,6,427,7,428,1,428,6,428,7,429,1,429,6,429,7,430,1,430,6,430,7,431,1,431,6,431,7,432,1,433,1,433,6,433,7,434,1,434,7,435,1,435,6,435,7,436,1,436,6,436,7,437,1,437,6,437,7,463,1,463,2,463,3,463,6,463,7,464,1,464,2,464,3,464,6,464,7,465,1,465,2,465,3,465,6,465,7,466,1,466,2,466,3,466,6,466,7,467,1,467,2,467,3,467,6,467,7,468,1,468,2,468,3,468,6,468,7,469,1,469,2,469,3,469,6,469,7,470,1,470,6,470,7,471,1,471,6,471,7,472,7,473,3,473,7,474,1,474,2,474,3,474,6,474,7,475,1,475,6,475,7,476,1,476,6,476,7,477,1,478,1,478,6,478,7,479,1,482,3,482,7,483,3,483,7,484,3,484,7,485,1,485,2,485,3,485,6,485,7,486,1,486,2,486,3,486,6,486,7,487,1,487,2,487,3,487,6,487,7,488,1,488,2,488,3,488,6,488,7,489,1,489,2,489,3,489,6,489,7,490,1,490,2,490,3,490,6,490,7,491,1,491,2,491,3,491,6,491,7,492,1,492,2,492,3,492,6,492,7,493,1,493,2,493,3,493,6,493,7,494,1,494,2,494,3,494,6,494,7,495,1,495,2,495,3,495,6,495,7,496,1,496,2,496,3,496,6,496,7,497,1,497,2,497,3,497,6,497,7,498,1,498,2,498,3,498,6,498,7,499,1,499,2,499,3,499,6,499,7,500,1,500,2,500,3,500,6,500,7,501,1,501,2,501,3,501,6,501,7,502,1,502,2,502,3,502,6,502,7,503,1,503,2,503,3,503,6,503,7,504,1,504,2,504,3,504,6,504,7,505,1,505,7,506,1,506,6,506,7,507,1,507,6,507,7,508,1,508,6,508,7,509,1,533,8,534,8,535,8,536,8,537,8,538,8,539,8,540,8,541,8,550,0,550,2,550,6,550,8],"member":[1,0,2,0,3,2,4,3,5,0,7,6,8,6,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,0,18,0,19,0,20,0,21,0,22,6,23,8,24,8,25,8,26,8,27,8,28,8,29,6,30,6,31,6,32,6,33,6,34,6,35,6,36,6,37,6,38,6,39,6,40,1,41,3,42,3,43,2,44,2,45,0,46,0,47,7,48,7,49,6,50,6,51,0,52,0,53,0,54,0,55,0,56,0,57,1,58,1,59,1,60,0,61,0,62,2,63,3,64,3,65,3,66,3,67,3,68,3,69,3,70,2,71,2,72,2,73,2,74,2,75,2,76,2,77,2,78,2,79,0,80,6,81,7,82,7,83,7,84,7,85,7,86,6,87,6,88,8,89,8,90,8,91,6,92,6,93,6,94,6,95,6,96,6,97,6,98,0,99,0,100,0,101,0,102,0,103,0,104,0,105,0,106,0,107,0,108,0,109,0,110,0,111,0,112,0,113,0,114,0,115,0,116,1,117,1,118,1,119,1,120,1,121,1,122,1,123,1,124,1,125,1,126,1,127,1,128,1,129,1,130,0,131,0,132,0,133,0,134,0,135,0,136,0,137,0,138,2,139,2,140,3,141,3,142,3,143,3,144,3,145,3,146,4,147,3,148,3,149,3,150,2,151,2,152,2,153,2,154,2,155,2,156,2,157,2,158,2,159,2,160,2,161,2,162,2,163,2,164,2,165,2,166,2,167,2,168,2,169,2,170,2,171,2,172,2,173,2,174,5,175,0,176,0,177,0,178,0,179,0,180,0,181,0,182,6,183,6,184,6,185,6,186,6,187,6,188,6,189,6,190,6,191,6,192,6,193,6,194,7,195,7,196,7,197,7,198,7,199,7,200,7,201,7,202,7,203,6,204,6,205,6,206,6,207,6,208,6,209,6,210,6,211,8,212,8,213,8,214,8,215,8,216,8,217,8,218,8,219,8,220,8,221,8,222,8,223,8,224,8,225,8,226,8,227,8,228,8,229,8,230,8,231,8,232,8,233,8,234,8,235,8,236,8,237,8,238,8,239,8,240,8,241,8,242,8,243,8,244,8,245,8,246,8,247,6,248,6,249,6,250,6,251,6,252,6,253,6,254,6,255,6,256,6,257,6,258,6,259,6,260,6,261,6,262,6,263,6,264,6,265,6,266,6,267,6,268,6,269,6,270,6,271,6,272,6,273,6,274,6,275,6,276,6,277,6,278,6,279,6,280,6,281,6,282,6,283,6,284,6,285,6,286,6,287,6,288,6,289,6,290,6,291,6,292,6,293,6,294,6,295,6,296,6,297,6,298,6,299,6,300,6,301,6,302,6,303,6,304,6,305,6,306,6,307,6,308,6,309,6,310,1,311,2,312,0,313,7,314,8,315,6,316,0,317,1,318,1,319,1,320,1,321,0,322,3,323,3,324,3,325,3,326,2,327,2,328,2,329,7,330,7,331,7,332,7,333,7,334,8,335,6,336,6,337,6]},"sourcemap":[{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Codable.swift","symbols":[29,14,179,57,9,18]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+CustomDebugStringConvertible.swift","symbols":[13,13,53]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+CustomReflectable.swift","symbols":[13,13,52]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+CustomStringConvertible.swift","symbols":[13,13,51]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Elements+SubSequence.swift","symbols":[17,16,3,38,13,64,47,13,66,73,14,143,82,19,323,86,16,4,109,25,146,119,14,140,129,19,322,133,19,324,136,19,325,146,13,63,154,13,69,162,13,67,176,14,141,190,14,142,202,14,148,214,14,149,233,14,145,259,14,144,279,14,147,290,9,42,308,9,41,321,13,68,328,13,65]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Elements.swift","symbols":[15,16,2,33,13,79,52,13,74,61,13,76,94,14,158,101,19,327,104,13,73,107,14,152,117,19,326,121,19,328,131,13,62,142,13,78,156,14,156,170,14,157,182,14,167,194,14,168,213,14,160,239,14,159,259,14,166,271,9,44,287,9,43,297,13,77,304,13,75,326,13,70,332,13,72,339,13,71,346,21,311,353,14,172,374,23,162,397,23,169,443,23,155,464,23,173,480,23,165,502,23,164,514,23,163,530,23,170,548,23,161,562,23,153,576,23,154,589,23,138,602,23,139,614,23,150,629,23,151,644,23,171]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Equatable.swift","symbols":[19,21,312]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+ExpressibleByDictionaryLiteral.swift","symbols":[27,9,11]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Hashable.swift","symbols":[17,14,180]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Initializers.swift","symbols":[20,9,19,51,9,10,78,9,13,114,9,14,149,9,9,199,9,20,241,9,21,277,9,17,327,9,15,359,9,16,394,9,12]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Partial MutableCollection.swift","symbols":[24,23,132,47,23,176,96,23,112,123,23,181,139,23,137,162,23,136,187,23,135]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Partial RangeReplaceableCollection.swift","symbols":[32,23,110,45,23,177,64,23,131,80,23,108,95,23,109,108,23,98,122,23,99,137,23,100,153,23,101,171,23,178]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Sequence.swift","symbols":[14,19,321,18,16,5,37,25,174,50,13,54,59,14,107]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary+Values.swift","symbols":[14,16,1,32,13,58,59,14,116,87,23,117,96,19,318,99,19,320,106,19,317,110,19,319,120,13,57,131,13,59,145,14,120,159,14,121,171,14,126,183,14,127,202,14,123,228,14,122,248,14,125,264,14,118,281,9,40,305,23,124,331,23,128,357,23,119,366,21,310,373,14,129]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedDictionary/OrderedDictionary.swift","symbols":[206,14,0,231,13,55,238,13,60,250,19,316,257,13,61,264,13,56,286,14,113,345,9,46,466,9,45,539,23,106,603,23,105,650,23,104,696,23,103,744,23,102,784,23,114,830,23,115,873,26,133,916,26,134,938,14,130,962,14,175,997,14,111]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Codable.swift","symbols":[16,14,308,30,9,31]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+CustomDebugStringConvertible.swift","symbols":[13,13,91]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+CustomReflectable.swift","symbols":[13,13,87]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+CustomStringConvertible.swift","symbols":[13,13,86]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Diffing.swift","symbols":[18,14,182,94,14,289]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Equatable.swift","symbols":[19,21,315]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+ExpressibleByArrayLiteral.swift","symbols":[28,9,22]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Hashable.swift","symbols":[17,14,270]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Initializers.swift","symbols":[30,9,30,57,9,38,81,9,35,93,9,33,105,9,37,117,9,36,132,9,39]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Insertions.swift","symbols":[86,23,280,104,23,279,157,23,281,185,23,285,212,23,253,241,23,254]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Partial MutableCollection.swift","symbols":[26,23,284,74,23,305,230,23,271,273,23,309,302,23,288,330,23,287,344,23,286]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Partial RangeReplaceableCollection.swift","symbols":[22,23,306,49,23,282,65,23,251,113,23,252,125,23,192,160,23,193,174,23,203,190,23,204,214,23,307]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Partial SetAlgebra+Basics.swift","symbols":[28,9,32,45,14,290,69,23,283]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Partial SetAlgebra+Operations.swift","symbols":[36,23,302,54,26,277,78,23,301,97,26,276,116,23,303,136,26,278,160,26,209,183,23,257,204,26,208,221,23,256,238,26,210,264,23,258,289,26,264,331,23,267,355,26,263,378,23,266,400,26,265,439,23,268,464,26,206,481,23,297,504,26,205,521,23,296,541,26,207,560,23,298]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+Partial SetAlgebra+Predicates.swift","symbols":[38,14,293,66,14,292,87,14,294,113,14,295,150,14,189,173,14,188,178,14,190,200,14,191,237,14,248,263,14,247,286,14,249,310,14,250,352,14,260,378,14,259,401,14,261,425,14,262,460,14,185,492,14,184,511,14,186,540,14,187]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+RandomAccessCollection.swift","symbols":[13,19,337,51,14,269,63,19,335,67,19,336,79,13,80,90,13,96,98,13,93,112,14,272,126,14,273,138,14,299,150,14,300,169,14,275,195,14,274,215,14,291,227,9,50,244,9,49,254,13,94,261,13,92]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+ReserveCapacity.swift","symbols":[33,9,29,57,23,255]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+SubSequence.swift","symbols":[19,16,7,51,19,330,53,19,332,94,14,194,106,19,329,110,19,331,113,19,333,123,13,81,134,13,85,142,13,83,156,14,196,170,14,197,182,14,201,194,14,202,213,14,199,239,14,198,259,14,200,271,9,48,289,9,47,299,13,84,306,13,82,341,21,313,348,14,195]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet+UnorderedView.swift","symbols":[15,16,8,16,21,334,34,9,34,51,13,97,68,13,88,75,13,90,82,13,89,94,21,314,115,14,233,135,9,23,149,9,24,163,9,28,177,9,25,191,9,27,205,9,26,222,14,239,249,23,236,275,23,238,304,23,237,326,23,245,344,26,234,364,23,246,383,26,235,405,26,219,421,23,224,440,26,220,457,23,225,482,26,229,502,23,231,525,26,230,548,23,232,572,26,217,588,23,243,609,26,218,627,23,244,652,14,240,675,14,241,697,14,242,722,14,214,745,14,215,766,14,216,793,14,221,818,14,222,842,14,223,869,14,226,894,14,227,918,14,228,941,14,211,962,14,212,981,14,213]},{"uri":"file:///workspaces/swiftinit.org/ecosystem/packages/.builds/swift-collections@1.0.2/.build/checkouts/swift-collections/Sources/OrderedCollections/OrderedSet/OrderedSet.swift","symbols":[235,14,6,281,13,95,421,14,183,435,14,304]}]}